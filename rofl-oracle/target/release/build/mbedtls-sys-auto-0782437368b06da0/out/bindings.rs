/* automatically generated by rust-bindgen 0.65.1 */

#![allow(dead_code, deref_nullptr, non_snake_case, non_camel_case_types, non_upper_case_globals, invalid_value)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const ERR_MPI_FILE_IO_ERROR: ::types::raw_types::c_int = -2;
pub const ERR_MPI_BAD_INPUT_DATA: ::types::raw_types::c_int = -4;
pub const ERR_MPI_INVALID_CHARACTER: ::types::raw_types::c_int = -6;
pub const ERR_MPI_BUFFER_TOO_SMALL: ::types::raw_types::c_int = -8;
pub const ERR_MPI_NEGATIVE_VALUE: ::types::raw_types::c_int = -10;
pub const ERR_MPI_DIVISION_BY_ZERO: ::types::raw_types::c_int = -12;
pub const ERR_MPI_NOT_ACCEPTABLE: ::types::raw_types::c_int = -14;
pub const ERR_MPI_ALLOC_FAILED: ::types::raw_types::c_int = -16;
pub const MPI_MAX_LIMBS: ::types::raw_types::c_int = 10000;
pub const MPI_WINDOW_SIZE: ::types::raw_types::c_int = 2;
pub const MPI_MAX_SIZE: ::types::raw_types::c_int = 1024;
pub const MPI_MAX_BITS: ::types::raw_types::c_int = 8192;
pub const MPI_MAX_BITS_SCALE100: ::types::raw_types::c_int = 819200;
pub const LN_2_DIV_LN_10_SCALE100: ::types::raw_types::c_int = 332;
pub const MPI_RW_BUFFER_SIZE: ::types::raw_types::c_int = 2484;
pub const ERR_MD_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -20608;
pub const ERR_MD_BAD_INPUT_DATA: ::types::raw_types::c_int = -20736;
pub const ERR_MD_ALLOC_FAILED: ::types::raw_types::c_int = -20864;
pub const ERR_MD_FILE_IO_ERROR: ::types::raw_types::c_int = -20992;
pub const ERR_MD_HW_ACCEL_FAILED: ::types::raw_types::c_int = -21120;
pub const MD_MAX_SIZE: ::types::raw_types::c_int = 64;
pub const MD_MAX_BLOCK_SIZE: ::types::raw_types::c_int = 128;
pub const ERR_THREADING_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -26;
pub const ERR_THREADING_BAD_INPUT_DATA: ::types::raw_types::c_int = -28;
pub const ERR_THREADING_MUTEX_ERROR: ::types::raw_types::c_int = -30;
pub const ERR_ECP_BAD_INPUT_DATA: ::types::raw_types::c_int = -20352;
pub const ERR_ECP_BUFFER_TOO_SMALL: ::types::raw_types::c_int = -20224;
pub const ERR_ECP_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -20096;
pub const ERR_ECP_VERIFY_FAILED: ::types::raw_types::c_int = -19968;
pub const ERR_ECP_ALLOC_FAILED: ::types::raw_types::c_int = -19840;
pub const ERR_ECP_RANDOM_FAILED: ::types::raw_types::c_int = -19712;
pub const ERR_ECP_INVALID_KEY: ::types::raw_types::c_int = -19584;
pub const ERR_ECP_SIG_LEN_MISMATCH: ::types::raw_types::c_int = -19456;
pub const ERR_ECP_HW_ACCEL_FAILED: ::types::raw_types::c_int = -19328;
pub const ERR_ECP_IN_PROGRESS: ::types::raw_types::c_int = -19200;
pub const ECP_DP_MAX: ::types::raw_types::c_int = 12;
pub const ECP_MAX_BITS_MIN: ::types::raw_types::c_int = 521;
pub const ECP_MAX_BITS: ::types::raw_types::c_int = 521;
pub const ECP_MAX_BYTES: ::types::raw_types::c_int = 66;
pub const ECP_MAX_PT_LEN: ::types::raw_types::c_int = 133;
pub const ECP_WINDOW_SIZE: ::types::raw_types::c_int = 4;
pub const ECP_FIXED_POINT_OPTIM: ::types::raw_types::c_int = 1;
pub const ECP_PF_UNCOMPRESSED: ::types::raw_types::c_int = 0;
pub const ECP_PF_COMPRESSED: ::types::raw_types::c_int = 1;
pub const ECP_TLS_NAMED_CURVE: ::types::raw_types::c_int = 3;
pub const ERR_RSA_BAD_INPUT_DATA: ::types::raw_types::c_int = -16512;
pub const ERR_RSA_INVALID_PADDING: ::types::raw_types::c_int = -16640;
pub const ERR_RSA_KEY_GEN_FAILED: ::types::raw_types::c_int = -16768;
pub const ERR_RSA_KEY_CHECK_FAILED: ::types::raw_types::c_int = -16896;
pub const ERR_RSA_PUBLIC_FAILED: ::types::raw_types::c_int = -17024;
pub const ERR_RSA_PRIVATE_FAILED: ::types::raw_types::c_int = -17152;
pub const ERR_RSA_VERIFY_FAILED: ::types::raw_types::c_int = -17280;
pub const ERR_RSA_OUTPUT_TOO_LARGE: ::types::raw_types::c_int = -17408;
pub const ERR_RSA_RNG_FAILED: ::types::raw_types::c_int = -17536;
pub const ERR_RSA_UNSUPPORTED_OPERATION: ::types::raw_types::c_int = -17664;
pub const ERR_RSA_HW_ACCEL_FAILED: ::types::raw_types::c_int = -17792;
pub const RSA_PUBLIC: ::types::raw_types::c_int = 0;
pub const RSA_PRIVATE: ::types::raw_types::c_int = 1;
pub const RSA_PKCS_V15: ::types::raw_types::c_int = 0;
pub const RSA_PKCS_V21: ::types::raw_types::c_int = 1;
pub const RSA_SIGN: ::types::raw_types::c_int = 1;
pub const RSA_CRYPT: ::types::raw_types::c_int = 2;
pub const RSA_SALT_LEN_ANY: ::types::raw_types::c_int = -1;
pub const ERR_ASN1_OUT_OF_DATA: ::types::raw_types::c_int = -96;
pub const ERR_ASN1_UNEXPECTED_TAG: ::types::raw_types::c_int = -98;
pub const ERR_ASN1_INVALID_LENGTH: ::types::raw_types::c_int = -100;
pub const ERR_ASN1_LENGTH_MISMATCH: ::types::raw_types::c_int = -102;
pub const ERR_ASN1_INVALID_DATA: ::types::raw_types::c_int = -104;
pub const ERR_ASN1_ALLOC_FAILED: ::types::raw_types::c_int = -106;
pub const ERR_ASN1_BUF_TOO_SMALL: ::types::raw_types::c_int = -108;
pub const ASN1_BOOLEAN: ::types::raw_types::c_int = 1;
pub const ASN1_INTEGER: ::types::raw_types::c_int = 2;
pub const ASN1_BIT_STRING: ::types::raw_types::c_int = 3;
pub const ASN1_OCTET_STRING: ::types::raw_types::c_int = 4;
pub const ASN1_NULL: ::types::raw_types::c_int = 5;
pub const ASN1_OID: ::types::raw_types::c_int = 6;
pub const ASN1_ENUMERATED: ::types::raw_types::c_int = 10;
pub const ASN1_UTF8_STRING: ::types::raw_types::c_int = 12;
pub const ASN1_SEQUENCE: ::types::raw_types::c_int = 16;
pub const ASN1_SET: ::types::raw_types::c_int = 17;
pub const ASN1_PRINTABLE_STRING: ::types::raw_types::c_int = 19;
pub const ASN1_T61_STRING: ::types::raw_types::c_int = 20;
pub const ASN1_IA5_STRING: ::types::raw_types::c_int = 22;
pub const ASN1_UTC_TIME: ::types::raw_types::c_int = 23;
pub const ASN1_GENERALIZED_TIME: ::types::raw_types::c_int = 24;
pub const ASN1_UNIVERSAL_STRING: ::types::raw_types::c_int = 28;
pub const ASN1_BMP_STRING: ::types::raw_types::c_int = 30;
pub const ASN1_PRIMITIVE: ::types::raw_types::c_int = 0;
pub const ASN1_CONSTRUCTED: ::types::raw_types::c_int = 32;
pub const ASN1_CONTEXT_SPECIFIC: ::types::raw_types::c_int = 128;
pub const ASN1_TAG_CLASS_MASK: ::types::raw_types::c_int = 192;
pub const ASN1_TAG_PC_MASK: ::types::raw_types::c_int = 32;
pub const ASN1_TAG_VALUE_MASK: ::types::raw_types::c_int = 31;
pub const ERR_PK_ALLOC_FAILED: ::types::raw_types::c_int = -16256;
pub const ERR_PK_TYPE_MISMATCH: ::types::raw_types::c_int = -16128;
pub const ERR_PK_BAD_INPUT_DATA: ::types::raw_types::c_int = -16000;
pub const ERR_PK_FILE_IO_ERROR: ::types::raw_types::c_int = -15872;
pub const ERR_PK_KEY_INVALID_VERSION: ::types::raw_types::c_int = -15744;
pub const ERR_PK_KEY_INVALID_FORMAT: ::types::raw_types::c_int = -15616;
pub const ERR_PK_UNKNOWN_PK_ALG: ::types::raw_types::c_int = -15488;
pub const ERR_PK_PASSWORD_REQUIRED: ::types::raw_types::c_int = -15360;
pub const ERR_PK_PASSWORD_MISMATCH: ::types::raw_types::c_int = -15232;
pub const ERR_PK_INVALID_PUBKEY: ::types::raw_types::c_int = -15104;
pub const ERR_PK_INVALID_ALG: ::types::raw_types::c_int = -14976;
pub const ERR_PK_UNKNOWN_NAMED_CURVE: ::types::raw_types::c_int = -14848;
pub const ERR_PK_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -14720;
pub const ERR_PK_SIG_LEN_MISMATCH: ::types::raw_types::c_int = -14592;
pub const ERR_PK_HW_ACCEL_FAILED: ::types::raw_types::c_int = -14464;
pub const PK_SIGNATURE_MAX_SIZE: ::types::raw_types::c_int = 0;
pub const PK_DEBUG_MAX_ITEMS: ::types::raw_types::c_int = 3;
pub const X509_MAX_INTERMEDIATE_CA: ::types::raw_types::c_int = 8;
pub const ERR_X509_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -8320;
pub const ERR_X509_UNKNOWN_OID: ::types::raw_types::c_int = -8448;
pub const ERR_X509_INVALID_FORMAT: ::types::raw_types::c_int = -8576;
pub const ERR_X509_INVALID_VERSION: ::types::raw_types::c_int = -8704;
pub const ERR_X509_INVALID_SERIAL: ::types::raw_types::c_int = -8832;
pub const ERR_X509_INVALID_ALG: ::types::raw_types::c_int = -8960;
pub const ERR_X509_INVALID_NAME: ::types::raw_types::c_int = -9088;
pub const ERR_X509_INVALID_DATE: ::types::raw_types::c_int = -9216;
pub const ERR_X509_INVALID_SIGNATURE: ::types::raw_types::c_int = -9344;
pub const ERR_X509_INVALID_EXTENSIONS: ::types::raw_types::c_int = -9472;
pub const ERR_X509_UNKNOWN_VERSION: ::types::raw_types::c_int = -9600;
pub const ERR_X509_UNKNOWN_SIG_ALG: ::types::raw_types::c_int = -9728;
pub const ERR_X509_SIG_MISMATCH: ::types::raw_types::c_int = -9856;
pub const ERR_X509_CERT_VERIFY_FAILED: ::types::raw_types::c_int = -9984;
pub const ERR_X509_CERT_UNKNOWN_FORMAT: ::types::raw_types::c_int = -10112;
pub const ERR_X509_BAD_INPUT_DATA: ::types::raw_types::c_int = -10240;
pub const ERR_X509_ALLOC_FAILED: ::types::raw_types::c_int = -10368;
pub const ERR_X509_FILE_IO_ERROR: ::types::raw_types::c_int = -10496;
pub const ERR_X509_BUFFER_TOO_SMALL: ::types::raw_types::c_int = -10624;
pub const ERR_X509_FATAL_ERROR: ::types::raw_types::c_int = -12288;
pub const X509_BADCERT_EXPIRED: ::types::raw_types::c_int = 1;
pub const X509_BADCERT_REVOKED: ::types::raw_types::c_int = 2;
pub const X509_BADCERT_CN_MISMATCH: ::types::raw_types::c_int = 4;
pub const X509_BADCERT_NOT_TRUSTED: ::types::raw_types::c_int = 8;
pub const X509_BADCRL_NOT_TRUSTED: ::types::raw_types::c_int = 16;
pub const X509_BADCRL_EXPIRED: ::types::raw_types::c_int = 32;
pub const X509_BADCERT_MISSING: ::types::raw_types::c_int = 64;
pub const X509_BADCERT_SKIP_VERIFY: ::types::raw_types::c_int = 128;
pub const X509_BADCERT_OTHER: ::types::raw_types::c_int = 256;
pub const X509_BADCERT_FUTURE: ::types::raw_types::c_int = 512;
pub const X509_BADCRL_FUTURE: ::types::raw_types::c_int = 1024;
pub const X509_BADCERT_KEY_USAGE: ::types::raw_types::c_int = 2048;
pub const X509_BADCERT_EXT_KEY_USAGE: ::types::raw_types::c_int = 4096;
pub const X509_BADCERT_NS_CERT_TYPE: ::types::raw_types::c_int = 8192;
pub const X509_BADCERT_BAD_MD: ::types::raw_types::c_int = 16384;
pub const X509_BADCERT_BAD_PK: ::types::raw_types::c_int = 32768;
pub const X509_BADCERT_BAD_KEY: ::types::raw_types::c_int = 65536;
pub const X509_BADCRL_BAD_MD: ::types::raw_types::c_int = 131072;
pub const X509_BADCRL_BAD_PK: ::types::raw_types::c_int = 262144;
pub const X509_BADCRL_BAD_KEY: ::types::raw_types::c_int = 524288;
pub const X509_SAN_OTHER_NAME: ::types::raw_types::c_int = 0;
pub const X509_SAN_RFC822_NAME: ::types::raw_types::c_int = 1;
pub const X509_SAN_DNS_NAME: ::types::raw_types::c_int = 2;
pub const X509_SAN_X400_ADDRESS_NAME: ::types::raw_types::c_int = 3;
pub const X509_SAN_DIRECTORY_NAME: ::types::raw_types::c_int = 4;
pub const X509_SAN_EDI_PARTY_NAME: ::types::raw_types::c_int = 5;
pub const X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: ::types::raw_types::c_int = 6;
pub const X509_SAN_IP_ADDRESS: ::types::raw_types::c_int = 7;
pub const X509_SAN_REGISTERED_ID: ::types::raw_types::c_int = 8;
pub const X509_KU_DIGITAL_SIGNATURE: ::types::raw_types::c_int = 128;
pub const X509_KU_NON_REPUDIATION: ::types::raw_types::c_int = 64;
pub const X509_KU_KEY_ENCIPHERMENT: ::types::raw_types::c_int = 32;
pub const X509_KU_DATA_ENCIPHERMENT: ::types::raw_types::c_int = 16;
pub const X509_KU_KEY_AGREEMENT: ::types::raw_types::c_int = 8;
pub const X509_KU_KEY_CERT_SIGN: ::types::raw_types::c_int = 4;
pub const X509_KU_CRL_SIGN: ::types::raw_types::c_int = 2;
pub const X509_KU_ENCIPHER_ONLY: ::types::raw_types::c_int = 1;
pub const X509_KU_DECIPHER_ONLY: ::types::raw_types::c_int = 32768;
pub const X509_NS_CERT_TYPE_SSL_CLIENT: ::types::raw_types::c_int = 128;
pub const X509_NS_CERT_TYPE_SSL_SERVER: ::types::raw_types::c_int = 64;
pub const X509_NS_CERT_TYPE_EMAIL: ::types::raw_types::c_int = 32;
pub const X509_NS_CERT_TYPE_OBJECT_SIGNING: ::types::raw_types::c_int = 16;
pub const X509_NS_CERT_TYPE_RESERVED: ::types::raw_types::c_int = 8;
pub const X509_NS_CERT_TYPE_SSL_CA: ::types::raw_types::c_int = 4;
pub const X509_NS_CERT_TYPE_EMAIL_CA: ::types::raw_types::c_int = 2;
pub const X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: ::types::raw_types::c_int = 1;
pub const X509_FORMAT_DER: ::types::raw_types::c_int = 1;
pub const X509_FORMAT_PEM: ::types::raw_types::c_int = 2;
pub const X509_MAX_DN_NAME_SIZE: ::types::raw_types::c_int = 256;
pub const ERR_CIPHER_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -24704;
pub const ERR_CIPHER_BAD_INPUT_DATA: ::types::raw_types::c_int = -24832;
pub const ERR_CIPHER_ALLOC_FAILED: ::types::raw_types::c_int = -24960;
pub const ERR_CIPHER_INVALID_PADDING: ::types::raw_types::c_int = -25088;
pub const ERR_CIPHER_FULL_BLOCK_EXPECTED: ::types::raw_types::c_int = -25216;
pub const ERR_CIPHER_AUTH_FAILED: ::types::raw_types::c_int = -25344;
pub const ERR_CIPHER_INVALID_CONTEXT: ::types::raw_types::c_int = -25472;
pub const ERR_CIPHER_HW_ACCEL_FAILED: ::types::raw_types::c_int = -25600;
pub const CIPHER_VARIABLE_IV_LEN: ::types::raw_types::c_int = 1;
pub const CIPHER_VARIABLE_KEY_LEN: ::types::raw_types::c_int = 2;
pub const MAX_IV_LENGTH: ::types::raw_types::c_int = 16;
pub const MAX_BLOCK_LENGTH: ::types::raw_types::c_int = 16;
pub const MAX_KEY_LENGTH: ::types::raw_types::c_int = 64;
pub const AES_ENCRYPT: ::types::raw_types::c_int = 1;
pub const AES_DECRYPT: ::types::raw_types::c_int = 0;
pub const ERR_AES_INVALID_KEY_LENGTH: ::types::raw_types::c_int = -32;
pub const ERR_AES_INVALID_INPUT_LENGTH: ::types::raw_types::c_int = -34;
pub const ERR_AES_BAD_INPUT_DATA: ::types::raw_types::c_int = -33;
pub const ERR_AES_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -35;
pub const ERR_AES_HW_ACCEL_FAILED: ::types::raw_types::c_int = -37;
pub const TLS_RSA_WITH_NULL_MD5: ::types::raw_types::c_int = 1;
pub const TLS_RSA_WITH_NULL_SHA: ::types::raw_types::c_int = 2;
pub const TLS_RSA_WITH_RC4_128_MD5: ::types::raw_types::c_int = 4;
pub const TLS_RSA_WITH_RC4_128_SHA: ::types::raw_types::c_int = 5;
pub const TLS_RSA_WITH_DES_CBC_SHA: ::types::raw_types::c_int = 9;
pub const TLS_RSA_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 10;
pub const TLS_DHE_RSA_WITH_DES_CBC_SHA: ::types::raw_types::c_int = 21;
pub const TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 22;
pub const TLS_PSK_WITH_NULL_SHA: ::types::raw_types::c_int = 44;
pub const TLS_DHE_PSK_WITH_NULL_SHA: ::types::raw_types::c_int = 45;
pub const TLS_RSA_PSK_WITH_NULL_SHA: ::types::raw_types::c_int = 46;
pub const TLS_RSA_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 47;
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 51;
pub const TLS_RSA_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 53;
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 57;
pub const TLS_RSA_WITH_NULL_SHA256: ::types::raw_types::c_int = 59;
pub const TLS_RSA_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 60;
pub const TLS_RSA_WITH_AES_256_CBC_SHA256: ::types::raw_types::c_int = 61;
pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: ::types::raw_types::c_int = 65;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: ::types::raw_types::c_int = 69;
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 103;
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: ::types::raw_types::c_int = 107;
pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: ::types::raw_types::c_int = 132;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: ::types::raw_types::c_int = 136;
pub const TLS_PSK_WITH_RC4_128_SHA: ::types::raw_types::c_int = 138;
pub const TLS_PSK_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 139;
pub const TLS_PSK_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 140;
pub const TLS_PSK_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 141;
pub const TLS_DHE_PSK_WITH_RC4_128_SHA: ::types::raw_types::c_int = 142;
pub const TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 143;
pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 144;
pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 145;
pub const TLS_RSA_PSK_WITH_RC4_128_SHA: ::types::raw_types::c_int = 146;
pub const TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 147;
pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 148;
pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 149;
pub const TLS_RSA_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 156;
pub const TLS_RSA_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 157;
pub const TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 158;
pub const TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 159;
pub const TLS_PSK_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 168;
pub const TLS_PSK_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 169;
pub const TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 170;
pub const TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 171;
pub const TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 172;
pub const TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 173;
pub const TLS_PSK_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 174;
pub const TLS_PSK_WITH_AES_256_CBC_SHA384: ::types::raw_types::c_int = 175;
pub const TLS_PSK_WITH_NULL_SHA256: ::types::raw_types::c_int = 176;
pub const TLS_PSK_WITH_NULL_SHA384: ::types::raw_types::c_int = 177;
pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 178;
pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: ::types::raw_types::c_int = 179;
pub const TLS_DHE_PSK_WITH_NULL_SHA256: ::types::raw_types::c_int = 180;
pub const TLS_DHE_PSK_WITH_NULL_SHA384: ::types::raw_types::c_int = 181;
pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 182;
pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: ::types::raw_types::c_int = 183;
pub const TLS_RSA_PSK_WITH_NULL_SHA256: ::types::raw_types::c_int = 184;
pub const TLS_RSA_PSK_WITH_NULL_SHA384: ::types::raw_types::c_int = 185;
pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 186;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 190;
pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: ::types::raw_types::c_int = 192;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: ::types::raw_types::c_int = 196;
pub const TLS_ECDH_ECDSA_WITH_NULL_SHA: ::types::raw_types::c_int = 49153;
pub const TLS_ECDH_ECDSA_WITH_RC4_128_SHA: ::types::raw_types::c_int = 49154;
pub const TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 49155;
pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 49156;
pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 49157;
pub const TLS_ECDHE_ECDSA_WITH_NULL_SHA: ::types::raw_types::c_int = 49158;
pub const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: ::types::raw_types::c_int = 49159;
pub const TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 49160;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 49161;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 49162;
pub const TLS_ECDH_RSA_WITH_NULL_SHA: ::types::raw_types::c_int = 49163;
pub const TLS_ECDH_RSA_WITH_RC4_128_SHA: ::types::raw_types::c_int = 49164;
pub const TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 49165;
pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 49166;
pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 49167;
pub const TLS_ECDHE_RSA_WITH_NULL_SHA: ::types::raw_types::c_int = 49168;
pub const TLS_ECDHE_RSA_WITH_RC4_128_SHA: ::types::raw_types::c_int = 49169;
pub const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 49170;
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 49171;
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 49172;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 49187;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: ::types::raw_types::c_int = 49188;
pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 49189;
pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: ::types::raw_types::c_int = 49190;
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 49191;
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: ::types::raw_types::c_int = 49192;
pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 49193;
pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: ::types::raw_types::c_int = 49194;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 49195;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 49196;
pub const TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 49197;
pub const TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 49198;
pub const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 49199;
pub const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 49200;
pub const TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: ::types::raw_types::c_int = 49201;
pub const TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: ::types::raw_types::c_int = 49202;
pub const TLS_ECDHE_PSK_WITH_RC4_128_SHA: ::types::raw_types::c_int = 49203;
pub const TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: ::types::raw_types::c_int = 49204;
pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: ::types::raw_types::c_int = 49205;
pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: ::types::raw_types::c_int = 49206;
pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: ::types::raw_types::c_int = 49207;
pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: ::types::raw_types::c_int = 49208;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA: ::types::raw_types::c_int = 49209;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA256: ::types::raw_types::c_int = 49210;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA384: ::types::raw_types::c_int = 49211;
pub const TLS_RSA_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49212;
pub const TLS_RSA_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49213;
pub const TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49220;
pub const TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49221;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49224;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49225;
pub const TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49226;
pub const TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49227;
pub const TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49228;
pub const TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49229;
pub const TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49230;
pub const TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49231;
pub const TLS_RSA_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49232;
pub const TLS_RSA_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49233;
pub const TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49234;
pub const TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49235;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49244;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49245;
pub const TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49246;
pub const TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49247;
pub const TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49248;
pub const TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49249;
pub const TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49250;
pub const TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49251;
pub const TLS_PSK_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49252;
pub const TLS_PSK_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49253;
pub const TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49254;
pub const TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49255;
pub const TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49256;
pub const TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49257;
pub const TLS_PSK_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49258;
pub const TLS_PSK_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49259;
pub const TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49260;
pub const TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49261;
pub const TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: ::types::raw_types::c_int = 49262;
pub const TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: ::types::raw_types::c_int = 49263;
pub const TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: ::types::raw_types::c_int = 49264;
pub const TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: ::types::raw_types::c_int = 49265;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 49266;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: ::types::raw_types::c_int = 49267;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 49268;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: ::types::raw_types::c_int = 49269;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 49270;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: ::types::raw_types::c_int = 49271;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 49272;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: ::types::raw_types::c_int = 49273;
pub const TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49274;
pub const TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49275;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49276;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49277;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49286;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49287;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49288;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49289;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49290;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49291;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49292;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49293;
pub const TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49294;
pub const TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49295;
pub const TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49296;
pub const TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49297;
pub const TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: ::types::raw_types::c_int = 49298;
pub const TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: ::types::raw_types::c_int = 49299;
pub const TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 49300;
pub const TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: ::types::raw_types::c_int = 49301;
pub const TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 49302;
pub const TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: ::types::raw_types::c_int = 49303;
pub const TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 49304;
pub const TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: ::types::raw_types::c_int = 49305;
pub const TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: ::types::raw_types::c_int = 49306;
pub const TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: ::types::raw_types::c_int = 49307;
pub const TLS_RSA_WITH_AES_128_CCM: ::types::raw_types::c_int = 49308;
pub const TLS_RSA_WITH_AES_256_CCM: ::types::raw_types::c_int = 49309;
pub const TLS_DHE_RSA_WITH_AES_128_CCM: ::types::raw_types::c_int = 49310;
pub const TLS_DHE_RSA_WITH_AES_256_CCM: ::types::raw_types::c_int = 49311;
pub const TLS_RSA_WITH_AES_128_CCM_8: ::types::raw_types::c_int = 49312;
pub const TLS_RSA_WITH_AES_256_CCM_8: ::types::raw_types::c_int = 49313;
pub const TLS_DHE_RSA_WITH_AES_128_CCM_8: ::types::raw_types::c_int = 49314;
pub const TLS_DHE_RSA_WITH_AES_256_CCM_8: ::types::raw_types::c_int = 49315;
pub const TLS_PSK_WITH_AES_128_CCM: ::types::raw_types::c_int = 49316;
pub const TLS_PSK_WITH_AES_256_CCM: ::types::raw_types::c_int = 49317;
pub const TLS_DHE_PSK_WITH_AES_128_CCM: ::types::raw_types::c_int = 49318;
pub const TLS_DHE_PSK_WITH_AES_256_CCM: ::types::raw_types::c_int = 49319;
pub const TLS_PSK_WITH_AES_128_CCM_8: ::types::raw_types::c_int = 49320;
pub const TLS_PSK_WITH_AES_256_CCM_8: ::types::raw_types::c_int = 49321;
pub const TLS_DHE_PSK_WITH_AES_128_CCM_8: ::types::raw_types::c_int = 49322;
pub const TLS_DHE_PSK_WITH_AES_256_CCM_8: ::types::raw_types::c_int = 49323;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM: ::types::raw_types::c_int = 49324;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CCM: ::types::raw_types::c_int = 49325;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: ::types::raw_types::c_int = 49326;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: ::types::raw_types::c_int = 49327;
pub const TLS_ECJPAKE_WITH_AES_128_CCM_8: ::types::raw_types::c_int = 49407;
pub const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: ::types::raw_types::c_int = 52392;
pub const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: ::types::raw_types::c_int = 52393;
pub const TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: ::types::raw_types::c_int = 52394;
pub const TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: ::types::raw_types::c_int = 52395;
pub const TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: ::types::raw_types::c_int = 52396;
pub const TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: ::types::raw_types::c_int = 52397;
pub const TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: ::types::raw_types::c_int = 52398;
pub const CIPHERSUITE_WEAK: ::types::raw_types::c_int = 1;
pub const CIPHERSUITE_SHORT_TAG: ::types::raw_types::c_int = 2;
pub const CIPHERSUITE_NODTLS: ::types::raw_types::c_int = 4;
pub const X509_CRT_VERSION_1: ::types::raw_types::c_int = 0;
pub const X509_CRT_VERSION_2: ::types::raw_types::c_int = 1;
pub const X509_CRT_VERSION_3: ::types::raw_types::c_int = 2;
pub const X509_RFC5280_MAX_SERIAL_LEN: ::types::raw_types::c_int = 32;
pub const X509_RFC5280_UTC_TIME_LEN: ::types::raw_types::c_int = 15;
pub const X509_MAX_FILE_PATH_LEN: ::types::raw_types::c_int = 512;
pub const X509_MAX_VERIFY_CHAIN_SIZE: ::types::raw_types::c_int = 10;
pub const ERR_DHM_BAD_INPUT_DATA: ::types::raw_types::c_int = -12416;
pub const ERR_DHM_READ_PARAMS_FAILED: ::types::raw_types::c_int = -12544;
pub const ERR_DHM_MAKE_PARAMS_FAILED: ::types::raw_types::c_int = -12672;
pub const ERR_DHM_READ_PUBLIC_FAILED: ::types::raw_types::c_int = -12800;
pub const ERR_DHM_MAKE_PUBLIC_FAILED: ::types::raw_types::c_int = -12928;
pub const ERR_DHM_CALC_SECRET_FAILED: ::types::raw_types::c_int = -13056;
pub const ERR_DHM_INVALID_FORMAT: ::types::raw_types::c_int = -13184;
pub const ERR_DHM_ALLOC_FAILED: ::types::raw_types::c_int = -13312;
pub const ERR_DHM_FILE_IO_ERROR: ::types::raw_types::c_int = -13440;
pub const ERR_DHM_HW_ACCEL_FAILED: ::types::raw_types::c_int = -13568;
pub const ERR_DHM_SET_GROUP_FAILED: ::types::raw_types::c_int = -13696;
pub const ERR_OID_NOT_FOUND: ::types::raw_types::c_int = -46;
pub const ERR_OID_BUF_TOO_SMALL: ::types::raw_types::c_int = -11;
pub const OID_X509_EXT_AUTHORITY_KEY_IDENTIFIER: ::types::raw_types::c_int = 1;
pub const OID_X509_EXT_SUBJECT_KEY_IDENTIFIER: ::types::raw_types::c_int = 2;
pub const OID_X509_EXT_KEY_USAGE: ::types::raw_types::c_int = 4;
pub const OID_X509_EXT_CERTIFICATE_POLICIES: ::types::raw_types::c_int = 8;
pub const OID_X509_EXT_POLICY_MAPPINGS: ::types::raw_types::c_int = 16;
pub const OID_X509_EXT_SUBJECT_ALT_NAME: ::types::raw_types::c_int = 32;
pub const OID_X509_EXT_ISSUER_ALT_NAME: ::types::raw_types::c_int = 64;
pub const OID_X509_EXT_SUBJECT_DIRECTORY_ATTRS: ::types::raw_types::c_int = 128;
pub const OID_X509_EXT_BASIC_CONSTRAINTS: ::types::raw_types::c_int = 256;
pub const OID_X509_EXT_NAME_CONSTRAINTS: ::types::raw_types::c_int = 512;
pub const OID_X509_EXT_POLICY_CONSTRAINTS: ::types::raw_types::c_int = 1024;
pub const OID_X509_EXT_EXTENDED_KEY_USAGE: ::types::raw_types::c_int = 2048;
pub const OID_X509_EXT_CRL_DISTRIBUTION_POINTS: ::types::raw_types::c_int = 4096;
pub const OID_X509_EXT_INIHIBIT_ANYPOLICY: ::types::raw_types::c_int = 8192;
pub const OID_X509_EXT_FRESHEST_CRL: ::types::raw_types::c_int = 16384;
pub const OID_X509_EXT_NS_CERT_TYPE: ::types::raw_types::c_int = 65536;
pub const OID_ISO_MEMBER_BODIES: &[u8; 2usize] = b"*\0";
pub const OID_ISO_IDENTIFIED_ORG: &[u8; 2usize] = b"+\0";
pub const OID_ISO_CCITT_DS: &[u8; 2usize] = b"U\0";
pub const OID_ISO_ITU_COUNTRY: &[u8; 2usize] = b"`\0";
pub const OID_COUNTRY_US: [u8; 3usize] = [134u8, 72u8, 0u8];
pub const OID_ORG_RSA_DATA_SECURITY: [u8; 4usize] = [134u8, 247u8, 13u8, 0u8];
pub const OID_RSA_COMPANY: [u8; 7usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 0u8];
pub const OID_ORG_ANSI_X9_62: [u8; 3usize] = [206u8, 61u8, 0u8];
pub const OID_ANSI_X9_62: [u8; 6usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 0u8];
pub const OID_ORG_DOD: &[u8; 2usize] = b"\x06\0";
pub const OID_ORG_OIW: &[u8; 2usize] = b"\x0E\0";
pub const OID_OIW_SECSIG: &[u8; 3usize] = b"\x0E\x03\0";
pub const OID_OIW_SECSIG_ALG: &[u8; 4usize] = b"\x0E\x03\x02\0";
pub const OID_OIW_SECSIG_SHA1: &[u8; 5usize] = b"\x0E\x03\x02\x1A\0";
pub const OID_ORG_CERTICOM: [u8; 3usize] = [129u8, 4u8, 0u8];
pub const OID_CERTICOM: [u8; 4usize] = [43u8, 129u8, 4u8, 0u8];
pub const OID_ORG_TELETRUST: &[u8; 2usize] = b"$\0";
pub const OID_TELETRUST: &[u8; 3usize] = b"+$\0";
pub const OID_ORGANIZATION: &[u8; 2usize] = b"\x01\0";
pub const OID_ISO_ITU_US_ORG: [u8; 5usize] = [96u8, 134u8, 72u8, 1u8, 0u8];
pub const OID_ORG_GOV: &[u8; 2usize] = b"e\0";
pub const OID_GOV: [u8; 6usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 0u8];
pub const OID_ORG_NETSCAPE: [u8; 4usize] = [134u8, 248u8, 66u8, 0u8];
pub const OID_NETSCAPE: [u8; 8usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 0u8];
pub const OID_ID_CE: &[u8; 3usize] = b"U\x1D\0";
pub const OID_NIST_ALG: [u8; 8usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 0u8];
pub const OID_INTERNET: &[u8; 4usize] = b"+\x06\x01\0";
pub const OID_PKIX: &[u8; 7usize] = b"+\x06\x01\x05\x05\x07\0";
pub const OID_AT: &[u8; 3usize] = b"U\x04\0";
pub const OID_AT_CN: &[u8; 4usize] = b"U\x04\x03\0";
pub const OID_AT_SUR_NAME: &[u8; 4usize] = b"U\x04\x04\0";
pub const OID_AT_SERIAL_NUMBER: &[u8; 4usize] = b"U\x04\x05\0";
pub const OID_AT_COUNTRY: &[u8; 4usize] = b"U\x04\x06\0";
pub const OID_AT_LOCALITY: &[u8; 4usize] = b"U\x04\x07\0";
pub const OID_AT_STATE: &[u8; 4usize] = b"U\x04\x08\0";
pub const OID_AT_ORGANIZATION: &[u8; 4usize] = b"U\x04\n\0";
pub const OID_AT_ORG_UNIT: &[u8; 4usize] = b"U\x04\x0B\0";
pub const OID_AT_TITLE: &[u8; 4usize] = b"U\x04\x0C\0";
pub const OID_AT_POSTAL_ADDRESS: &[u8; 4usize] = b"U\x04\x10\0";
pub const OID_AT_POSTAL_CODE: &[u8; 4usize] = b"U\x04\x11\0";
pub const OID_AT_GIVEN_NAME: &[u8; 4usize] = b"U\x04*\0";
pub const OID_AT_INITIALS: &[u8; 4usize] = b"U\x04+\0";
pub const OID_AT_GENERATION_QUALIFIER: &[u8; 4usize] = b"U\x04,\0";
pub const OID_AT_UNIQUE_IDENTIFIER: &[u8; 4usize] = b"U\x04-\0";
pub const OID_AT_DN_QUALIFIER: &[u8; 4usize] = b"U\x04.\0";
pub const OID_AT_PSEUDONYM: &[u8; 4usize] = b"U\x04A\0";
pub const OID_DOMAIN_COMPONENT: [u8; 11usize] = [
    9u8, 146u8, 38u8, 137u8, 147u8, 242u8, 44u8, 100u8, 1u8, 25u8, 0u8,
];
pub const OID_AUTHORITY_KEY_IDENTIFIER: &[u8; 4usize] = b"U\x1D#\0";
pub const OID_SUBJECT_KEY_IDENTIFIER: &[u8; 4usize] = b"U\x1D\x0E\0";
pub const OID_KEY_USAGE: &[u8; 4usize] = b"U\x1D\x0F\0";
pub const OID_CERTIFICATE_POLICIES: &[u8; 4usize] = b"U\x1D \0";
pub const OID_POLICY_MAPPINGS: &[u8; 4usize] = b"U\x1D!\0";
pub const OID_SUBJECT_ALT_NAME: &[u8; 4usize] = b"U\x1D\x11\0";
pub const OID_ISSUER_ALT_NAME: &[u8; 4usize] = b"U\x1D\x12\0";
pub const OID_SUBJECT_DIRECTORY_ATTRS: &[u8; 4usize] = b"U\x1D\t\0";
pub const OID_BASIC_CONSTRAINTS: &[u8; 4usize] = b"U\x1D\x13\0";
pub const OID_NAME_CONSTRAINTS: &[u8; 4usize] = b"U\x1D\x1E\0";
pub const OID_POLICY_CONSTRAINTS: &[u8; 4usize] = b"U\x1D$\0";
pub const OID_EXTENDED_KEY_USAGE: &[u8; 4usize] = b"U\x1D%\0";
pub const OID_CRL_DISTRIBUTION_POINTS: &[u8; 4usize] = b"U\x1D\x1F\0";
pub const OID_INIHIBIT_ANYPOLICY: &[u8; 4usize] = b"U\x1D6\0";
pub const OID_FRESHEST_CRL: &[u8; 4usize] = b"U\x1D.\0";
pub const OID_ANY_POLICY: &[u8; 5usize] = b"U\x1D \0\0";
pub const OID_NS_CERT: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 0u8];
pub const OID_NS_CERT_TYPE: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 1u8, 0u8];
pub const OID_NS_BASE_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 2u8, 0u8];
pub const OID_NS_REVOCATION_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 3u8, 0u8];
pub const OID_NS_CA_REVOCATION_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 4u8, 0u8];
pub const OID_NS_RENEWAL_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 7u8, 0u8];
pub const OID_NS_CA_POLICY_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 8u8, 0u8];
pub const OID_NS_SSL_SERVER_NAME: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 12u8, 0u8];
pub const OID_NS_COMMENT: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 13u8, 0u8];
pub const OID_NS_DATA_TYPE: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 2u8, 0u8];
pub const OID_NS_CERT_SEQUENCE: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 2u8, 5u8, 0u8];
pub const OID_PRIVATE_KEY_USAGE_PERIOD: &[u8; 4usize] = b"U\x1D\x10\0";
pub const OID_CRL_NUMBER: &[u8; 4usize] = b"U\x1D\x14\0";
pub const OID_ANY_EXTENDED_KEY_USAGE: &[u8; 5usize] = b"U\x1D%\0\0";
pub const OID_KP: &[u8; 8usize] = b"+\x06\x01\x05\x05\x07\x03\0";
pub const OID_SERVER_AUTH: &[u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x01\0";
pub const OID_CLIENT_AUTH: &[u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x02\0";
pub const OID_CODE_SIGNING: &[u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x03\0";
pub const OID_EMAIL_PROTECTION: &[u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x04\0";
pub const OID_TIME_STAMPING: &[u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x08\0";
pub const OID_OCSP_SIGNING: &[u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\t\0";
pub const OID_WISUN_FAN: [u8; 10usize] = [43u8, 6u8, 1u8, 4u8, 1u8, 130u8, 228u8, 37u8, 1u8, 0u8];
pub const OID_ON: &[u8; 8usize] = b"+\x06\x01\x05\x05\x07\x08\0";
pub const OID_ON_HW_MODULE_NAME: &[u8; 9usize] = b"+\x06\x01\x05\x05\x07\x08\x04\0";
pub const OID_PKCS: [u8; 8usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 0u8];
pub const OID_PKCS1: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 0u8];
pub const OID_PKCS5: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 0u8];
pub const OID_PKCS9: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 0u8];
pub const OID_PKCS12: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 0u8];
pub const OID_PKCS1_RSA: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 1u8, 0u8];
pub const OID_PKCS1_MD2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 2u8, 0u8];
pub const OID_PKCS1_MD4: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 3u8, 0u8];
pub const OID_PKCS1_MD5: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 4u8, 0u8];
pub const OID_PKCS1_SHA1: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 5u8, 0u8];
pub const OID_PKCS1_SHA224: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 14u8, 0u8];
pub const OID_PKCS1_SHA256: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 11u8, 0u8];
pub const OID_PKCS1_SHA384: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 12u8, 0u8];
pub const OID_PKCS1_SHA512: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 13u8, 0u8];
pub const OID_RSA_SHA_OBS: &[u8; 6usize] = b"+\x0E\x03\x02\x1D\0";
pub const OID_PKCS9_EMAIL: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 1u8, 0u8];
pub const OID_RSASSA_PSS: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 10u8, 0u8];
pub const OID_MGF1: [u8; 10usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 8u8, 0u8];
pub const OID_DIGEST_ALG_MD2: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 2u8, 0u8];
pub const OID_DIGEST_ALG_MD4: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 4u8, 0u8];
pub const OID_DIGEST_ALG_MD5: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 5u8, 0u8];
pub const OID_DIGEST_ALG_SHA1: &[u8; 6usize] = b"+\x0E\x03\x02\x1A\0";
pub const OID_DIGEST_ALG_SHA224: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 4u8, 0u8];
pub const OID_DIGEST_ALG_SHA256: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 1u8, 0u8];
pub const OID_DIGEST_ALG_SHA384: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 2u8, 0u8];
pub const OID_DIGEST_ALG_SHA512: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 3u8, 0u8];
pub const OID_DIGEST_ALG_RIPEMD160: &[u8; 6usize] = b"+$\x03\x02\x01\0";
pub const OID_HMAC_SHA1: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 7u8, 0u8];
pub const OID_HMAC_SHA224: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 8u8, 0u8];
pub const OID_HMAC_SHA256: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 9u8, 0u8];
pub const OID_HMAC_SHA384: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 10u8, 0u8];
pub const OID_HMAC_SHA512: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 11u8, 0u8];
pub const OID_DES_CBC: &[u8; 6usize] = b"+\x0E\x03\x02\x07\0";
pub const OID_DES_EDE3_CBC: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 3u8, 7u8, 0u8];
pub const OID_AES: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 0u8];
pub const OID_AES128_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 5u8, 0u8];
pub const OID_AES128_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 8u8, 0u8];
pub const OID_AES192_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 25u8, 0u8];
pub const OID_AES192_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 28u8, 0u8];
pub const OID_AES256_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 45u8, 0u8];
pub const OID_AES256_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 48u8, 0u8];
pub const OID_PKCS5_PBKDF2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 12u8, 0u8];
pub const OID_PKCS5_PBES2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 13u8, 0u8];
pub const OID_PKCS5_PBMAC1: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 14u8, 0u8];
pub const OID_PKCS5_PBE_MD2_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 1u8, 0u8];
pub const OID_PKCS5_PBE_MD2_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 4u8, 0u8];
pub const OID_PKCS5_PBE_MD5_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 3u8, 0u8];
pub const OID_PKCS5_PBE_MD5_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 6u8, 0u8];
pub const OID_PKCS5_PBE_SHA1_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 10u8, 0u8];
pub const OID_PKCS5_PBE_SHA1_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 11u8, 0u8];
pub const OID_PKCS9_CSR_EXT_REQ: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 14u8, 0u8];
pub const OID_PKCS12_PBE: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 0u8];
pub const OID_PKCS12_PBE_SHA1_RC4_128: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 1u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC4_40: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 2u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_DES3_EDE_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 3u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_DES2_EDE_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 4u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC2_128_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 5u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC2_40_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 6u8, 0u8,
];
pub const OID_EC_ALG_UNRESTRICTED: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 2u8, 1u8, 0u8];
pub const OID_EC_ALG_ECDH: [u8; 6usize] = [43u8, 129u8, 4u8, 1u8, 12u8, 0u8];
pub const OID_EC_GRP_SECP192R1: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 3u8, 1u8, 1u8, 0u8];
pub const OID_EC_GRP_SECP224R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 33u8, 0u8];
pub const OID_EC_GRP_SECP256R1: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 3u8, 1u8, 7u8, 0u8];
pub const OID_EC_GRP_SECP384R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 34u8, 0u8];
pub const OID_EC_GRP_SECP521R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 35u8, 0u8];
pub const OID_EC_GRP_SECP192K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 31u8, 0u8];
pub const OID_EC_GRP_SECP224K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 32u8, 0u8];
pub const OID_EC_GRP_SECP256K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 10u8, 0u8];
pub const OID_EC_BRAINPOOL_V1: &[u8; 9usize] = b"+$\x03\x03\x02\x08\x01\x01\0";
pub const OID_EC_GRP_BP256R1: &[u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\x07\0";
pub const OID_EC_GRP_BP384R1: &[u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\x0B\0";
pub const OID_EC_GRP_BP512R1: &[u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\r\0";
pub const OID_ANSI_X9_62_FIELD_TYPE: [u8; 7usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 1u8, 0u8];
pub const OID_ANSI_X9_62_PRIME_FIELD: [u8; 8usize] =
    [42u8, 134u8, 72u8, 206u8, 61u8, 1u8, 1u8, 0u8];
pub const OID_ANSI_X9_62_SIG: [u8; 7usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 0u8];
pub const OID_ANSI_X9_62_SIG_SHA2: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 0u8];
pub const OID_ECDSA_SHA1: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 1u8, 0u8];
pub const OID_ECDSA_SHA224: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 1u8, 0u8];
pub const OID_ECDSA_SHA256: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 2u8, 0u8];
pub const OID_ECDSA_SHA384: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 3u8, 0u8];
pub const OID_ECDSA_SHA512: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 4u8, 0u8];
pub const ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED: ::types::raw_types::c_int = -52;
pub const ERR_CTR_DRBG_REQUEST_TOO_BIG: ::types::raw_types::c_int = -54;
pub const ERR_CTR_DRBG_INPUT_TOO_BIG: ::types::raw_types::c_int = -56;
pub const ERR_CTR_DRBG_FILE_IO_ERROR: ::types::raw_types::c_int = -58;
pub const CTR_DRBG_BLOCKSIZE: ::types::raw_types::c_int = 16;
pub const CTR_DRBG_KEYSIZE: ::types::raw_types::c_int = 32;
pub const CTR_DRBG_KEYBITS: ::types::raw_types::c_int = 256;
pub const CTR_DRBG_SEEDLEN: ::types::raw_types::c_int = 48;
pub const CTR_DRBG_ENTROPY_LEN: ::types::raw_types::c_int = 48;
pub const CTR_DRBG_RESEED_INTERVAL: ::types::raw_types::c_int = 10000;
pub const CTR_DRBG_MAX_INPUT: ::types::raw_types::c_int = 256;
pub const CTR_DRBG_MAX_REQUEST: ::types::raw_types::c_int = 1024;
pub const CTR_DRBG_MAX_SEED_INPUT: ::types::raw_types::c_int = 384;
pub const CTR_DRBG_PR_OFF: ::types::raw_types::c_int = 0;
pub const CTR_DRBG_PR_ON: ::types::raw_types::c_int = 1;
pub const CTR_DRBG_ENTROPY_NONCE_LEN: ::types::raw_types::c_int = 0;
pub const ERR_HMAC_DRBG_REQUEST_TOO_BIG: ::types::raw_types::c_int = -3;
pub const ERR_HMAC_DRBG_INPUT_TOO_BIG: ::types::raw_types::c_int = -5;
pub const ERR_HMAC_DRBG_FILE_IO_ERROR: ::types::raw_types::c_int = -7;
pub const ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED: ::types::raw_types::c_int = -9;
pub const HMAC_DRBG_RESEED_INTERVAL: ::types::raw_types::c_int = 10000;
pub const HMAC_DRBG_MAX_INPUT: ::types::raw_types::c_int = 256;
pub const HMAC_DRBG_MAX_REQUEST: ::types::raw_types::c_int = 1024;
pub const HMAC_DRBG_MAX_SEED_INPUT: ::types::raw_types::c_int = 384;
pub const HMAC_DRBG_PR_OFF: ::types::raw_types::c_int = 0;
pub const HMAC_DRBG_PR_ON: ::types::raw_types::c_int = 1;
pub const ERR_SSL_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -28800;
pub const ERR_SSL_BAD_INPUT_DATA: ::types::raw_types::c_int = -28928;
pub const ERR_SSL_INVALID_MAC: ::types::raw_types::c_int = -29056;
pub const ERR_SSL_INVALID_RECORD: ::types::raw_types::c_int = -29184;
pub const ERR_SSL_CONN_EOF: ::types::raw_types::c_int = -29312;
pub const ERR_SSL_UNKNOWN_CIPHER: ::types::raw_types::c_int = -29440;
pub const ERR_SSL_NO_CIPHER_CHOSEN: ::types::raw_types::c_int = -29568;
pub const ERR_SSL_NO_RNG: ::types::raw_types::c_int = -29696;
pub const ERR_SSL_NO_CLIENT_CERTIFICATE: ::types::raw_types::c_int = -29824;
pub const ERR_SSL_CERTIFICATE_TOO_LARGE: ::types::raw_types::c_int = -29952;
pub const ERR_SSL_CERTIFICATE_REQUIRED: ::types::raw_types::c_int = -30080;
pub const ERR_SSL_PRIVATE_KEY_REQUIRED: ::types::raw_types::c_int = -30208;
pub const ERR_SSL_CA_CHAIN_REQUIRED: ::types::raw_types::c_int = -30336;
pub const ERR_SSL_UNEXPECTED_MESSAGE: ::types::raw_types::c_int = -30464;
pub const ERR_SSL_FATAL_ALERT_MESSAGE: ::types::raw_types::c_int = -30592;
pub const ERR_SSL_PEER_VERIFY_FAILED: ::types::raw_types::c_int = -30720;
pub const ERR_SSL_PEER_CLOSE_NOTIFY: ::types::raw_types::c_int = -30848;
pub const ERR_SSL_BAD_HS_CLIENT_HELLO: ::types::raw_types::c_int = -30976;
pub const ERR_SSL_BAD_HS_SERVER_HELLO: ::types::raw_types::c_int = -31104;
pub const ERR_SSL_BAD_HS_CERTIFICATE: ::types::raw_types::c_int = -31232;
pub const ERR_SSL_BAD_HS_CERTIFICATE_REQUEST: ::types::raw_types::c_int = -31360;
pub const ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE: ::types::raw_types::c_int = -31488;
pub const ERR_SSL_BAD_HS_SERVER_HELLO_DONE: ::types::raw_types::c_int = -31616;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE: ::types::raw_types::c_int = -31744;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP: ::types::raw_types::c_int = -31872;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS: ::types::raw_types::c_int = -32000;
pub const ERR_SSL_BAD_HS_CERTIFICATE_VERIFY: ::types::raw_types::c_int = -32128;
pub const ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC: ::types::raw_types::c_int = -32256;
pub const ERR_SSL_BAD_HS_FINISHED: ::types::raw_types::c_int = -32384;
pub const ERR_SSL_ALLOC_FAILED: ::types::raw_types::c_int = -32512;
pub const ERR_SSL_HW_ACCEL_FAILED: ::types::raw_types::c_int = -32640;
pub const ERR_SSL_HW_ACCEL_FALLTHROUGH: ::types::raw_types::c_int = -28544;
pub const ERR_SSL_COMPRESSION_FAILED: ::types::raw_types::c_int = -28416;
pub const ERR_SSL_BAD_HS_PROTOCOL_VERSION: ::types::raw_types::c_int = -28288;
pub const ERR_SSL_BAD_HS_NEW_SESSION_TICKET: ::types::raw_types::c_int = -28160;
pub const ERR_SSL_SESSION_TICKET_EXPIRED: ::types::raw_types::c_int = -28032;
pub const ERR_SSL_PK_TYPE_MISMATCH: ::types::raw_types::c_int = -27904;
pub const ERR_SSL_UNKNOWN_IDENTITY: ::types::raw_types::c_int = -27776;
pub const ERR_SSL_INTERNAL_ERROR: ::types::raw_types::c_int = -27648;
pub const ERR_SSL_COUNTER_WRAPPING: ::types::raw_types::c_int = -27520;
pub const ERR_SSL_WAITING_SERVER_HELLO_RENEGO: ::types::raw_types::c_int = -27392;
pub const ERR_SSL_HELLO_VERIFY_REQUIRED: ::types::raw_types::c_int = -27264;
pub const ERR_SSL_BUFFER_TOO_SMALL: ::types::raw_types::c_int = -27136;
pub const ERR_SSL_NO_USABLE_CIPHERSUITE: ::types::raw_types::c_int = -27008;
pub const ERR_SSL_WANT_READ: ::types::raw_types::c_int = -26880;
pub const ERR_SSL_WANT_WRITE: ::types::raw_types::c_int = -26752;
pub const ERR_SSL_TIMEOUT: ::types::raw_types::c_int = -26624;
pub const ERR_SSL_CLIENT_RECONNECT: ::types::raw_types::c_int = -26496;
pub const ERR_SSL_UNEXPECTED_RECORD: ::types::raw_types::c_int = -26368;
pub const ERR_SSL_NON_FATAL: ::types::raw_types::c_int = -26240;
pub const ERR_SSL_INVALID_VERIFY_HASH: ::types::raw_types::c_int = -26112;
pub const ERR_SSL_CONTINUE_PROCESSING: ::types::raw_types::c_int = -25984;
pub const ERR_SSL_ASYNC_IN_PROGRESS: ::types::raw_types::c_int = -25856;
pub const ERR_SSL_EARLY_MESSAGE: ::types::raw_types::c_int = -25728;
pub const ERR_SSL_UNEXPECTED_CID: ::types::raw_types::c_int = -24576;
pub const ERR_SSL_VERSION_MISMATCH: ::types::raw_types::c_int = -24320;
pub const ERR_SSL_CRYPTO_IN_PROGRESS: ::types::raw_types::c_int = -28672;
pub const ERR_SSL_BAD_CONFIG: ::types::raw_types::c_int = -24192;
pub const ERR_SSL_CACHE_ENTRY_NOT_FOUND: ::types::raw_types::c_int = -24064;
pub const SSL_MAJOR_VERSION_3: ::types::raw_types::c_int = 3;
pub const SSL_MINOR_VERSION_0: ::types::raw_types::c_int = 0;
pub const SSL_MINOR_VERSION_1: ::types::raw_types::c_int = 1;
pub const SSL_MINOR_VERSION_2: ::types::raw_types::c_int = 2;
pub const SSL_MINOR_VERSION_3: ::types::raw_types::c_int = 3;
pub const SSL_MINOR_VERSION_4: ::types::raw_types::c_int = 4;
pub const SSL_TRANSPORT_STREAM: ::types::raw_types::c_int = 0;
pub const SSL_TRANSPORT_DATAGRAM: ::types::raw_types::c_int = 1;
pub const SSL_MAX_HOST_NAME_LEN: ::types::raw_types::c_int = 255;
pub const SSL_MAX_ALPN_NAME_LEN: ::types::raw_types::c_int = 255;
pub const SSL_MAX_ALPN_LIST_LEN: ::types::raw_types::c_int = 65535;
pub const SSL_MAX_FRAG_LEN_NONE: ::types::raw_types::c_int = 0;
pub const SSL_MAX_FRAG_LEN_512: ::types::raw_types::c_int = 1;
pub const SSL_MAX_FRAG_LEN_1024: ::types::raw_types::c_int = 2;
pub const SSL_MAX_FRAG_LEN_2048: ::types::raw_types::c_int = 3;
pub const SSL_MAX_FRAG_LEN_4096: ::types::raw_types::c_int = 4;
pub const SSL_MAX_FRAG_LEN_INVALID: ::types::raw_types::c_int = 5;
pub const SSL_IS_CLIENT: ::types::raw_types::c_int = 0;
pub const SSL_IS_SERVER: ::types::raw_types::c_int = 1;
pub const SSL_IS_NOT_FALLBACK: ::types::raw_types::c_int = 0;
pub const SSL_IS_FALLBACK: ::types::raw_types::c_int = 1;
pub const SSL_EXTENDED_MS_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_EXTENDED_MS_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_CID_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_CID_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_ETM_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_ETM_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_COMPRESS_NULL: ::types::raw_types::c_int = 0;
pub const SSL_COMPRESS_DEFLATE: ::types::raw_types::c_int = 1;
pub const SSL_VERIFY_NONE: ::types::raw_types::c_int = 0;
pub const SSL_VERIFY_OPTIONAL: ::types::raw_types::c_int = 1;
pub const SSL_VERIFY_REQUIRED: ::types::raw_types::c_int = 2;
pub const SSL_VERIFY_UNSET: ::types::raw_types::c_int = 3;
pub const SSL_LEGACY_RENEGOTIATION: ::types::raw_types::c_int = 0;
pub const SSL_SECURE_RENEGOTIATION: ::types::raw_types::c_int = 1;
pub const SSL_RENEGOTIATION_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_RENEGOTIATION_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_ANTI_REPLAY_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_ANTI_REPLAY_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_RENEGOTIATION_NOT_ENFORCED: ::types::raw_types::c_int = -1;
pub const SSL_RENEGO_MAX_RECORDS_DEFAULT: ::types::raw_types::c_int = 16;
pub const SSL_LEGACY_NO_RENEGOTIATION: ::types::raw_types::c_int = 0;
pub const SSL_LEGACY_ALLOW_RENEGOTIATION: ::types::raw_types::c_int = 1;
pub const SSL_LEGACY_BREAK_HANDSHAKE: ::types::raw_types::c_int = 2;
pub const SSL_TRUNC_HMAC_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_TRUNC_HMAC_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_TRUNCATED_HMAC_LEN: ::types::raw_types::c_int = 10;
pub const SSL_SESSION_TICKETS_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_SESSION_TICKETS_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_CBC_RECORD_SPLITTING_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_CBC_RECORD_SPLITTING_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_ARC4_ENABLED: ::types::raw_types::c_int = 0;
pub const SSL_ARC4_DISABLED: ::types::raw_types::c_int = 1;
pub const SSL_PRESET_DEFAULT: ::types::raw_types::c_int = 0;
pub const SSL_PRESET_SUITEB: ::types::raw_types::c_int = 2;
pub const SSL_CERT_REQ_CA_LIST_ENABLED: ::types::raw_types::c_int = 1;
pub const SSL_CERT_REQ_CA_LIST_DISABLED: ::types::raw_types::c_int = 0;
pub const SSL_DTLS_SRTP_MKI_UNSUPPORTED: ::types::raw_types::c_int = 0;
pub const SSL_DTLS_SRTP_MKI_SUPPORTED: ::types::raw_types::c_int = 1;
pub const SSL_DTLS_TIMEOUT_DFL_MIN: ::types::raw_types::c_int = 1000;
pub const SSL_DTLS_TIMEOUT_DFL_MAX: ::types::raw_types::c_int = 60000;
pub const SSL_DEFAULT_TICKET_LIFETIME: ::types::raw_types::c_int = 86400;
pub const SSL_MAX_CONTENT_LEN: ::types::raw_types::c_int = 16384;
pub const SSL_IN_CONTENT_LEN: ::types::raw_types::c_int = 16384;
pub const SSL_OUT_CONTENT_LEN: ::types::raw_types::c_int = 16384;
pub const SSL_DTLS_MAX_BUFFERING: ::types::raw_types::c_int = 32768;
pub const SSL_CID_IN_LEN_MAX: ::types::raw_types::c_int = 32;
pub const SSL_CID_OUT_LEN_MAX: ::types::raw_types::c_int = 32;
pub const SSL_CID_PADDING_GRANULARITY: ::types::raw_types::c_int = 16;
pub const SSL_TLS1_3_PADDING_GRANULARITY: ::types::raw_types::c_int = 1;
pub const SSL_VERIFY_DATA_MAX_LEN: ::types::raw_types::c_int = 12;
pub const SSL_EMPTY_RENEGOTIATION_INFO: ::types::raw_types::c_int = 255;
pub const SSL_FALLBACK_SCSV_VALUE: ::types::raw_types::c_int = 22016;
pub const SSL_HASH_NONE: ::types::raw_types::c_int = 0;
pub const SSL_HASH_MD5: ::types::raw_types::c_int = 1;
pub const SSL_HASH_SHA1: ::types::raw_types::c_int = 2;
pub const SSL_HASH_SHA224: ::types::raw_types::c_int = 3;
pub const SSL_HASH_SHA256: ::types::raw_types::c_int = 4;
pub const SSL_HASH_SHA384: ::types::raw_types::c_int = 5;
pub const SSL_HASH_SHA512: ::types::raw_types::c_int = 6;
pub const SSL_SIG_ANON: ::types::raw_types::c_int = 0;
pub const SSL_SIG_RSA: ::types::raw_types::c_int = 1;
pub const SSL_SIG_ECDSA: ::types::raw_types::c_int = 3;
pub const SSL_CERT_TYPE_RSA_SIGN: ::types::raw_types::c_int = 1;
pub const SSL_CERT_TYPE_ECDSA_SIGN: ::types::raw_types::c_int = 64;
pub const SSL_MSG_CHANGE_CIPHER_SPEC: ::types::raw_types::c_int = 20;
pub const SSL_MSG_ALERT: ::types::raw_types::c_int = 21;
pub const SSL_MSG_HANDSHAKE: ::types::raw_types::c_int = 22;
pub const SSL_MSG_APPLICATION_DATA: ::types::raw_types::c_int = 23;
pub const SSL_MSG_CID: ::types::raw_types::c_int = 25;
pub const SSL_ALERT_LEVEL_WARNING: ::types::raw_types::c_int = 1;
pub const SSL_ALERT_LEVEL_FATAL: ::types::raw_types::c_int = 2;
pub const SSL_ALERT_MSG_CLOSE_NOTIFY: ::types::raw_types::c_int = 0;
pub const SSL_ALERT_MSG_UNEXPECTED_MESSAGE: ::types::raw_types::c_int = 10;
pub const SSL_ALERT_MSG_BAD_RECORD_MAC: ::types::raw_types::c_int = 20;
pub const SSL_ALERT_MSG_DECRYPTION_FAILED: ::types::raw_types::c_int = 21;
pub const SSL_ALERT_MSG_RECORD_OVERFLOW: ::types::raw_types::c_int = 22;
pub const SSL_ALERT_MSG_DECOMPRESSION_FAILURE: ::types::raw_types::c_int = 30;
pub const SSL_ALERT_MSG_HANDSHAKE_FAILURE: ::types::raw_types::c_int = 40;
pub const SSL_ALERT_MSG_NO_CERT: ::types::raw_types::c_int = 41;
pub const SSL_ALERT_MSG_BAD_CERT: ::types::raw_types::c_int = 42;
pub const SSL_ALERT_MSG_UNSUPPORTED_CERT: ::types::raw_types::c_int = 43;
pub const SSL_ALERT_MSG_CERT_REVOKED: ::types::raw_types::c_int = 44;
pub const SSL_ALERT_MSG_CERT_EXPIRED: ::types::raw_types::c_int = 45;
pub const SSL_ALERT_MSG_CERT_UNKNOWN: ::types::raw_types::c_int = 46;
pub const SSL_ALERT_MSG_ILLEGAL_PARAMETER: ::types::raw_types::c_int = 47;
pub const SSL_ALERT_MSG_UNKNOWN_CA: ::types::raw_types::c_int = 48;
pub const SSL_ALERT_MSG_ACCESS_DENIED: ::types::raw_types::c_int = 49;
pub const SSL_ALERT_MSG_DECODE_ERROR: ::types::raw_types::c_int = 50;
pub const SSL_ALERT_MSG_DECRYPT_ERROR: ::types::raw_types::c_int = 51;
pub const SSL_ALERT_MSG_EXPORT_RESTRICTION: ::types::raw_types::c_int = 60;
pub const SSL_ALERT_MSG_PROTOCOL_VERSION: ::types::raw_types::c_int = 70;
pub const SSL_ALERT_MSG_INSUFFICIENT_SECURITY: ::types::raw_types::c_int = 71;
pub const SSL_ALERT_MSG_INTERNAL_ERROR: ::types::raw_types::c_int = 80;
pub const SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: ::types::raw_types::c_int = 86;
pub const SSL_ALERT_MSG_USER_CANCELED: ::types::raw_types::c_int = 90;
pub const SSL_ALERT_MSG_NO_RENEGOTIATION: ::types::raw_types::c_int = 100;
pub const SSL_ALERT_MSG_UNSUPPORTED_EXT: ::types::raw_types::c_int = 110;
pub const SSL_ALERT_MSG_UNRECOGNIZED_NAME: ::types::raw_types::c_int = 112;
pub const SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: ::types::raw_types::c_int = 115;
pub const SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: ::types::raw_types::c_int = 120;
pub const SSL_HS_HELLO_REQUEST: ::types::raw_types::c_int = 0;
pub const SSL_HS_CLIENT_HELLO: ::types::raw_types::c_int = 1;
pub const SSL_HS_SERVER_HELLO: ::types::raw_types::c_int = 2;
pub const SSL_HS_HELLO_VERIFY_REQUEST: ::types::raw_types::c_int = 3;
pub const SSL_HS_NEW_SESSION_TICKET: ::types::raw_types::c_int = 4;
pub const SSL_HS_CERTIFICATE: ::types::raw_types::c_int = 11;
pub const SSL_HS_SERVER_KEY_EXCHANGE: ::types::raw_types::c_int = 12;
pub const SSL_HS_CERTIFICATE_REQUEST: ::types::raw_types::c_int = 13;
pub const SSL_HS_SERVER_HELLO_DONE: ::types::raw_types::c_int = 14;
pub const SSL_HS_CERTIFICATE_VERIFY: ::types::raw_types::c_int = 15;
pub const SSL_HS_CLIENT_KEY_EXCHANGE: ::types::raw_types::c_int = 16;
pub const SSL_HS_FINISHED: ::types::raw_types::c_int = 20;
pub const TLS_EXT_SERVERNAME: ::types::raw_types::c_int = 0;
pub const TLS_EXT_SERVERNAME_HOSTNAME: ::types::raw_types::c_int = 0;
pub const TLS_EXT_MAX_FRAGMENT_LENGTH: ::types::raw_types::c_int = 1;
pub const TLS_EXT_TRUNCATED_HMAC: ::types::raw_types::c_int = 4;
pub const TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: ::types::raw_types::c_int = 10;
pub const TLS_EXT_SUPPORTED_POINT_FORMATS: ::types::raw_types::c_int = 11;
pub const TLS_EXT_SIG_ALG: ::types::raw_types::c_int = 13;
pub const TLS_EXT_USE_SRTP: ::types::raw_types::c_int = 14;
pub const TLS_EXT_ALPN: ::types::raw_types::c_int = 16;
pub const TLS_EXT_ENCRYPT_THEN_MAC: ::types::raw_types::c_int = 22;
pub const TLS_EXT_EXTENDED_MASTER_SECRET: ::types::raw_types::c_int = 23;
pub const TLS_EXT_SESSION_TICKET: ::types::raw_types::c_int = 35;
pub const TLS_EXT_CID: ::types::raw_types::c_int = 254;
pub const TLS_EXT_ECJPAKE_KKPP: ::types::raw_types::c_int = 256;
pub const TLS_EXT_RENEGOTIATION_INFO: ::types::raw_types::c_int = 65281;
pub const PSK_MAX_LEN: ::types::raw_types::c_int = 32;
pub const ERR_MD5_HW_ACCEL_FAILED: ::types::raw_types::c_int = -47;
pub const ERR_SHA1_HW_ACCEL_FAILED: ::types::raw_types::c_int = -53;
pub const ERR_SHA1_BAD_INPUT_DATA: ::types::raw_types::c_int = -115;
pub const ERR_SHA256_HW_ACCEL_FAILED: ::types::raw_types::c_int = -55;
pub const ERR_SHA256_BAD_INPUT_DATA: ::types::raw_types::c_int = -116;
pub const ERR_SHA512_HW_ACCEL_FAILED: ::types::raw_types::c_int = -57;
pub const ERR_SHA512_BAD_INPUT_DATA: ::types::raw_types::c_int = -117;
pub const ERR_NET_SOCKET_FAILED: ::types::raw_types::c_int = -66;
pub const ERR_NET_CONNECT_FAILED: ::types::raw_types::c_int = -68;
pub const ERR_NET_BIND_FAILED: ::types::raw_types::c_int = -70;
pub const ERR_NET_LISTEN_FAILED: ::types::raw_types::c_int = -72;
pub const ERR_NET_ACCEPT_FAILED: ::types::raw_types::c_int = -74;
pub const ERR_NET_RECV_FAILED: ::types::raw_types::c_int = -76;
pub const ERR_NET_SEND_FAILED: ::types::raw_types::c_int = -78;
pub const ERR_NET_CONN_RESET: ::types::raw_types::c_int = -80;
pub const ERR_NET_UNKNOWN_HOST: ::types::raw_types::c_int = -82;
pub const ERR_NET_BUFFER_TOO_SMALL: ::types::raw_types::c_int = -67;
pub const ERR_NET_INVALID_CONTEXT: ::types::raw_types::c_int = -69;
pub const ERR_NET_POLL_FAILED: ::types::raw_types::c_int = -71;
pub const ERR_NET_BAD_INPUT_DATA: ::types::raw_types::c_int = -73;
pub const NET_LISTEN_BACKLOG: ::types::raw_types::c_int = 10;
pub const NET_PROTO_TCP: ::types::raw_types::c_int = 0;
pub const NET_PROTO_UDP: ::types::raw_types::c_int = 1;
pub const NET_POLL_READ: ::types::raw_types::c_int = 1;
pub const NET_POLL_WRITE: ::types::raw_types::c_int = 2;
pub const HAVEGE_COLLECT_SIZE: ::types::raw_types::c_int = 1024;
pub const ERR_POLY1305_BAD_INPUT_DATA: ::types::raw_types::c_int = -87;
pub const ERR_POLY1305_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -89;
pub const ERR_POLY1305_HW_ACCEL_FAILED: ::types::raw_types::c_int = -91;
pub const ERR_CHACHA20_BAD_INPUT_DATA: ::types::raw_types::c_int = -81;
pub const ERR_CHACHA20_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -83;
pub const ERR_CHACHA20_HW_ACCEL_FAILED: ::types::raw_types::c_int = -85;
pub const XTEA_ENCRYPT: ::types::raw_types::c_int = 1;
pub const XTEA_DECRYPT: ::types::raw_types::c_int = 0;
pub const ERR_XTEA_INVALID_INPUT_LENGTH: ::types::raw_types::c_int = -40;
pub const ERR_XTEA_HW_ACCEL_FAILED: ::types::raw_types::c_int = -41;
pub const VERSION_MAJOR: ::types::raw_types::c_int = 2;
pub const VERSION_MINOR: ::types::raw_types::c_int = 28;
pub const VERSION_PATCH: ::types::raw_types::c_int = 7;
pub const VERSION_NUMBER: ::types::raw_types::c_int = 35391232;
pub const VERSION_STRING: &[u8; 7usize] = b"2.28.7\0";
pub const VERSION_STRING_FULL: &[u8; 16usize] = b"Mbed TLS 2.28.7\0";
pub const SSL_MIN_MAJOR_VERSION: ::types::raw_types::c_int = 3;
pub const SSL_MIN_MINOR_VERSION: ::types::raw_types::c_int = 3;
pub const SSL_MIN_VALID_MINOR_VERSION: ::types::raw_types::c_int = 1;
pub const SSL_MIN_VALID_MAJOR_VERSION: ::types::raw_types::c_int = 3;
pub const SSL_MAX_MAJOR_VERSION: ::types::raw_types::c_int = 3;
pub const SSL_MAX_MINOR_VERSION: ::types::raw_types::c_int = 3;
pub const SSL_INITIAL_HANDSHAKE: ::types::raw_types::c_int = 0;
pub const SSL_RENEGOTIATION_IN_PROGRESS: ::types::raw_types::c_int = 1;
pub const SSL_RENEGOTIATION_DONE: ::types::raw_types::c_int = 2;
pub const SSL_RENEGOTIATION_PENDING: ::types::raw_types::c_int = 3;
pub const SSL_RETRANS_PREPARING: ::types::raw_types::c_int = 0;
pub const SSL_RETRANS_SENDING: ::types::raw_types::c_int = 1;
pub const SSL_RETRANS_WAITING: ::types::raw_types::c_int = 2;
pub const SSL_RETRANS_FINISHED: ::types::raw_types::c_int = 3;
pub const SSL_COMPRESSION_ADD: ::types::raw_types::c_int = 0;
pub const SSL_MAC_ADD: ::types::raw_types::c_int = 48;
pub const SSL_PADDING_ADD: ::types::raw_types::c_int = 256;
pub const SSL_MAX_CID_EXPANSION: ::types::raw_types::c_int = 0;
pub const SSL_PAYLOAD_OVERHEAD: ::types::raw_types::c_int = 320;
pub const SSL_IN_PAYLOAD_LEN: ::types::raw_types::c_int = 16704;
pub const SSL_OUT_PAYLOAD_LEN: ::types::raw_types::c_int = 16704;
pub const SSL_MAX_BUFFERED_HS: ::types::raw_types::c_int = 4;
pub const SSL_MAX_SIG_HASH_ALG_LIST_LEN: ::types::raw_types::c_int = 65534;
pub const SSL_MAX_CURVE_LIST_LEN: ::types::raw_types::c_int = 65535;
pub const SSL_HEADER_LEN: ::types::raw_types::c_int = 13;
pub const SSL_IN_BUFFER_LEN: ::types::raw_types::c_int = 16717;
pub const SSL_OUT_BUFFER_LEN: ::types::raw_types::c_int = 16717;
pub const TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT: ::types::raw_types::c_int = 1;
pub const TLS_EXT_ECJPAKE_KKPP_OK: ::types::raw_types::c_int = 2;
pub const SSL_MAX_BLOCK_LENGTH: ::types::raw_types::c_int = 16;
pub const SSL_MAX_IV_LENGTH: ::types::raw_types::c_int = 16;
pub const SSL_MAX_KEY_LENGTH: ::types::raw_types::c_int = 32;
pub const SSL_CID_LEN_MAX: ::types::raw_types::c_int = 32;
pub const SSL_COOKIE_TIMEOUT: ::types::raw_types::c_int = 60;
pub const SSL_CACHE_DEFAULT_TIMEOUT: ::types::raw_types::c_int = 86400;
pub const SSL_CACHE_DEFAULT_MAX_ENTRIES: ::types::raw_types::c_int = 50;
pub const ERR_RIPEMD160_HW_ACCEL_FAILED: ::types::raw_types::c_int = -49;
pub const ERR_PLATFORM_HW_ACCEL_FAILED: ::types::raw_types::c_int = -112;
pub const ERR_PLATFORM_FEATURE_UNSUPPORTED: ::types::raw_types::c_int = -114;
pub const PLATFORM_STD_EXIT_SUCCESS: ::types::raw_types::c_int = 0;
pub const PLATFORM_STD_EXIT_FAILURE: ::types::raw_types::c_int = 1;
pub const PLATFORM_STD_NV_SEED_FILE: &[u8; 9usize] = b"seedfile\0";
pub const EXIT_SUCCESS: ::types::raw_types::c_int = 0;
pub const EXIT_FAILURE: ::types::raw_types::c_int = 1;
pub const ERR_PKCS5_BAD_INPUT_DATA: ::types::raw_types::c_int = -12160;
pub const ERR_PKCS5_INVALID_FORMAT: ::types::raw_types::c_int = -12032;
pub const ERR_PKCS5_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -11904;
pub const ERR_PKCS5_PASSWORD_MISMATCH: ::types::raw_types::c_int = -11776;
pub const PKCS5_DECRYPT: ::types::raw_types::c_int = 0;
pub const PKCS5_ENCRYPT: ::types::raw_types::c_int = 1;
pub const ERR_PKCS12_BAD_INPUT_DATA: ::types::raw_types::c_int = -8064;
pub const ERR_PKCS12_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -7936;
pub const ERR_PKCS12_PBE_INVALID_FORMAT: ::types::raw_types::c_int = -7808;
pub const ERR_PKCS12_PASSWORD_MISMATCH: ::types::raw_types::c_int = -7680;
pub const PKCS12_DERIVE_KEY: ::types::raw_types::c_int = 1;
pub const PKCS12_DERIVE_IV: ::types::raw_types::c_int = 2;
pub const PKCS12_DERIVE_MAC_KEY: ::types::raw_types::c_int = 3;
pub const PKCS12_PBE_DECRYPT: ::types::raw_types::c_int = 0;
pub const PKCS12_PBE_ENCRYPT: ::types::raw_types::c_int = 1;
pub const ERR_PEM_NO_HEADER_FOOTER_PRESENT: ::types::raw_types::c_int = -4224;
pub const ERR_PEM_INVALID_DATA: ::types::raw_types::c_int = -4352;
pub const ERR_PEM_ALLOC_FAILED: ::types::raw_types::c_int = -4480;
pub const ERR_PEM_INVALID_ENC_IV: ::types::raw_types::c_int = -4608;
pub const ERR_PEM_UNKNOWN_ENC_ALG: ::types::raw_types::c_int = -4736;
pub const ERR_PEM_PASSWORD_REQUIRED: ::types::raw_types::c_int = -4864;
pub const ERR_PEM_PASSWORD_MISMATCH: ::types::raw_types::c_int = -4992;
pub const ERR_PEM_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -5120;
pub const ERR_PEM_BAD_INPUT_DATA: ::types::raw_types::c_int = -5248;
pub const ERR_PADLOCK_DATA_MISALIGNED: ::types::raw_types::c_int = -48;
pub const MEMORY_ALIGN_MULTIPLE: ::types::raw_types::c_int = 4;
pub const MEMORY_VERIFY_NONE: ::types::raw_types::c_int = 0;
pub const MEMORY_VERIFY_ALLOC: ::types::raw_types::c_int = 1;
pub const MEMORY_VERIFY_FREE: ::types::raw_types::c_int = 2;
pub const MEMORY_VERIFY_ALWAYS: ::types::raw_types::c_int = 3;
pub const ERR_MD4_HW_ACCEL_FAILED: ::types::raw_types::c_int = -45;
pub const ERR_MD2_HW_ACCEL_FAILED: ::types::raw_types::c_int = -43;
pub const ERR_HKDF_BAD_INPUT_DATA: ::types::raw_types::c_int = -24448;
pub const GCM_ENCRYPT: ::types::raw_types::c_int = 1;
pub const GCM_DECRYPT: ::types::raw_types::c_int = 0;
pub const ERR_GCM_AUTH_FAILED: ::types::raw_types::c_int = -18;
pub const ERR_GCM_HW_ACCEL_FAILED: ::types::raw_types::c_int = -19;
pub const ERR_GCM_BAD_INPUT: ::types::raw_types::c_int = -20;
pub const ERR_ERROR_GENERIC_ERROR: ::types::raw_types::c_int = -1;
pub const ERR_ERROR_CORRUPTION_DETECTED: ::types::raw_types::c_int = -110;
pub const ENTROPY_MIN_PLATFORM: ::types::raw_types::c_int = 32;
pub const ENTROPY_MIN_HAVEGE: ::types::raw_types::c_int = 32;
pub const ENTROPY_MIN_HARDCLOCK: ::types::raw_types::c_int = 4;
pub const ENTROPY_MIN_HARDWARE: ::types::raw_types::c_int = 32;
pub const ERR_ENTROPY_SOURCE_FAILED: ::types::raw_types::c_int = -60;
pub const ERR_ENTROPY_MAX_SOURCES: ::types::raw_types::c_int = -62;
pub const ERR_ENTROPY_NO_SOURCES_DEFINED: ::types::raw_types::c_int = -64;
pub const ERR_ENTROPY_NO_STRONG_SOURCE: ::types::raw_types::c_int = -61;
pub const ERR_ENTROPY_FILE_IO_ERROR: ::types::raw_types::c_int = -63;
pub const ENTROPY_MAX_SOURCES: ::types::raw_types::c_int = 20;
pub const ENTROPY_MAX_GATHER: ::types::raw_types::c_int = 128;
pub const ENTROPY_BLOCK_SIZE: ::types::raw_types::c_int = 64;
pub const ENTROPY_MAX_SEED_SIZE: ::types::raw_types::c_int = 1024;
pub const ENTROPY_SOURCE_MANUAL: ::types::raw_types::c_int = 20;
pub const ENTROPY_SOURCE_STRONG: ::types::raw_types::c_int = 1;
pub const ENTROPY_SOURCE_WEAK: ::types::raw_types::c_int = 0;
pub const DES_ENCRYPT: ::types::raw_types::c_int = 1;
pub const DES_DECRYPT: ::types::raw_types::c_int = 0;
pub const ERR_DES_INVALID_INPUT_LENGTH: ::types::raw_types::c_int = -50;
pub const ERR_DES_HW_ACCEL_FAILED: ::types::raw_types::c_int = -51;
pub const DES_KEY_SIZE: ::types::raw_types::c_int = 8;
pub const PRINTF_SIZET: &[u8; 3usize] = b"zu\0";
pub const PRINTF_LONGLONG: &[u8; 4usize] = b"lld\0";
pub const ERR_CMAC_HW_ACCEL_FAILED: ::types::raw_types::c_int = -122;
pub const AES_BLOCK_SIZE: ::types::raw_types::c_int = 16;
pub const DES3_BLOCK_SIZE: ::types::raw_types::c_int = 8;
pub const CIPHER_BLKSIZE_MAX: ::types::raw_types::c_int = 16;
pub const ERR_CHACHAPOLY_BAD_STATE: ::types::raw_types::c_int = -84;
pub const ERR_CHACHAPOLY_AUTH_FAILED: ::types::raw_types::c_int = -86;
pub const ERR_CCM_BAD_INPUT: ::types::raw_types::c_int = -13;
pub const ERR_CCM_AUTH_FAILED: ::types::raw_types::c_int = -15;
pub const ERR_CCM_HW_ACCEL_FAILED: ::types::raw_types::c_int = -17;
pub const CAMELLIA_ENCRYPT: ::types::raw_types::c_int = 1;
pub const CAMELLIA_DECRYPT: ::types::raw_types::c_int = 0;
pub const ERR_CAMELLIA_BAD_INPUT_DATA: ::types::raw_types::c_int = -36;
pub const ERR_CAMELLIA_INVALID_INPUT_LENGTH: ::types::raw_types::c_int = -38;
pub const ERR_CAMELLIA_HW_ACCEL_FAILED: ::types::raw_types::c_int = -39;
pub const BLOWFISH_ENCRYPT: ::types::raw_types::c_int = 1;
pub const BLOWFISH_DECRYPT: ::types::raw_types::c_int = 0;
pub const BLOWFISH_MAX_KEY_BITS: ::types::raw_types::c_int = 448;
pub const BLOWFISH_MIN_KEY_BITS: ::types::raw_types::c_int = 32;
pub const BLOWFISH_ROUNDS: ::types::raw_types::c_int = 16;
pub const BLOWFISH_BLOCKSIZE: ::types::raw_types::c_int = 8;
pub const ERR_BLOWFISH_BAD_INPUT_DATA: ::types::raw_types::c_int = -22;
pub const ERR_BLOWFISH_INVALID_INPUT_LENGTH: ::types::raw_types::c_int = -24;
pub const ERR_BLOWFISH_HW_ACCEL_FAILED: ::types::raw_types::c_int = -23;
pub const ERR_BASE64_BUFFER_TOO_SMALL: ::types::raw_types::c_int = -42;
pub const ERR_BASE64_INVALID_CHARACTER: ::types::raw_types::c_int = -44;
pub const ARIA_ENCRYPT: ::types::raw_types::c_int = 1;
pub const ARIA_DECRYPT: ::types::raw_types::c_int = 0;
pub const ARIA_BLOCKSIZE: ::types::raw_types::c_int = 16;
pub const ARIA_MAX_ROUNDS: ::types::raw_types::c_int = 16;
pub const ARIA_MAX_KEYSIZE: ::types::raw_types::c_int = 32;
pub const ERR_ARIA_BAD_INPUT_DATA: ::types::raw_types::c_int = -92;
pub const ERR_ARIA_INVALID_INPUT_LENGTH: ::types::raw_types::c_int = -94;
pub const ERR_ARIA_FEATURE_UNAVAILABLE: ::types::raw_types::c_int = -90;
pub const ERR_ARIA_HW_ACCEL_FAILED: ::types::raw_types::c_int = -88;
pub const ERR_ARC4_HW_ACCEL_FAILED: ::types::raw_types::c_int = -25;
pub const AESNI_AES: ::types::raw_types::c_int = 33554432;
pub const AESNI_CLMUL: ::types::raw_types::c_int = 2;
pub const AESNI_HAVE_CODE: ::types::raw_types::c_int = 1;
extern "C" {
    #[link_name = "\u{1}mbedtls_printf"]
    pub fn printf(format: *const ::types::raw_types::c_char, ...) -> ::types::raw_types::c_int;
}
pub type iso_c_forbids_empty_translation_units = ::types::raw_types::c_int;
extern "C" {
    #[link_name = "\u{1}mbedtls_platform_zeroize"]
    pub fn platform_zeroize(buf: *mut ::types::raw_types::c_void, len: usize);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_platform_gmtime_r"]
    pub fn platform_gmtime_r(tt: *const time_t, tm_buf: *mut tm) -> *mut tm;
}
pub type mpi_sint = i64;
pub type mpi_uint = u64;
pub type t_udbl = u128;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpi {
    pub s: ::types::raw_types::c_int,
    pub n: usize,
    pub p: *mut mpi_uint,
}
#[test]
fn bindgen_test_layout_mpi() {
    const UNINIT: ::core::mem::MaybeUninit<mpi> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpi>(),
        24usize,
        concat!("Size of: ", stringify!(mpi))
    );
    assert_eq!(
        ::core::mem::align_of::<mpi>(),
        8usize,
        concat!("Alignment of ", stringify!(mpi))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(p))
    );
}
impl Default for mpi {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_init"]
    pub fn mpi_init(X: *mut mpi);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_free"]
    pub fn mpi_free(X: *mut mpi);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_grow"]
    pub fn mpi_grow(X: *mut mpi, nblimbs: usize) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_shrink"]
    pub fn mpi_shrink(X: *mut mpi, nblimbs: usize) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_copy"]
    pub fn mpi_copy(X: *mut mpi, Y: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_swap"]
    pub fn mpi_swap(X: *mut mpi, Y: *mut mpi);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_safe_cond_assign"]
    pub fn mpi_safe_cond_assign(
        X: *mut mpi,
        Y: *const mpi,
        assign: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_safe_cond_swap"]
    pub fn mpi_safe_cond_swap(
        X: *mut mpi,
        Y: *mut mpi,
        swap: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_lset"]
    pub fn mpi_lset(X: *mut mpi, z: mpi_sint) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_get_bit"]
    pub fn mpi_get_bit(X: *const mpi, pos: usize) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_set_bit"]
    pub fn mpi_set_bit(
        X: *mut mpi,
        pos: usize,
        val: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_lsb"]
    pub fn mpi_lsb(X: *const mpi) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_bitlen"]
    pub fn mpi_bitlen(X: *const mpi) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_size"]
    pub fn mpi_size(X: *const mpi) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_read_string"]
    pub fn mpi_read_string(
        X: *mut mpi,
        radix: ::types::raw_types::c_int,
        s: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_write_string"]
    pub fn mpi_write_string(
        X: *const mpi,
        radix: ::types::raw_types::c_int,
        buf: *mut ::types::raw_types::c_char,
        buflen: usize,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_read_file"]
    pub fn mpi_read_file(
        X: *mut mpi,
        radix: ::types::raw_types::c_int,
        fin: *mut FILE,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_write_file"]
    pub fn mpi_write_file(
        p: *const ::types::raw_types::c_char,
        X: *const mpi,
        radix: ::types::raw_types::c_int,
        fout: *mut FILE,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_read_binary"]
    pub fn mpi_read_binary(
        X: *mut mpi,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_read_binary_le"]
    pub fn mpi_read_binary_le(
        X: *mut mpi,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_write_binary"]
    pub fn mpi_write_binary(
        X: *const mpi,
        buf: *mut ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_write_binary_le"]
    pub fn mpi_write_binary_le(
        X: *const mpi,
        buf: *mut ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_shift_l"]
    pub fn mpi_shift_l(X: *mut mpi, count: usize) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_shift_r"]
    pub fn mpi_shift_r(X: *mut mpi, count: usize) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_cmp_abs"]
    pub fn mpi_cmp_abs(X: *const mpi, Y: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_cmp_mpi"]
    pub fn mpi_cmp_mpi(X: *const mpi, Y: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_lt_mpi_ct"]
    pub fn mpi_lt_mpi_ct(
        X: *const mpi,
        Y: *const mpi,
        ret: *mut ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_cmp_int"]
    pub fn mpi_cmp_int(X: *const mpi, z: mpi_sint) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_add_abs"]
    pub fn mpi_add_abs(X: *mut mpi, A: *const mpi, B: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_sub_abs"]
    pub fn mpi_sub_abs(X: *mut mpi, A: *const mpi, B: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_add_mpi"]
    pub fn mpi_add_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_sub_mpi"]
    pub fn mpi_sub_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_add_int"]
    pub fn mpi_add_int(X: *mut mpi, A: *const mpi, b: mpi_sint) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_sub_int"]
    pub fn mpi_sub_int(X: *mut mpi, A: *const mpi, b: mpi_sint) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_mul_mpi"]
    pub fn mpi_mul_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_mul_int"]
    pub fn mpi_mul_int(X: *mut mpi, A: *const mpi, b: mpi_uint) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_div_mpi"]
    pub fn mpi_div_mpi(
        Q: *mut mpi,
        R: *mut mpi,
        A: *const mpi,
        B: *const mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_div_int"]
    pub fn mpi_div_int(
        Q: *mut mpi,
        R: *mut mpi,
        A: *const mpi,
        b: mpi_sint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_mod_mpi"]
    pub fn mpi_mod_mpi(R: *mut mpi, A: *const mpi, B: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_mod_int"]
    pub fn mpi_mod_int(r: *mut mpi_uint, A: *const mpi, b: mpi_sint) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_exp_mod"]
    pub fn mpi_exp_mod(
        X: *mut mpi,
        A: *const mpi,
        E: *const mpi,
        N: *const mpi,
        prec_RR: *mut mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_fill_random"]
    pub fn mpi_fill_random(
        X: *mut mpi,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_random"]
    pub fn mpi_random(
        X: *mut mpi,
        min: mpi_sint,
        N: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_gcd"]
    pub fn mpi_gcd(G: *mut mpi, A: *const mpi, B: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_inv_mod"]
    pub fn mpi_inv_mod(X: *mut mpi, A: *const mpi, N: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_is_prime"]
    pub fn mpi_is_prime(
        X: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_is_prime_ext"]
    pub fn mpi_is_prime_ext(
        X: *const mpi,
        rounds: ::types::raw_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
pub const MPI_GEN_PRIME_FLAG_DH: mpi_gen_prime_flag_t = 1;
pub const MPI_GEN_PRIME_FLAG_LOW_ERR: mpi_gen_prime_flag_t = 2;
pub type mpi_gen_prime_flag_t = u32;
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_gen_prime"]
    pub fn mpi_gen_prime(
        X: *mut mpi,
        nbits: usize,
        flags: ::types::raw_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mpi_self_test"]
    pub fn mpi_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
pub const MD_NONE: md_type_t = 0;
pub const MD_MD2: md_type_t = 1;
pub const MD_MD4: md_type_t = 2;
pub const MD_MD5: md_type_t = 3;
pub const MD_SHA1: md_type_t = 4;
pub const MD_SHA224: md_type_t = 5;
pub const MD_SHA256: md_type_t = 6;
pub const MD_SHA384: md_type_t = 7;
pub const MD_SHA512: md_type_t = 8;
pub const MD_RIPEMD160: md_type_t = 9;
pub type md_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md_context_t {
    pub md_info: *const md_info_t,
    pub md_ctx: *mut ::types::raw_types::c_void,
    pub hmac_ctx: *mut ::types::raw_types::c_void,
}
#[test]
fn bindgen_test_layout_md_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<md_context_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<md_context_t>(),
        24usize,
        concat!("Size of: ", stringify!(md_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<md_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(md_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(md_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hmac_ctx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(hmac_ctx)
        )
    );
}
impl Default for md_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_list"]
    pub fn md_list() -> *const ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_info_from_string"]
    pub fn md_info_from_string(md_name: *const ::types::raw_types::c_char) -> *const md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_info_from_type"]
    pub fn md_info_from_type(md_type: md_type_t) -> *const md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_init"]
    pub fn md_init(ctx: *mut md_context_t);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_free"]
    pub fn md_free(ctx: *mut md_context_t);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_init_ctx"]
    pub fn md_init_ctx(
        ctx: *mut md_context_t,
        md_info: *const md_info_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_setup"]
    pub fn md_setup(
        ctx: *mut md_context_t,
        md_info: *const md_info_t,
        hmac: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_clone"]
    pub fn md_clone(dst: *mut md_context_t, src: *const md_context_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_get_size"]
    pub fn md_get_size(md_info: *const md_info_t) -> ::types::raw_types::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_get_type"]
    pub fn md_get_type(md_info: *const md_info_t) -> md_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_get_name"]
    pub fn md_get_name(md_info: *const md_info_t) -> *const ::types::raw_types::c_char;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_starts"]
    pub fn md_starts(ctx: *mut md_context_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_update"]
    pub fn md_update(
        ctx: *mut md_context_t,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_finish"]
    pub fn md_finish(
        ctx: *mut md_context_t,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md"]
    pub fn md(
        md_info: *const md_info_t,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_file"]
    pub fn md_file(
        md_info: *const md_info_t,
        path: *const ::types::raw_types::c_char,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_hmac_starts"]
    pub fn md_hmac_starts(
        ctx: *mut md_context_t,
        key: *const ::types::raw_types::c_uchar,
        keylen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_hmac_update"]
    pub fn md_hmac_update(
        ctx: *mut md_context_t,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_hmac_finish"]
    pub fn md_hmac_finish(
        ctx: *mut md_context_t,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_hmac_reset"]
    pub fn md_hmac_reset(ctx: *mut md_context_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_hmac"]
    pub fn md_hmac(
        md_info: *const md_info_t,
        key: *const ::types::raw_types::c_uchar,
        keylen: usize,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_md_process"]
    pub fn md_process(
        ctx: *mut md_context_t,
        data: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct threading_mutex_t {
    pub mutex: pthread_mutex_t,
    pub is_valid: ::types::raw_types::c_char,
}
#[test]
fn bindgen_test_layout_threading_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<threading_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<threading_mutex_t>(),
        48usize,
        concat!("Size of: ", stringify!(threading_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<threading_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(threading_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threading_mutex_t),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(threading_mutex_t),
            "::",
            stringify!(is_valid)
        )
    );
}
impl Default for threading_mutex_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mutex_init"]
    pub static mut mutex_init:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut threading_mutex_t)>;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mutex_free"]
    pub static mut mutex_free:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut threading_mutex_t)>;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mutex_lock"]
    pub static mut mutex_lock: ::core::option::Option<
        unsafe extern "C" fn(mutex: *mut threading_mutex_t) -> ::types::raw_types::c_int,
    >;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_mutex_unlock"]
    pub static mut mutex_unlock: ::core::option::Option<
        unsafe extern "C" fn(mutex: *mut threading_mutex_t) -> ::types::raw_types::c_int,
    >;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_threading_readdir_mutex"]
    pub static mut threading_readdir_mutex: threading_mutex_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_threading_gmtime_mutex"]
    pub static mut threading_gmtime_mutex: threading_mutex_t;
}
pub const ECP_DP_NONE: ecp_group_id = 0;
pub const ECP_DP_SECP192R1: ecp_group_id = 1;
pub const ECP_DP_SECP224R1: ecp_group_id = 2;
pub const ECP_DP_SECP256R1: ecp_group_id = 3;
pub const ECP_DP_SECP384R1: ecp_group_id = 4;
pub const ECP_DP_SECP521R1: ecp_group_id = 5;
pub const ECP_DP_BP256R1: ecp_group_id = 6;
pub const ECP_DP_BP384R1: ecp_group_id = 7;
pub const ECP_DP_BP512R1: ecp_group_id = 8;
pub const ECP_DP_CURVE25519: ecp_group_id = 9;
pub const ECP_DP_SECP192K1: ecp_group_id = 10;
pub const ECP_DP_SECP224K1: ecp_group_id = 11;
pub const ECP_DP_SECP256K1: ecp_group_id = 12;
pub const ECP_DP_CURVE448: ecp_group_id = 13;
pub type ecp_group_id = u32;
pub const ECP_TYPE_NONE: ecp_curve_type = 0;
pub const ECP_TYPE_SHORT_WEIERSTRASS: ecp_curve_type = 1;
pub const ECP_TYPE_MONTGOMERY: ecp_curve_type = 2;
pub type ecp_curve_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecp_curve_info {
    pub grp_id: ecp_group_id,
    pub tls_id: u16,
    pub bit_size: u16,
    pub name: *const ::types::raw_types::c_char,
}
#[test]
fn bindgen_test_layout_ecp_curve_info() {
    const UNINIT: ::core::mem::MaybeUninit<ecp_curve_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ecp_curve_info>(),
        16usize,
        concat!("Size of: ", stringify!(ecp_curve_info))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_curve_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ecp_curve_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grp_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(grp_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tls_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(tls_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(name)
        )
    );
}
impl Default for ecp_curve_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecp_point {
    pub X: mpi,
    pub Y: mpi,
    pub Z: mpi,
}
#[test]
fn bindgen_test_layout_ecp_point() {
    const UNINIT: ::core::mem::MaybeUninit<ecp_point> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ecp_point>(),
        72usize,
        concat!("Size of: ", stringify!(ecp_point))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_point>(),
        8usize,
        concat!("Alignment of ", stringify!(ecp_point))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Z) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(Z)
        )
    );
}
impl Default for ecp_point {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecp_group {
    pub id: ecp_group_id,
    pub P: mpi,
    pub A: mpi,
    pub B: mpi,
    pub G: ecp_point,
    pub N: mpi,
    pub pbits: usize,
    pub nbits: usize,
    pub h: ::types::raw_types::c_uint,
    pub modp:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut mpi) -> ::types::raw_types::c_int>,
    pub t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ecp_point,
            arg2: *mut ::types::raw_types::c_void,
        ) -> ::types::raw_types::c_int,
    >,
    pub t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ecp_point,
            arg2: *mut ::types::raw_types::c_void,
        ) -> ::types::raw_types::c_int,
    >,
    pub t_data: *mut ::types::raw_types::c_void,
    pub T: *mut ecp_point,
    pub T_size: usize,
}
#[test]
fn bindgen_test_layout_ecp_group() {
    const UNINIT: ::core::mem::MaybeUninit<ecp_group> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ecp_group>(),
        248usize,
        concat!("Size of: ", stringify!(ecp_group))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_group>(),
        8usize,
        concat!("Alignment of ", stringify!(ecp_group))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).P) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).G) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pbits) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(pbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbits) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(nbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modp) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(modp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t_pre) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_pre)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t_post) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_post)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t_data) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).T) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(T)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).T_size) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(T_size)
        )
    );
}
impl Default for ecp_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ecp_restart_ctx = ::types::raw_types::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecp_keypair {
    pub grp: ecp_group,
    pub d: mpi,
    pub Q: ecp_point,
}
#[test]
fn bindgen_test_layout_ecp_keypair() {
    const UNINIT: ::core::mem::MaybeUninit<ecp_keypair> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ecp_keypair>(),
        344usize,
        concat!("Size of: ", stringify!(ecp_keypair))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_keypair>(),
        8usize,
        concat!("Alignment of ", stringify!(ecp_keypair))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Q) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(Q)
        )
    );
}
impl Default for ecp_keypair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_get_type"]
    pub fn ecp_get_type(grp: *const ecp_group) -> ecp_curve_type;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_curve_list"]
    pub fn ecp_curve_list() -> *const ecp_curve_info;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_grp_id_list"]
    pub fn ecp_grp_id_list() -> *const ecp_group_id;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_curve_info_from_grp_id"]
    pub fn ecp_curve_info_from_grp_id(grp_id: ecp_group_id) -> *const ecp_curve_info;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_curve_info_from_tls_id"]
    pub fn ecp_curve_info_from_tls_id(tls_id: u16) -> *const ecp_curve_info;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_curve_info_from_name"]
    pub fn ecp_curve_info_from_name(
        name: *const ::types::raw_types::c_char,
    ) -> *const ecp_curve_info;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_point_init"]
    pub fn ecp_point_init(pt: *mut ecp_point);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_group_init"]
    pub fn ecp_group_init(grp: *mut ecp_group);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_keypair_init"]
    pub fn ecp_keypair_init(key: *mut ecp_keypair);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_point_free"]
    pub fn ecp_point_free(pt: *mut ecp_point);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_group_free"]
    pub fn ecp_group_free(grp: *mut ecp_group);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_keypair_free"]
    pub fn ecp_keypair_free(key: *mut ecp_keypair);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_copy"]
    pub fn ecp_copy(P: *mut ecp_point, Q: *const ecp_point) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_group_copy"]
    pub fn ecp_group_copy(dst: *mut ecp_group, src: *const ecp_group) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_set_zero"]
    pub fn ecp_set_zero(pt: *mut ecp_point) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_is_zero"]
    pub fn ecp_is_zero(pt: *mut ecp_point) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_point_cmp"]
    pub fn ecp_point_cmp(P: *const ecp_point, Q: *const ecp_point) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_point_read_string"]
    pub fn ecp_point_read_string(
        P: *mut ecp_point,
        radix: ::types::raw_types::c_int,
        x: *const ::types::raw_types::c_char,
        y: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_point_write_binary"]
    pub fn ecp_point_write_binary(
        grp: *const ecp_group,
        P: *const ecp_point,
        format: ::types::raw_types::c_int,
        olen: *mut usize,
        buf: *mut ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_point_read_binary"]
    pub fn ecp_point_read_binary(
        grp: *const ecp_group,
        P: *mut ecp_point,
        buf: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_tls_read_point"]
    pub fn ecp_tls_read_point(
        grp: *const ecp_group,
        pt: *mut ecp_point,
        buf: *mut *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_tls_write_point"]
    pub fn ecp_tls_write_point(
        grp: *const ecp_group,
        pt: *const ecp_point,
        format: ::types::raw_types::c_int,
        olen: *mut usize,
        buf: *mut ::types::raw_types::c_uchar,
        blen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_group_load"]
    pub fn ecp_group_load(grp: *mut ecp_group, id: ecp_group_id) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_tls_read_group"]
    pub fn ecp_tls_read_group(
        grp: *mut ecp_group,
        buf: *mut *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_tls_read_group_id"]
    pub fn ecp_tls_read_group_id(
        grp: *mut ecp_group_id,
        buf: *mut *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_tls_write_group"]
    pub fn ecp_tls_write_group(
        grp: *const ecp_group,
        olen: *mut usize,
        buf: *mut ::types::raw_types::c_uchar,
        blen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_mul"]
    pub fn ecp_mul(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_mul_restartable"]
    pub fn ecp_mul_restartable(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        rs_ctx: *mut ecp_restart_ctx,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_muladd"]
    pub fn ecp_muladd(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        n: *const mpi,
        Q: *const ecp_point,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_muladd_restartable"]
    pub fn ecp_muladd_restartable(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        n: *const mpi,
        Q: *const ecp_point,
        rs_ctx: *mut ecp_restart_ctx,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_check_pubkey"]
    pub fn ecp_check_pubkey(
        grp: *const ecp_group,
        pt: *const ecp_point,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_check_privkey"]
    pub fn ecp_check_privkey(grp: *const ecp_group, d: *const mpi) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_gen_privkey"]
    pub fn ecp_gen_privkey(
        grp: *const ecp_group,
        d: *mut mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_gen_keypair_base"]
    pub fn ecp_gen_keypair_base(
        grp: *mut ecp_group,
        G: *const ecp_point,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_gen_keypair"]
    pub fn ecp_gen_keypair(
        grp: *mut ecp_group,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_gen_key"]
    pub fn ecp_gen_key(
        grp_id: ecp_group_id,
        key: *mut ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_read_key"]
    pub fn ecp_read_key(
        grp_id: ecp_group_id,
        key: *mut ecp_keypair,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_write_key"]
    pub fn ecp_write_key(
        key: *mut ecp_keypair,
        buf: *mut ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_check_pub_priv"]
    pub fn ecp_check_pub_priv(
        pub_: *const ecp_keypair,
        prv: *const ecp_keypair,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_self_test"]
    pub fn ecp_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsa_context {
    pub ver: ::types::raw_types::c_int,
    pub len: usize,
    pub N: mpi,
    pub E: mpi,
    pub D: mpi,
    pub P: mpi,
    pub Q: mpi,
    pub DP: mpi,
    pub DQ: mpi,
    pub QP: mpi,
    pub RN: mpi,
    pub RP: mpi,
    pub RQ: mpi,
    pub Vi: mpi,
    pub Vf: mpi,
    pub padding: ::types::raw_types::c_int,
    pub hash_id: ::types::raw_types::c_int,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_rsa_context() {
    const UNINIT: ::core::mem::MaybeUninit<rsa_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rsa_context>(),
        384usize,
        concat!("Size of: ", stringify!(rsa_context))
    );
    assert_eq!(
        ::core::mem::align_of::<rsa_context>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).E) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(E)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).D) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(D)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).P) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Q) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DP) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(DP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DQ) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(DQ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QP) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(QP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RN) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RN)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RP) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RQ) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RQ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vi) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vf) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_id) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(hash_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(mutex)
        )
    );
}
impl Default for rsa_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_init"]
    pub fn rsa_init(
        ctx: *mut rsa_context,
        padding: ::types::raw_types::c_int,
        hash_id: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_import"]
    pub fn rsa_import(
        ctx: *mut rsa_context,
        N: *const mpi,
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        E: *const mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_import_raw"]
    pub fn rsa_import_raw(
        ctx: *mut rsa_context,
        N: *const ::types::raw_types::c_uchar,
        N_len: usize,
        P: *const ::types::raw_types::c_uchar,
        P_len: usize,
        Q: *const ::types::raw_types::c_uchar,
        Q_len: usize,
        D: *const ::types::raw_types::c_uchar,
        D_len: usize,
        E: *const ::types::raw_types::c_uchar,
        E_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_complete"]
    pub fn rsa_complete(ctx: *mut rsa_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_export"]
    pub fn rsa_export(
        ctx: *const rsa_context,
        N: *mut mpi,
        P: *mut mpi,
        Q: *mut mpi,
        D: *mut mpi,
        E: *mut mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_export_raw"]
    pub fn rsa_export_raw(
        ctx: *const rsa_context,
        N: *mut ::types::raw_types::c_uchar,
        N_len: usize,
        P: *mut ::types::raw_types::c_uchar,
        P_len: usize,
        Q: *mut ::types::raw_types::c_uchar,
        Q_len: usize,
        D: *mut ::types::raw_types::c_uchar,
        D_len: usize,
        E: *mut ::types::raw_types::c_uchar,
        E_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_export_crt"]
    pub fn rsa_export_crt(
        ctx: *const rsa_context,
        DP: *mut mpi,
        DQ: *mut mpi,
        QP: *mut mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_set_padding"]
    pub fn rsa_set_padding(
        ctx: *mut rsa_context,
        padding: ::types::raw_types::c_int,
        hash_id: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_get_len"]
    pub fn rsa_get_len(ctx: *const rsa_context) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_gen_key"]
    pub fn rsa_gen_key(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        nbits: ::types::raw_types::c_uint,
        exponent: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_check_pubkey"]
    pub fn rsa_check_pubkey(ctx: *const rsa_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_check_privkey"]
    pub fn rsa_check_privkey(ctx: *const rsa_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_check_pub_priv"]
    pub fn rsa_check_pub_priv(
        pub_: *const rsa_context,
        prv: *const rsa_context,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_public"]
    pub fn rsa_public(
        ctx: *mut rsa_context,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_private"]
    pub fn rsa_private(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_pkcs1_encrypt"]
    pub fn rsa_pkcs1_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        ilen: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsaes_pkcs1_v15_encrypt"]
    pub fn rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        ilen: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsaes_oaep_encrypt"]
    pub fn rsa_rsaes_oaep_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        label: *const ::types::raw_types::c_uchar,
        label_len: usize,
        ilen: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_pkcs1_decrypt"]
    pub fn rsa_pkcs1_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        olen: *mut usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        output_max_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsaes_pkcs1_v15_decrypt"]
    pub fn rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        olen: *mut usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        output_max_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsaes_oaep_decrypt"]
    pub fn rsa_rsaes_oaep_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        label: *const ::types::raw_types::c_uchar,
        label_len: usize,
        olen: *mut usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        output_max_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_pkcs1_sign"]
    pub fn rsa_pkcs1_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        sig: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pkcs1_v15_sign"]
    pub fn rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        sig: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pss_sign_ext"]
    pub fn rsa_rsassa_pss_sign_ext(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        saltlen: ::types::raw_types::c_int,
        sig: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pss_sign"]
    pub fn rsa_rsassa_pss_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        sig: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_pkcs1_verify"]
    pub fn rsa_pkcs1_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        sig: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pkcs1_v15_verify"]
    pub fn rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        sig: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pss_verify"]
    pub fn rsa_rsassa_pss_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        sig: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pss_verify_ext"]
    pub fn rsa_rsassa_pss_verify_ext(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        mgf1_hash_id: md_type_t,
        expected_salt_len: ::types::raw_types::c_int,
        sig: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_copy"]
    pub fn rsa_copy(dst: *mut rsa_context, src: *const rsa_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_free"]
    pub fn rsa_free(ctx: *mut rsa_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_self_test"]
    pub fn rsa_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
pub type ecdsa_context = ecp_keypair;
pub type ecdsa_restart_ctx = ::types::raw_types::c_void;
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_can_do"]
    pub fn ecdsa_can_do(gid: ecp_group_id) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_sign"]
    pub fn ecdsa_sign(
        grp: *mut ecp_group,
        r: *mut mpi,
        s: *mut mpi,
        d: *const mpi,
        buf: *const ::types::raw_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_verify"]
    pub fn ecdsa_verify(
        grp: *mut ecp_group,
        buf: *const ::types::raw_types::c_uchar,
        blen: usize,
        Q: *const ecp_point,
        r: *const mpi,
        s: *const mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_write_signature"]
    pub fn ecdsa_write_signature(
        ctx: *mut ecdsa_context,
        md_alg: md_type_t,
        hash: *const ::types::raw_types::c_uchar,
        hlen: usize,
        sig: *mut ::types::raw_types::c_uchar,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_write_signature_restartable"]
    pub fn ecdsa_write_signature_restartable(
        ctx: *mut ecdsa_context,
        md_alg: md_type_t,
        hash: *const ::types::raw_types::c_uchar,
        hlen: usize,
        sig: *mut ::types::raw_types::c_uchar,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        rs_ctx: *mut ecdsa_restart_ctx,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_read_signature"]
    pub fn ecdsa_read_signature(
        ctx: *mut ecdsa_context,
        hash: *const ::types::raw_types::c_uchar,
        hlen: usize,
        sig: *const ::types::raw_types::c_uchar,
        slen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_read_signature_restartable"]
    pub fn ecdsa_read_signature_restartable(
        ctx: *mut ecdsa_context,
        hash: *const ::types::raw_types::c_uchar,
        hlen: usize,
        sig: *const ::types::raw_types::c_uchar,
        slen: usize,
        rs_ctx: *mut ecdsa_restart_ctx,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_genkey"]
    pub fn ecdsa_genkey(
        ctx: *mut ecdsa_context,
        gid: ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_from_keypair"]
    pub fn ecdsa_from_keypair(
        ctx: *mut ecdsa_context,
        key: *const ecp_keypair,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_init"]
    pub fn ecdsa_init(ctx: *mut ecdsa_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_free"]
    pub fn ecdsa_free(ctx: *mut ecdsa_context);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_buf {
    pub tag: ::types::raw_types::c_int,
    pub len: usize,
    pub p: *mut ::types::raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_buf() {
    const UNINIT: ::core::mem::MaybeUninit<asn1_buf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<asn1_buf>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_buf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(p)
        )
    );
}
impl Default for asn1_buf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_bitstring {
    pub len: usize,
    pub unused_bits: ::types::raw_types::c_uchar,
    pub p: *mut ::types::raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_bitstring() {
    const UNINIT: ::core::mem::MaybeUninit<asn1_bitstring> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<asn1_bitstring>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_bitstring))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_bitstring>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_bitstring))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused_bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(unused_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(p)
        )
    );
}
impl Default for asn1_bitstring {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_sequence {
    pub buf: asn1_buf,
    pub next: *mut asn1_sequence,
}
#[test]
fn bindgen_test_layout_asn1_sequence() {
    const UNINIT: ::core::mem::MaybeUninit<asn1_sequence> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<asn1_sequence>(),
        32usize,
        concat!("Size of: ", stringify!(asn1_sequence))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_sequence))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_sequence),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_sequence),
            "::",
            stringify!(next)
        )
    );
}
impl Default for asn1_sequence {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_named_data {
    pub oid: asn1_buf,
    pub val: asn1_buf,
    pub next: *mut asn1_named_data,
    pub next_merged: ::types::raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_named_data() {
    const UNINIT: ::core::mem::MaybeUninit<asn1_named_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<asn1_named_data>(),
        64usize,
        concat!("Size of: ", stringify!(asn1_named_data))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_named_data>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_named_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_merged) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(next_merged)
        )
    );
}
impl Default for asn1_named_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_len"]
    pub fn asn1_get_len(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        len: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_tag"]
    pub fn asn1_get_tag(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        len: *mut usize,
        tag: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_bool"]
    pub fn asn1_get_bool(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        val: *mut ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_int"]
    pub fn asn1_get_int(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        val: *mut ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_enum"]
    pub fn asn1_get_enum(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        val: *mut ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_bitstring"]
    pub fn asn1_get_bitstring(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        bs: *mut asn1_bitstring,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_bitstring_null"]
    pub fn asn1_get_bitstring_null(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        len: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_sequence_of"]
    pub fn asn1_get_sequence_of(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        cur: *mut asn1_sequence,
        tag: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_sequence_free"]
    pub fn asn1_sequence_free(seq: *mut asn1_sequence);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_traverse_sequence_of"]
    pub fn asn1_traverse_sequence_of(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        tag_must_mask: ::types::raw_types::c_uchar,
        tag_must_val: ::types::raw_types::c_uchar,
        tag_may_mask: ::types::raw_types::c_uchar,
        tag_may_val: ::types::raw_types::c_uchar,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut ::types::raw_types::c_void,
                tag: ::types::raw_types::c_int,
                start: *mut ::types::raw_types::c_uchar,
                len: usize,
            ) -> ::types::raw_types::c_int,
        >,
        ctx: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_mpi"]
    pub fn asn1_get_mpi(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        X: *mut mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_alg"]
    pub fn asn1_get_alg(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        alg: *mut asn1_buf,
        params: *mut asn1_buf,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_get_alg_null"]
    pub fn asn1_get_alg_null(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        alg: *mut asn1_buf,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_find_named_data"]
    pub fn asn1_find_named_data(
        list: *mut asn1_named_data,
        oid: *const ::types::raw_types::c_char,
        len: usize,
    ) -> *mut asn1_named_data;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_free_named_data"]
    pub fn asn1_free_named_data(entry: *mut asn1_named_data);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_free_named_data_list"]
    pub fn asn1_free_named_data_list(head: *mut *mut asn1_named_data);
}
pub const PK_NONE: pk_type_t = 0;
pub const PK_RSA: pk_type_t = 1;
pub const PK_ECKEY: pk_type_t = 2;
pub const PK_ECKEY_DH: pk_type_t = 3;
pub const PK_ECDSA: pk_type_t = 4;
pub const PK_RSA_ALT: pk_type_t = 5;
pub const PK_RSASSA_PSS: pk_type_t = 6;
pub const PK_OPAQUE: pk_type_t = 7;
pub type pk_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pk_rsassa_pss_options {
    pub mgf1_hash_id: md_type_t,
    pub expected_salt_len: ::types::raw_types::c_int,
}
#[test]
fn bindgen_test_layout_pk_rsassa_pss_options() {
    const UNINIT: ::core::mem::MaybeUninit<pk_rsassa_pss_options> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pk_rsassa_pss_options>(),
        8usize,
        concat!("Size of: ", stringify!(pk_rsassa_pss_options))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_rsassa_pss_options>(),
        4usize,
        concat!("Alignment of ", stringify!(pk_rsassa_pss_options))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mgf1_hash_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_rsassa_pss_options),
            "::",
            stringify!(mgf1_hash_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expected_salt_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_rsassa_pss_options),
            "::",
            stringify!(expected_salt_len)
        )
    );
}
impl Default for pk_rsassa_pss_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PK_DEBUG_NONE: pk_debug_type = 0;
pub const PK_DEBUG_MPI: pk_debug_type = 1;
pub const PK_DEBUG_ECP: pk_debug_type = 2;
pub type pk_debug_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pk_debug_item {
    pub type_: pk_debug_type,
    pub name: *const ::types::raw_types::c_char,
    pub value: *mut ::types::raw_types::c_void,
}
#[test]
fn bindgen_test_layout_pk_debug_item() {
    const UNINIT: ::core::mem::MaybeUninit<pk_debug_item> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pk_debug_item>(),
        24usize,
        concat!("Size of: ", stringify!(pk_debug_item))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_debug_item>(),
        8usize,
        concat!("Alignment of ", stringify!(pk_debug_item))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(value)
        )
    );
}
impl Default for pk_debug_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pk_context {
    pub pk_info: *const pk_info_t,
    pub pk_ctx: *mut ::types::raw_types::c_void,
}
#[test]
fn bindgen_test_layout_pk_context() {
    const UNINIT: ::core::mem::MaybeUninit<pk_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pk_context>(),
        16usize,
        concat!("Size of: ", stringify!(pk_context))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_context>(),
        8usize,
        concat!("Alignment of ", stringify!(pk_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pk_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_context),
            "::",
            stringify!(pk_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pk_ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_context),
            "::",
            stringify!(pk_ctx)
        )
    );
}
impl Default for pk_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pk_restart_ctx = ::types::raw_types::c_void;
pub type pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        olen: *mut usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        output_max_len: usize,
    ) -> ::types::raw_types::c_int,
>;
pub type pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::types::raw_types::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        mode: ::types::raw_types::c_int,
        md_alg: md_type_t,
        hashlen: ::types::raw_types::c_uint,
        hash: *const ::types::raw_types::c_uchar,
        sig: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int,
>;
pub type pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::types::raw_types::c_void) -> usize>;
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_info_from_type"]
    pub fn pk_info_from_type(pk_type: pk_type_t) -> *const pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_init"]
    pub fn pk_init(ctx: *mut pk_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_free"]
    pub fn pk_free(ctx: *mut pk_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_setup"]
    pub fn pk_setup(ctx: *mut pk_context, info: *const pk_info_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_setup_rsa_alt"]
    pub fn pk_setup_rsa_alt(
        ctx: *mut pk_context,
        key: *mut ::types::raw_types::c_void,
        decrypt_func: pk_rsa_alt_decrypt_func,
        sign_func: pk_rsa_alt_sign_func,
        key_len_func: pk_rsa_alt_key_len_func,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_get_bitlen"]
    pub fn pk_get_bitlen(ctx: *const pk_context) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_can_do"]
    pub fn pk_can_do(ctx: *const pk_context, type_: pk_type_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_verify"]
    pub fn pk_verify(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const ::types::raw_types::c_uchar,
        hash_len: usize,
        sig: *const ::types::raw_types::c_uchar,
        sig_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_verify_restartable"]
    pub fn pk_verify_restartable(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const ::types::raw_types::c_uchar,
        hash_len: usize,
        sig: *const ::types::raw_types::c_uchar,
        sig_len: usize,
        rs_ctx: *mut pk_restart_ctx,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_verify_ext"]
    pub fn pk_verify_ext(
        type_: pk_type_t,
        options: *const ::types::raw_types::c_void,
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const ::types::raw_types::c_uchar,
        hash_len: usize,
        sig: *const ::types::raw_types::c_uchar,
        sig_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_sign"]
    pub fn pk_sign(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const ::types::raw_types::c_uchar,
        hash_len: usize,
        sig: *mut ::types::raw_types::c_uchar,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_sign_restartable"]
    pub fn pk_sign_restartable(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const ::types::raw_types::c_uchar,
        hash_len: usize,
        sig: *mut ::types::raw_types::c_uchar,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        rs_ctx: *mut pk_restart_ctx,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_decrypt"]
    pub fn pk_decrypt(
        ctx: *mut pk_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_encrypt"]
    pub fn pk_encrypt(
        ctx: *mut pk_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_check_pair"]
    pub fn pk_check_pair(
        pub_: *const pk_context,
        prv: *const pk_context,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_debug"]
    pub fn pk_debug(ctx: *const pk_context, items: *mut pk_debug_item)
        -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_get_name"]
    pub fn pk_get_name(ctx: *const pk_context) -> *const ::types::raw_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_get_type"]
    pub fn pk_get_type(ctx: *const pk_context) -> pk_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_parse_key"]
    pub fn pk_parse_key(
        ctx: *mut pk_context,
        key: *const ::types::raw_types::c_uchar,
        keylen: usize,
        pwd: *const ::types::raw_types::c_uchar,
        pwdlen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_parse_public_key"]
    pub fn pk_parse_public_key(
        ctx: *mut pk_context,
        key: *const ::types::raw_types::c_uchar,
        keylen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_parse_keyfile"]
    pub fn pk_parse_keyfile(
        ctx: *mut pk_context,
        path: *const ::types::raw_types::c_char,
        password: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_parse_public_keyfile"]
    pub fn pk_parse_public_keyfile(
        ctx: *mut pk_context,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_write_key_der"]
    pub fn pk_write_key_der(
        ctx: *mut pk_context,
        buf: *mut ::types::raw_types::c_uchar,
        size: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_write_pubkey_der"]
    pub fn pk_write_pubkey_der(
        ctx: *mut pk_context,
        buf: *mut ::types::raw_types::c_uchar,
        size: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_write_pubkey_pem"]
    pub fn pk_write_pubkey_pem(
        ctx: *mut pk_context,
        buf: *mut ::types::raw_types::c_uchar,
        size: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_write_key_pem"]
    pub fn pk_write_key_pem(
        ctx: *mut pk_context,
        buf: *mut ::types::raw_types::c_uchar,
        size: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_parse_subpubkey"]
    pub fn pk_parse_subpubkey(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        pk: *mut pk_context,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_write_pubkey"]
    pub fn pk_write_pubkey(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        key: *const pk_context,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pk_load_file"]
    pub fn pk_load_file(
        path: *const ::types::raw_types::c_char,
        buf: *mut *mut ::types::raw_types::c_uchar,
        n: *mut usize,
    ) -> ::types::raw_types::c_int;
}
pub type x509_buf = asn1_buf;
pub type x509_bitstring = asn1_bitstring;
pub type x509_name = asn1_named_data;
pub type x509_sequence = asn1_sequence;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x509_time {
    pub year: ::types::raw_types::c_int,
    pub mon: ::types::raw_types::c_int,
    pub day: ::types::raw_types::c_int,
    pub hour: ::types::raw_types::c_int,
    pub min: ::types::raw_types::c_int,
    pub sec: ::types::raw_types::c_int,
}
#[test]
fn bindgen_test_layout_x509_time() {
    const UNINIT: ::core::mem::MaybeUninit<x509_time> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_time>(),
        24usize,
        concat!("Size of: ", stringify!(x509_time))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_time>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_time))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(sec)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_dn_gets"]
    pub fn x509_dn_gets(
        buf: *mut ::types::raw_types::c_char,
        size: usize,
        dn: *const x509_name,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_serial_gets"]
    pub fn x509_serial_gets(
        buf: *mut ::types::raw_types::c_char,
        size: usize,
        serial: *const x509_buf,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_time_is_past"]
    pub fn x509_time_is_past(to: *const x509_time) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_time_is_future"]
    pub fn x509_time_is_future(from: *const x509_time) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_self_test"]
    pub fn x509_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_name"]
    pub fn x509_get_name(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        cur: *mut x509_name,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_alg_null"]
    pub fn x509_get_alg_null(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        alg: *mut x509_buf,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_alg"]
    pub fn x509_get_alg(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        alg: *mut x509_buf,
        params: *mut x509_buf,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_rsassa_pss_params"]
    pub fn x509_get_rsassa_pss_params(
        params: *const x509_buf,
        md_alg: *mut md_type_t,
        mgf_md: *mut md_type_t,
        salt_len: *mut ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_sig"]
    pub fn x509_get_sig(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        sig: *mut x509_buf,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_sig_alg"]
    pub fn x509_get_sig_alg(
        sig_oid: *const x509_buf,
        sig_params: *const x509_buf,
        md_alg: *mut md_type_t,
        pk_alg: *mut pk_type_t,
        sig_opts: *mut *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_time"]
    pub fn x509_get_time(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        t: *mut x509_time,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_serial"]
    pub fn x509_get_serial(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        serial: *mut x509_buf,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_ext"]
    pub fn x509_get_ext(
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        ext: *mut x509_buf,
        tag: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_sig_alg_gets"]
    pub fn x509_sig_alg_gets(
        buf: *mut ::types::raw_types::c_char,
        size: usize,
        sig_oid: *const x509_buf,
        pk_alg: pk_type_t,
        md_alg: md_type_t,
        sig_opts: *const ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_key_size_helper"]
    pub fn x509_key_size_helper(
        buf: *mut ::types::raw_types::c_char,
        buf_size: usize,
        name: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_string_to_names"]
    pub fn x509_string_to_names(
        head: *mut *mut asn1_named_data,
        name: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_set_extension"]
    pub fn x509_set_extension(
        head: *mut *mut asn1_named_data,
        oid: *const ::types::raw_types::c_char,
        oid_len: usize,
        critical: ::types::raw_types::c_int,
        val: *const ::types::raw_types::c_uchar,
        val_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_write_extensions"]
    pub fn x509_write_extensions(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        first: *mut asn1_named_data,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_write_names"]
    pub fn x509_write_names(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        first: *mut asn1_named_data,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_write_sig"]
    pub fn x509_write_sig(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        oid: *const ::types::raw_types::c_char,
        oid_len: usize,
        sig: *mut ::types::raw_types::c_uchar,
        size: usize,
        pk_alg: pk_type_t,
    ) -> ::types::raw_types::c_int;
}
pub const CIPHER_ID_NONE: cipher_id_t = 0;
pub const CIPHER_ID_NULL: cipher_id_t = 1;
pub const CIPHER_ID_AES: cipher_id_t = 2;
pub const CIPHER_ID_DES: cipher_id_t = 3;
pub const CIPHER_ID_3DES: cipher_id_t = 4;
pub const CIPHER_ID_CAMELLIA: cipher_id_t = 5;
pub const CIPHER_ID_BLOWFISH: cipher_id_t = 6;
pub const CIPHER_ID_ARC4: cipher_id_t = 7;
pub const CIPHER_ID_ARIA: cipher_id_t = 8;
pub const CIPHER_ID_CHACHA20: cipher_id_t = 9;
pub type cipher_id_t = u32;
pub const CIPHER_NONE: cipher_type_t = 0;
pub const CIPHER_NULL: cipher_type_t = 1;
pub const CIPHER_AES_128_ECB: cipher_type_t = 2;
pub const CIPHER_AES_192_ECB: cipher_type_t = 3;
pub const CIPHER_AES_256_ECB: cipher_type_t = 4;
pub const CIPHER_AES_128_CBC: cipher_type_t = 5;
pub const CIPHER_AES_192_CBC: cipher_type_t = 6;
pub const CIPHER_AES_256_CBC: cipher_type_t = 7;
pub const CIPHER_AES_128_CFB128: cipher_type_t = 8;
pub const CIPHER_AES_192_CFB128: cipher_type_t = 9;
pub const CIPHER_AES_256_CFB128: cipher_type_t = 10;
pub const CIPHER_AES_128_CTR: cipher_type_t = 11;
pub const CIPHER_AES_192_CTR: cipher_type_t = 12;
pub const CIPHER_AES_256_CTR: cipher_type_t = 13;
pub const CIPHER_AES_128_GCM: cipher_type_t = 14;
pub const CIPHER_AES_192_GCM: cipher_type_t = 15;
pub const CIPHER_AES_256_GCM: cipher_type_t = 16;
pub const CIPHER_CAMELLIA_128_ECB: cipher_type_t = 17;
pub const CIPHER_CAMELLIA_192_ECB: cipher_type_t = 18;
pub const CIPHER_CAMELLIA_256_ECB: cipher_type_t = 19;
pub const CIPHER_CAMELLIA_128_CBC: cipher_type_t = 20;
pub const CIPHER_CAMELLIA_192_CBC: cipher_type_t = 21;
pub const CIPHER_CAMELLIA_256_CBC: cipher_type_t = 22;
pub const CIPHER_CAMELLIA_128_CFB128: cipher_type_t = 23;
pub const CIPHER_CAMELLIA_192_CFB128: cipher_type_t = 24;
pub const CIPHER_CAMELLIA_256_CFB128: cipher_type_t = 25;
pub const CIPHER_CAMELLIA_128_CTR: cipher_type_t = 26;
pub const CIPHER_CAMELLIA_192_CTR: cipher_type_t = 27;
pub const CIPHER_CAMELLIA_256_CTR: cipher_type_t = 28;
pub const CIPHER_CAMELLIA_128_GCM: cipher_type_t = 29;
pub const CIPHER_CAMELLIA_192_GCM: cipher_type_t = 30;
pub const CIPHER_CAMELLIA_256_GCM: cipher_type_t = 31;
pub const CIPHER_DES_ECB: cipher_type_t = 32;
pub const CIPHER_DES_CBC: cipher_type_t = 33;
pub const CIPHER_DES_EDE_ECB: cipher_type_t = 34;
pub const CIPHER_DES_EDE_CBC: cipher_type_t = 35;
pub const CIPHER_DES_EDE3_ECB: cipher_type_t = 36;
pub const CIPHER_DES_EDE3_CBC: cipher_type_t = 37;
pub const CIPHER_BLOWFISH_ECB: cipher_type_t = 38;
pub const CIPHER_BLOWFISH_CBC: cipher_type_t = 39;
pub const CIPHER_BLOWFISH_CFB64: cipher_type_t = 40;
pub const CIPHER_BLOWFISH_CTR: cipher_type_t = 41;
pub const CIPHER_ARC4_128: cipher_type_t = 42;
pub const CIPHER_AES_128_CCM: cipher_type_t = 43;
pub const CIPHER_AES_192_CCM: cipher_type_t = 44;
pub const CIPHER_AES_256_CCM: cipher_type_t = 45;
pub const CIPHER_CAMELLIA_128_CCM: cipher_type_t = 46;
pub const CIPHER_CAMELLIA_192_CCM: cipher_type_t = 47;
pub const CIPHER_CAMELLIA_256_CCM: cipher_type_t = 48;
pub const CIPHER_ARIA_128_ECB: cipher_type_t = 49;
pub const CIPHER_ARIA_192_ECB: cipher_type_t = 50;
pub const CIPHER_ARIA_256_ECB: cipher_type_t = 51;
pub const CIPHER_ARIA_128_CBC: cipher_type_t = 52;
pub const CIPHER_ARIA_192_CBC: cipher_type_t = 53;
pub const CIPHER_ARIA_256_CBC: cipher_type_t = 54;
pub const CIPHER_ARIA_128_CFB128: cipher_type_t = 55;
pub const CIPHER_ARIA_192_CFB128: cipher_type_t = 56;
pub const CIPHER_ARIA_256_CFB128: cipher_type_t = 57;
pub const CIPHER_ARIA_128_CTR: cipher_type_t = 58;
pub const CIPHER_ARIA_192_CTR: cipher_type_t = 59;
pub const CIPHER_ARIA_256_CTR: cipher_type_t = 60;
pub const CIPHER_ARIA_128_GCM: cipher_type_t = 61;
pub const CIPHER_ARIA_192_GCM: cipher_type_t = 62;
pub const CIPHER_ARIA_256_GCM: cipher_type_t = 63;
pub const CIPHER_ARIA_128_CCM: cipher_type_t = 64;
pub const CIPHER_ARIA_192_CCM: cipher_type_t = 65;
pub const CIPHER_ARIA_256_CCM: cipher_type_t = 66;
pub const CIPHER_AES_128_OFB: cipher_type_t = 67;
pub const CIPHER_AES_192_OFB: cipher_type_t = 68;
pub const CIPHER_AES_256_OFB: cipher_type_t = 69;
pub const CIPHER_AES_128_XTS: cipher_type_t = 70;
pub const CIPHER_AES_256_XTS: cipher_type_t = 71;
pub const CIPHER_CHACHA20: cipher_type_t = 72;
pub const CIPHER_CHACHA20_POLY1305: cipher_type_t = 73;
pub const CIPHER_AES_128_KW: cipher_type_t = 74;
pub const CIPHER_AES_192_KW: cipher_type_t = 75;
pub const CIPHER_AES_256_KW: cipher_type_t = 76;
pub const CIPHER_AES_128_KWP: cipher_type_t = 77;
pub const CIPHER_AES_192_KWP: cipher_type_t = 78;
pub const CIPHER_AES_256_KWP: cipher_type_t = 79;
pub type cipher_type_t = u32;
pub const MODE_NONE: cipher_mode_t = 0;
pub const MODE_ECB: cipher_mode_t = 1;
pub const MODE_CBC: cipher_mode_t = 2;
pub const MODE_CFB: cipher_mode_t = 3;
pub const MODE_OFB: cipher_mode_t = 4;
pub const MODE_CTR: cipher_mode_t = 5;
pub const MODE_GCM: cipher_mode_t = 6;
pub const MODE_STREAM: cipher_mode_t = 7;
pub const MODE_CCM: cipher_mode_t = 8;
pub const MODE_XTS: cipher_mode_t = 9;
pub const MODE_CHACHAPOLY: cipher_mode_t = 10;
pub const MODE_KW: cipher_mode_t = 11;
pub const MODE_KWP: cipher_mode_t = 12;
pub type cipher_mode_t = u32;
pub const PADDING_PKCS7: cipher_padding_t = 0;
pub const PADDING_ONE_AND_ZEROS: cipher_padding_t = 1;
pub const PADDING_ZEROS_AND_LEN: cipher_padding_t = 2;
pub const PADDING_ZEROS: cipher_padding_t = 3;
pub const PADDING_NONE: cipher_padding_t = 4;
pub type cipher_padding_t = u32;
pub const OPERATION_NONE: operation_t = -1;
pub const DECRYPT: operation_t = 0;
pub const ENCRYPT: operation_t = 1;
pub type operation_t = i32;
pub const KEY_LENGTH_NONE: _bindgen_ty_11 = 0;
pub const KEY_LENGTH_DES: _bindgen_ty_11 = 64;
pub const KEY_LENGTH_DES_EDE: _bindgen_ty_11 = 128;
pub const KEY_LENGTH_DES_EDE3: _bindgen_ty_11 = 192;
pub type _bindgen_ty_11 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cipher_info_t {
    pub type_: cipher_type_t,
    pub mode: cipher_mode_t,
    pub key_bitlen: ::types::raw_types::c_uint,
    pub name: *const ::types::raw_types::c_char,
    pub iv_size: ::types::raw_types::c_uint,
    pub flags: ::types::raw_types::c_int,
    pub block_size: ::types::raw_types::c_uint,
    pub base: *const cipher_base_t,
}
#[test]
fn bindgen_test_layout_cipher_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cipher_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cipher_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(cipher_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cipher_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_bitlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(base)
        )
    );
}
impl Default for cipher_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cipher_context_t {
    pub cipher_info: *const cipher_info_t,
    pub key_bitlen: ::types::raw_types::c_int,
    pub operation: operation_t,
    pub add_padding: ::core::option::Option<
        unsafe extern "C" fn(
            output: *mut ::types::raw_types::c_uchar,
            olen: usize,
            data_len: usize,
        ),
    >,
    pub get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut ::types::raw_types::c_uchar,
            ilen: usize,
            data_len: *mut usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub unprocessed_data: [::types::raw_types::c_uchar; 16usize],
    pub unprocessed_len: usize,
    pub iv: [::types::raw_types::c_uchar; 16usize],
    pub iv_size: usize,
    pub cipher_ctx: *mut ::types::raw_types::c_void,
    pub cmac_ctx: *mut cmac_context_t,
}
#[test]
fn bindgen_test_layout_cipher_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<cipher_context_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cipher_context_t>(),
        96usize,
        concat!("Size of: ", stringify!(cipher_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cipher_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(cipher_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_bitlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_padding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(add_padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_padding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(get_padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(unprocessed_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_size) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_ctx) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(cipher_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmac_ctx) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(cmac_ctx)
        )
    );
}
impl Default for cipher_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_list"]
    pub fn cipher_list() -> *const ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_info_from_string"]
    pub fn cipher_info_from_string(
        cipher_name: *const ::types::raw_types::c_char,
    ) -> *const cipher_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_info_from_type"]
    pub fn cipher_info_from_type(cipher_type: cipher_type_t) -> *const cipher_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_info_from_values"]
    pub fn cipher_info_from_values(
        cipher_id: cipher_id_t,
        key_bitlen: ::types::raw_types::c_int,
        mode: cipher_mode_t,
    ) -> *const cipher_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_init"]
    pub fn cipher_init(ctx: *mut cipher_context_t);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_free"]
    pub fn cipher_free(ctx: *mut cipher_context_t);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_setup"]
    pub fn cipher_setup(
        ctx: *mut cipher_context_t,
        cipher_info: *const cipher_info_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_setkey"]
    pub fn cipher_setkey(
        ctx: *mut cipher_context_t,
        key: *const ::types::raw_types::c_uchar,
        key_bitlen: ::types::raw_types::c_int,
        operation: operation_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_set_padding_mode"]
    pub fn cipher_set_padding_mode(
        ctx: *mut cipher_context_t,
        mode: cipher_padding_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_set_iv"]
    pub fn cipher_set_iv(
        ctx: *mut cipher_context_t,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_reset"]
    pub fn cipher_reset(ctx: *mut cipher_context_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_update_ad"]
    pub fn cipher_update_ad(
        ctx: *mut cipher_context_t,
        ad: *const ::types::raw_types::c_uchar,
        ad_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_update"]
    pub fn cipher_update(
        ctx: *mut cipher_context_t,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_finish"]
    pub fn cipher_finish(
        ctx: *mut cipher_context_t,
        output: *mut ::types::raw_types::c_uchar,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_write_tag"]
    pub fn cipher_write_tag(
        ctx: *mut cipher_context_t,
        tag: *mut ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_check_tag"]
    pub fn cipher_check_tag(
        ctx: *mut cipher_context_t,
        tag: *const ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_crypt"]
    pub fn cipher_crypt(
        ctx: *mut cipher_context_t,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_auth_encrypt"]
    pub fn cipher_auth_encrypt(
        ctx: *mut cipher_context_t,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        ad: *const ::types::raw_types::c_uchar,
        ad_len: usize,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        olen: *mut usize,
        tag: *mut ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_auth_decrypt"]
    pub fn cipher_auth_decrypt(
        ctx: *mut cipher_context_t,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        ad: *const ::types::raw_types::c_uchar,
        ad_len: usize,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        olen: *mut usize,
        tag: *const ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_auth_encrypt_ext"]
    pub fn cipher_auth_encrypt_ext(
        ctx: *mut cipher_context_t,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        ad: *const ::types::raw_types::c_uchar,
        ad_len: usize,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        output_len: usize,
        olen: *mut usize,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_auth_decrypt_ext"]
    pub fn cipher_auth_decrypt_ext(
        ctx: *mut cipher_context_t,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        ad: *const ::types::raw_types::c_uchar,
        ad_len: usize,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        output_len: usize,
        olen: *mut usize,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crl_entry {
    pub raw: x509_buf,
    pub serial: x509_buf,
    pub revocation_date: x509_time,
    pub entry_ext: x509_buf,
    pub next: *mut x509_crl_entry,
}
#[test]
fn bindgen_test_layout_x509_crl_entry() {
    const UNINIT: ::core::mem::MaybeUninit<x509_crl_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_crl_entry>(),
        104usize,
        concat!("Size of: ", stringify!(x509_crl_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crl_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crl_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).revocation_date) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(revocation_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry_ext) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(entry_ext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(next)
        )
    );
}
impl Default for x509_crl_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crl {
    pub raw: x509_buf,
    pub tbs: x509_buf,
    pub version: ::types::raw_types::c_int,
    pub sig_oid: x509_buf,
    pub issuer_raw: x509_buf,
    pub issuer: x509_name,
    pub this_update: x509_time,
    pub next_update: x509_time,
    pub entry: x509_crl_entry,
    pub crl_ext: x509_buf,
    pub sig_oid2: x509_buf,
    pub sig: x509_buf,
    pub sig_md: md_type_t,
    pub sig_pk: pk_type_t,
    pub sig_opts: *mut ::types::raw_types::c_void,
    pub next: *mut x509_crl,
}
#[test]
fn bindgen_test_layout_x509_crl() {
    const UNINIT: ::core::mem::MaybeUninit<x509_crl> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_crl>(),
        416usize,
        concat!("Size of: ", stringify!(x509_crl))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crl>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tbs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(tbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_oid) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer_raw) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(issuer_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).this_update) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(this_update)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_update) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(next_update)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crl_ext) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(crl_ext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_oid2) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_oid2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_md) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_pk) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_opts) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_opts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(next)
        )
    );
}
impl Default for x509_crl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crl_parse_der"]
    pub fn x509_crl_parse_der(
        chain: *mut x509_crl,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crl_parse"]
    pub fn x509_crl_parse(
        chain: *mut x509_crl,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crl_parse_file"]
    pub fn x509_crl_parse_file(
        chain: *mut x509_crl,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crl_info"]
    pub fn x509_crl_info(
        buf: *mut ::types::raw_types::c_char,
        size: usize,
        prefix: *const ::types::raw_types::c_char,
        crl: *const x509_crl,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crl_init"]
    pub fn x509_crl_init(crl: *mut x509_crl);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crl_free"]
    pub fn x509_crl_free(crl: *mut x509_crl);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aes_context {
    pub nr: ::types::raw_types::c_int,
    pub rk: *mut u32,
    pub buf: [u32; 68usize],
}
#[test]
fn bindgen_test_layout_aes_context() {
    const UNINIT: ::core::mem::MaybeUninit<aes_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<aes_context>(),
        288usize,
        concat!("Size of: ", stringify!(aes_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aes_context>(),
        8usize,
        concat!("Alignment of ", stringify!(aes_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rk) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(rk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(buf)
        )
    );
}
impl Default for aes_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aes_xts_context {
    pub crypt: aes_context,
    pub tweak: aes_context,
}
#[test]
fn bindgen_test_layout_aes_xts_context() {
    const UNINIT: ::core::mem::MaybeUninit<aes_xts_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<aes_xts_context>(),
        576usize,
        concat!("Size of: ", stringify!(aes_xts_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aes_xts_context>(),
        8usize,
        concat!("Alignment of ", stringify!(aes_xts_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_xts_context),
            "::",
            stringify!(crypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tweak) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_xts_context),
            "::",
            stringify!(tweak)
        )
    );
}
impl Default for aes_xts_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aes_init"]
    pub fn aes_init(ctx: *mut aes_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aes_free"]
    pub fn aes_free(ctx: *mut aes_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aes_xts_init"]
    pub fn aes_xts_init(ctx: *mut aes_xts_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aes_xts_free"]
    pub fn aes_xts_free(ctx: *mut aes_xts_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_setkey_enc"]
    pub fn aes_setkey_enc(
        ctx: *mut aes_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_setkey_dec"]
    pub fn aes_setkey_dec(
        ctx: *mut aes_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_xts_setkey_enc"]
    pub fn aes_xts_setkey_enc(
        ctx: *mut aes_xts_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_xts_setkey_dec"]
    pub fn aes_xts_setkey_dec(
        ctx: *mut aes_xts_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_crypt_ecb"]
    pub fn aes_crypt_ecb(
        ctx: *mut aes_context,
        mode: ::types::raw_types::c_int,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_crypt_cbc"]
    pub fn aes_crypt_cbc(
        ctx: *mut aes_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_crypt_xts"]
    pub fn aes_crypt_xts(
        ctx: *mut aes_xts_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        data_unit: *const ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_crypt_cfb128"]
    pub fn aes_crypt_cfb128(
        ctx: *mut aes_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_crypt_cfb8"]
    pub fn aes_crypt_cfb8(
        ctx: *mut aes_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_crypt_ofb"]
    pub fn aes_crypt_ofb(
        ctx: *mut aes_context,
        length: usize,
        iv_off: *mut usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_crypt_ctr"]
    pub fn aes_crypt_ctr(
        ctx: *mut aes_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut ::types::raw_types::c_uchar,
        stream_block: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_internal_aes_encrypt"]
    pub fn internal_aes_encrypt(
        ctx: *mut aes_context,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_internal_aes_decrypt"]
    pub fn internal_aes_decrypt(
        ctx: *mut aes_context,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aes_encrypt"]
    pub fn aes_encrypt(
        ctx: *mut aes_context,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aes_decrypt"]
    pub fn aes_decrypt(
        ctx: *mut aes_context,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_aes_self_test"]
    pub fn aes_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
pub const KEY_EXCHANGE_NONE: key_exchange_type_t = 0;
pub const KEY_EXCHANGE_RSA: key_exchange_type_t = 1;
pub const KEY_EXCHANGE_DHE_RSA: key_exchange_type_t = 2;
pub const KEY_EXCHANGE_ECDHE_RSA: key_exchange_type_t = 3;
pub const KEY_EXCHANGE_ECDHE_ECDSA: key_exchange_type_t = 4;
pub const KEY_EXCHANGE_PSK: key_exchange_type_t = 5;
pub const KEY_EXCHANGE_DHE_PSK: key_exchange_type_t = 6;
pub const KEY_EXCHANGE_RSA_PSK: key_exchange_type_t = 7;
pub const KEY_EXCHANGE_ECDHE_PSK: key_exchange_type_t = 8;
pub const KEY_EXCHANGE_ECDH_RSA: key_exchange_type_t = 9;
pub const KEY_EXCHANGE_ECDH_ECDSA: key_exchange_type_t = 10;
pub const KEY_EXCHANGE_ECJPAKE: key_exchange_type_t = 11;
pub type key_exchange_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_ciphersuite_t {
    pub id: ::types::raw_types::c_int,
    pub name: *const ::types::raw_types::c_char,
    pub cipher: cipher_type_t,
    pub mac: md_type_t,
    pub key_exchange: key_exchange_type_t,
    pub min_major_ver: ::types::raw_types::c_int,
    pub min_minor_ver: ::types::raw_types::c_int,
    pub max_major_ver: ::types::raw_types::c_int,
    pub max_minor_ver: ::types::raw_types::c_int,
    pub flags: ::types::raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_ssl_ciphersuite_t() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_ciphersuite_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_ciphersuite_t>(),
        48usize,
        concat!("Size of: ", stringify!(ssl_ciphersuite_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ciphersuite_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_ciphersuite_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_exchange) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(key_exchange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_major_ver) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(min_major_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_minor_ver) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(min_minor_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_major_ver) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_minor_ver) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ssl_ciphersuite_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_list_ciphersuites"]
    pub fn ssl_list_ciphersuites() -> *const ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ciphersuite_from_string"]
    pub fn ssl_ciphersuite_from_string(
        ciphersuite_name: *const ::types::raw_types::c_char,
    ) -> *const ssl_ciphersuite_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ciphersuite_from_id"]
    pub fn ssl_ciphersuite_from_id(
        ciphersuite_id: ::types::raw_types::c_int,
    ) -> *const ssl_ciphersuite_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite_sig_pk_alg"]
    pub fn ssl_get_ciphersuite_sig_pk_alg(info: *const ssl_ciphersuite_t) -> pk_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite_sig_alg"]
    pub fn ssl_get_ciphersuite_sig_alg(info: *const ssl_ciphersuite_t) -> pk_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ciphersuite_uses_ec"]
    pub fn ssl_ciphersuite_uses_ec(info: *const ssl_ciphersuite_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ciphersuite_uses_psk"]
    pub fn ssl_ciphersuite_uses_psk(info: *const ssl_ciphersuite_t) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crt {
    pub own_buffer: ::types::raw_types::c_int,
    pub raw: x509_buf,
    pub tbs: x509_buf,
    pub version: ::types::raw_types::c_int,
    pub serial: x509_buf,
    pub sig_oid: x509_buf,
    pub issuer_raw: x509_buf,
    pub subject_raw: x509_buf,
    pub issuer: x509_name,
    pub subject: x509_name,
    pub valid_from: x509_time,
    pub valid_to: x509_time,
    pub pk_raw: x509_buf,
    pub pk: pk_context,
    pub issuer_id: x509_buf,
    pub subject_id: x509_buf,
    pub v3_ext: x509_buf,
    pub subject_alt_names: x509_sequence,
    pub certificate_policies: x509_sequence,
    pub ext_types: ::types::raw_types::c_int,
    pub ca_istrue: ::types::raw_types::c_int,
    pub max_pathlen: ::types::raw_types::c_int,
    pub key_usage: ::types::raw_types::c_uint,
    pub ext_key_usage: x509_sequence,
    pub ns_cert_type: ::types::raw_types::c_uchar,
    pub sig: x509_buf,
    pub sig_md: md_type_t,
    pub sig_pk: pk_type_t,
    pub sig_opts: *mut ::types::raw_types::c_void,
    pub next: *mut x509_crt,
}
#[test]
fn bindgen_test_layout_x509_crt() {
    const UNINIT: ::core::mem::MaybeUninit<x509_crt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_crt>(),
        616usize,
        concat!("Size of: ", stringify!(x509_crt))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).own_buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(own_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tbs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(tbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_oid) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer_raw) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject_raw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_from) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(valid_from)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_to) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(valid_to)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pk_raw) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(pk_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pk) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(pk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer_id) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject_id) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v3_ext) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(v3_ext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject_alt_names) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_alt_names)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certificate_policies) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(certificate_policies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_types) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ext_types)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ca_istrue) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ca_istrue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pathlen) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(max_pathlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_usage) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(key_usage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_key_usage) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ext_key_usage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ns_cert_type) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ns_cert_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_md) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_pk) as usize - ptr as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_opts) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_opts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(next)
        )
    );
}
impl Default for x509_crt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_san_other_name {
    pub type_id: x509_buf,
    pub value: x509_san_other_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x509_san_other_name__bindgen_ty_1 {
    pub hardware_module_name: x509_san_other_name__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    pub oid: x509_buf,
    pub val: x509_buf,
}
#[test]
fn bindgen_test_layout_x509_san_other_name__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<x509_san_other_name__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_san_other_name__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(x509_san_other_name__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<x509_san_other_name__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(x509_san_other_name__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
impl Default for x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_x509_san_other_name__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<x509_san_other_name__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_san_other_name__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(x509_san_other_name__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_san_other_name__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(x509_san_other_name__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardware_module_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name__bindgen_ty_1),
            "::",
            stringify!(hardware_module_name)
        )
    );
}
impl Default for x509_san_other_name__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_x509_san_other_name() {
    const UNINIT: ::core::mem::MaybeUninit<x509_san_other_name> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_san_other_name>(),
        72usize,
        concat!("Size of: ", stringify!(x509_san_other_name))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_san_other_name>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_san_other_name))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name),
            "::",
            stringify!(value)
        )
    );
}
impl Default for x509_san_other_name {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_subject_alternative_name {
    pub type_: ::types::raw_types::c_int,
    pub san: x509_subject_alternative_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x509_subject_alternative_name__bindgen_ty_1 {
    pub other_name: x509_san_other_name,
    pub unstructured_name: x509_buf,
}
#[test]
fn bindgen_test_layout_x509_subject_alternative_name__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<x509_subject_alternative_name__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_subject_alternative_name__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(x509_subject_alternative_name__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<x509_subject_alternative_name__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(x509_subject_alternative_name__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).other_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_subject_alternative_name__bindgen_ty_1),
            "::",
            stringify!(other_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unstructured_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_subject_alternative_name__bindgen_ty_1),
            "::",
            stringify!(unstructured_name)
        )
    );
}
impl Default for x509_subject_alternative_name__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_x509_subject_alternative_name() {
    const UNINIT: ::core::mem::MaybeUninit<x509_subject_alternative_name> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_subject_alternative_name>(),
        80usize,
        concat!("Size of: ", stringify!(x509_subject_alternative_name))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_subject_alternative_name>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_subject_alternative_name))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_subject_alternative_name),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).san) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_subject_alternative_name),
            "::",
            stringify!(san)
        )
    );
}
impl Default for x509_subject_alternative_name {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x509_crt_profile {
    pub allowed_mds: u32,
    pub allowed_pks: u32,
    pub allowed_curves: u32,
    pub rsa_min_bitlen: u32,
}
#[test]
fn bindgen_test_layout_x509_crt_profile() {
    const UNINIT: ::core::mem::MaybeUninit<x509_crt_profile> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_crt_profile>(),
        16usize,
        concat!("Size of: ", stringify!(x509_crt_profile))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_profile>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_crt_profile))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allowed_mds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_mds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allowed_pks) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_pks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allowed_curves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_curves)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsa_min_bitlen) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(rsa_min_bitlen)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509write_cert {
    pub version: ::types::raw_types::c_int,
    pub serial: mpi,
    pub subject_key: *mut pk_context,
    pub issuer_key: *mut pk_context,
    pub subject: *mut asn1_named_data,
    pub issuer: *mut asn1_named_data,
    pub md_alg: md_type_t,
    pub not_before: [::types::raw_types::c_char; 16usize],
    pub not_after: [::types::raw_types::c_char; 16usize],
    pub extensions: *mut asn1_named_data,
}
#[test]
fn bindgen_test_layout_x509write_cert() {
    const UNINIT: ::core::mem::MaybeUninit<x509write_cert> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509write_cert>(),
        112usize,
        concat!("Size of: ", stringify!(x509write_cert))
    );
    assert_eq!(
        ::core::mem::align_of::<x509write_cert>(),
        8usize,
        concat!("Alignment of ", stringify!(x509write_cert))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject_key) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(subject_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer_key) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(issuer_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_alg) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(md_alg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).not_before) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(not_before)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).not_after) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(not_after)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(extensions)
        )
    );
}
impl Default for x509write_cert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crt_verify_chain_item {
    pub crt: *mut x509_crt,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_x509_crt_verify_chain_item() {
    const UNINIT: ::core::mem::MaybeUninit<x509_crt_verify_chain_item> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_crt_verify_chain_item>(),
        16usize,
        concat!("Size of: ", stringify!(x509_crt_verify_chain_item))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_verify_chain_item>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crt_verify_chain_item))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain_item),
            "::",
            stringify!(crt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain_item),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for x509_crt_verify_chain_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crt_verify_chain {
    pub items: [x509_crt_verify_chain_item; 10usize],
    pub len: ::types::raw_types::c_uint,
    pub trust_ca_cb_result: *mut x509_crt,
}
#[test]
fn bindgen_test_layout_x509_crt_verify_chain() {
    const UNINIT: ::core::mem::MaybeUninit<x509_crt_verify_chain> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_crt_verify_chain>(),
        176usize,
        concat!("Size of: ", stringify!(x509_crt_verify_chain))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_verify_chain>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crt_verify_chain))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trust_ca_cb_result) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain),
            "::",
            stringify!(trust_ca_cb_result)
        )
    );
}
impl Default for x509_crt_verify_chain {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type x509_crt_restart_ctx = ::types::raw_types::c_void;
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_profile_default"]
    pub static x509_crt_profile_default: x509_crt_profile;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_profile_next"]
    pub static x509_crt_profile_next: x509_crt_profile;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_profile_suiteb"]
    pub static x509_crt_profile_suiteb: x509_crt_profile;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_parse_der"]
    pub fn x509_crt_parse_der(
        chain: *mut x509_crt,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
pub type x509_crt_ext_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut ::types::raw_types::c_void,
        crt: *const x509_crt,
        oid: *const x509_buf,
        critical: ::types::raw_types::c_int,
        p: *const ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int,
>;
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_parse_der_with_ext_cb"]
    pub fn x509_crt_parse_der_with_ext_cb(
        chain: *mut x509_crt,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
        make_copy: ::types::raw_types::c_int,
        cb: x509_crt_ext_cb_t,
        p_ctx: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_parse_der_nocopy"]
    pub fn x509_crt_parse_der_nocopy(
        chain: *mut x509_crt,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_parse"]
    pub fn x509_crt_parse(
        chain: *mut x509_crt,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_parse_file"]
    pub fn x509_crt_parse_file(
        chain: *mut x509_crt,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_parse_path"]
    pub fn x509_crt_parse_path(
        chain: *mut x509_crt,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_parse_subject_alt_name"]
    pub fn x509_parse_subject_alt_name(
        san_buf: *const x509_buf,
        san: *mut x509_subject_alternative_name,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_info"]
    pub fn x509_crt_info(
        buf: *mut ::types::raw_types::c_char,
        size: usize,
        prefix: *const ::types::raw_types::c_char,
        crt: *const x509_crt,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_verify_info"]
    pub fn x509_crt_verify_info(
        buf: *mut ::types::raw_types::c_char,
        size: usize,
        prefix: *const ::types::raw_types::c_char,
        flags: u32,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_verify"]
    pub fn x509_crt_verify(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        cn: *const ::types::raw_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: ::types::raw_types::c_int,
                arg4: *mut u32,
            ) -> ::types::raw_types::c_int,
        >,
        p_vrfy: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_verify_with_profile"]
    pub fn x509_crt_verify_with_profile(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        profile: *const x509_crt_profile,
        cn: *const ::types::raw_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: ::types::raw_types::c_int,
                arg4: *mut u32,
            ) -> ::types::raw_types::c_int,
        >,
        p_vrfy: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_verify_restartable"]
    pub fn x509_crt_verify_restartable(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        profile: *const x509_crt_profile,
        cn: *const ::types::raw_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: ::types::raw_types::c_int,
                arg4: *mut u32,
            ) -> ::types::raw_types::c_int,
        >,
        p_vrfy: *mut ::types::raw_types::c_void,
        rs_ctx: *mut x509_crt_restart_ctx,
    ) -> ::types::raw_types::c_int;
}
pub type x509_crt_ca_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut ::types::raw_types::c_void,
        child: *const x509_crt,
        candidate_cas: *mut *mut x509_crt,
    ) -> ::types::raw_types::c_int,
>;
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_verify_with_ca_cb"]
    pub fn x509_crt_verify_with_ca_cb(
        crt: *mut x509_crt,
        f_ca_cb: x509_crt_ca_cb_t,
        p_ca_cb: *mut ::types::raw_types::c_void,
        profile: *const x509_crt_profile,
        cn: *const ::types::raw_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: ::types::raw_types::c_int,
                arg4: *mut u32,
            ) -> ::types::raw_types::c_int,
        >,
        p_vrfy: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_check_key_usage"]
    pub fn x509_crt_check_key_usage(
        crt: *const x509_crt,
        usage: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_check_extended_key_usage"]
    pub fn x509_crt_check_extended_key_usage(
        crt: *const x509_crt,
        usage_oid: *const ::types::raw_types::c_char,
        usage_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_is_revoked"]
    pub fn x509_crt_is_revoked(
        crt: *const x509_crt,
        crl: *const x509_crl,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_init"]
    pub fn x509_crt_init(crt: *mut x509_crt);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_free"]
    pub fn x509_crt_free(crt: *mut x509_crt);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_init"]
    pub fn x509write_crt_init(ctx: *mut x509write_cert);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_version"]
    pub fn x509write_crt_set_version(ctx: *mut x509write_cert, version: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_serial"]
    pub fn x509write_crt_set_serial(
        ctx: *mut x509write_cert,
        serial: *const mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_validity"]
    pub fn x509write_crt_set_validity(
        ctx: *mut x509write_cert,
        not_before: *const ::types::raw_types::c_char,
        not_after: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_issuer_name"]
    pub fn x509write_crt_set_issuer_name(
        ctx: *mut x509write_cert,
        issuer_name: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_subject_name"]
    pub fn x509write_crt_set_subject_name(
        ctx: *mut x509write_cert,
        subject_name: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_subject_key"]
    pub fn x509write_crt_set_subject_key(ctx: *mut x509write_cert, key: *mut pk_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_issuer_key"]
    pub fn x509write_crt_set_issuer_key(ctx: *mut x509write_cert, key: *mut pk_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_md_alg"]
    pub fn x509write_crt_set_md_alg(ctx: *mut x509write_cert, md_alg: md_type_t);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_extension"]
    pub fn x509write_crt_set_extension(
        ctx: *mut x509write_cert,
        oid: *const ::types::raw_types::c_char,
        oid_len: usize,
        critical: ::types::raw_types::c_int,
        val: *const ::types::raw_types::c_uchar,
        val_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_basic_constraints"]
    pub fn x509write_crt_set_basic_constraints(
        ctx: *mut x509write_cert,
        is_ca: ::types::raw_types::c_int,
        max_pathlen: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_subject_key_identifier"]
    pub fn x509write_crt_set_subject_key_identifier(
        ctx: *mut x509write_cert,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_authority_key_identifier"]
    pub fn x509write_crt_set_authority_key_identifier(
        ctx: *mut x509write_cert,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_key_usage"]
    pub fn x509write_crt_set_key_usage(
        ctx: *mut x509write_cert,
        key_usage: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_set_ns_cert_type"]
    pub fn x509write_crt_set_ns_cert_type(
        ctx: *mut x509write_cert,
        ns_cert_type: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_free"]
    pub fn x509write_crt_free(ctx: *mut x509write_cert);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_der"]
    pub fn x509write_crt_der(
        ctx: *mut x509write_cert,
        buf: *mut ::types::raw_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_crt_pem"]
    pub fn x509write_crt_pem(
        ctx: *mut x509write_cert,
        buf: *mut ::types::raw_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dhm_context {
    pub len: usize,
    pub P: mpi,
    pub G: mpi,
    pub X: mpi,
    pub GX: mpi,
    pub GY: mpi,
    pub K: mpi,
    pub RP: mpi,
    pub Vi: mpi,
    pub Vf: mpi,
    pub pX: mpi,
}
#[test]
fn bindgen_test_layout_dhm_context() {
    const UNINIT: ::core::mem::MaybeUninit<dhm_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<dhm_context>(),
        248usize,
        concat!("Size of: ", stringify!(dhm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<dhm_context>(),
        8usize,
        concat!("Alignment of ", stringify!(dhm_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).P) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).G) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GX) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(GX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GY) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(GY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).K) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(K)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RP) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(RP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vi) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vf) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pX) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(pX)
        )
    );
}
impl Default for dhm_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_init"]
    pub fn dhm_init(ctx: *mut dhm_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_read_params"]
    pub fn dhm_read_params(
        ctx: *mut dhm_context,
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_make_params"]
    pub fn dhm_make_params(
        ctx: *mut dhm_context,
        x_size: ::types::raw_types::c_int,
        output: *mut ::types::raw_types::c_uchar,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_set_group"]
    pub fn dhm_set_group(
        ctx: *mut dhm_context,
        P: *const mpi,
        G: *const mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_read_public"]
    pub fn dhm_read_public(
        ctx: *mut dhm_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_make_public"]
    pub fn dhm_make_public(
        ctx: *mut dhm_context,
        x_size: ::types::raw_types::c_int,
        output: *mut ::types::raw_types::c_uchar,
        olen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_calc_secret"]
    pub fn dhm_calc_secret(
        ctx: *mut dhm_context,
        output: *mut ::types::raw_types::c_uchar,
        output_size: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_free"]
    pub fn dhm_free(ctx: *mut dhm_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_parse_dhm"]
    pub fn dhm_parse_dhm(
        dhm: *mut dhm_context,
        dhmin: *const ::types::raw_types::c_uchar,
        dhminlen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_parse_dhmfile"]
    pub fn dhm_parse_dhmfile(
        dhm: *mut dhm_context,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_dhm_self_test"]
    pub fn dhm_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
pub const ECDH_OURS: ecdh_side = 0;
pub const ECDH_THEIRS: ecdh_side = 1;
pub type ecdh_side = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecdh_context {
    pub grp: ecp_group,
    pub d: mpi,
    pub Q: ecp_point,
    pub Qp: ecp_point,
    pub z: mpi,
    pub point_format: ::types::raw_types::c_int,
    pub Vi: ecp_point,
    pub Vf: ecp_point,
    pub _d: mpi,
}
#[test]
fn bindgen_test_layout_ecdh_context() {
    const UNINIT: ::core::mem::MaybeUninit<ecdh_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ecdh_context>(),
        616usize,
        concat!("Size of: ", stringify!(ecdh_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ecdh_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ecdh_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Q) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Qp) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Qp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).point_format) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(point_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vi) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vf) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._d) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(_d)
        )
    );
}
impl Default for ecdh_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_can_do"]
    pub fn ecdh_can_do(gid: ecp_group_id) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_gen_public"]
    pub fn ecdh_gen_public(
        grp: *mut ecp_group,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_compute_shared"]
    pub fn ecdh_compute_shared(
        grp: *mut ecp_group,
        z: *mut mpi,
        Q: *const ecp_point,
        d: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_init"]
    pub fn ecdh_init(ctx: *mut ecdh_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_setup"]
    pub fn ecdh_setup(ctx: *mut ecdh_context, grp_id: ecp_group_id) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_free"]
    pub fn ecdh_free(ctx: *mut ecdh_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_make_params"]
    pub fn ecdh_make_params(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut ::types::raw_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_read_params"]
    pub fn ecdh_read_params(
        ctx: *mut ecdh_context,
        buf: *mut *const ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_get_params"]
    pub fn ecdh_get_params(
        ctx: *mut ecdh_context,
        key: *const ecp_keypair,
        side: ecdh_side,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_make_public"]
    pub fn ecdh_make_public(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut ::types::raw_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_read_public"]
    pub fn ecdh_read_public(
        ctx: *mut ecdh_context,
        buf: *const ::types::raw_types::c_uchar,
        blen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdh_calc_secret"]
    pub fn ecdh_calc_secret(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut ::types::raw_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct oid_descriptor_t {
    pub asn1: *const ::types::raw_types::c_char,
    pub asn1_len: usize,
    pub name: *const ::types::raw_types::c_char,
    pub description: *const ::types::raw_types::c_char,
}
#[test]
fn bindgen_test_layout_oid_descriptor_t() {
    const UNINIT: ::core::mem::MaybeUninit<oid_descriptor_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<oid_descriptor_t>(),
        32usize,
        concat!("Size of: ", stringify!(oid_descriptor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<oid_descriptor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(oid_descriptor_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).asn1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(asn1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).asn1_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(asn1_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(description)
        )
    );
}
impl Default for oid_descriptor_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_numeric_string"]
    pub fn oid_get_numeric_string(
        buf: *mut ::types::raw_types::c_char,
        size: usize,
        oid: *const asn1_buf,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_x509_ext_type"]
    pub fn oid_get_x509_ext_type(
        oid: *const asn1_buf,
        ext_type: *mut ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_attr_short_name"]
    pub fn oid_get_attr_short_name(
        oid: *const asn1_buf,
        short_name: *mut *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_pk_alg"]
    pub fn oid_get_pk_alg(
        oid: *const asn1_buf,
        pk_alg: *mut pk_type_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_oid_by_pk_alg"]
    pub fn oid_get_oid_by_pk_alg(
        pk_alg: pk_type_t,
        oid: *mut *const ::types::raw_types::c_char,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_ec_grp"]
    pub fn oid_get_ec_grp(
        oid: *const asn1_buf,
        grp_id: *mut ecp_group_id,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_oid_by_ec_grp"]
    pub fn oid_get_oid_by_ec_grp(
        grp_id: ecp_group_id,
        oid: *mut *const ::types::raw_types::c_char,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_sig_alg"]
    pub fn oid_get_sig_alg(
        oid: *const asn1_buf,
        md_alg: *mut md_type_t,
        pk_alg: *mut pk_type_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_sig_alg_desc"]
    pub fn oid_get_sig_alg_desc(
        oid: *const asn1_buf,
        desc: *mut *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_oid_by_sig_alg"]
    pub fn oid_get_oid_by_sig_alg(
        pk_alg: pk_type_t,
        md_alg: md_type_t,
        oid: *mut *const ::types::raw_types::c_char,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_md_alg"]
    pub fn oid_get_md_alg(
        oid: *const asn1_buf,
        md_alg: *mut md_type_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_md_hmac"]
    pub fn oid_get_md_hmac(
        oid: *const asn1_buf,
        md_hmac: *mut md_type_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_extended_key_usage"]
    pub fn oid_get_extended_key_usage(
        oid: *const asn1_buf,
        desc: *mut *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_certificate_policies"]
    pub fn oid_get_certificate_policies(
        oid: *const asn1_buf,
        desc: *mut *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_oid_by_md"]
    pub fn oid_get_oid_by_md(
        md_alg: md_type_t,
        oid: *mut *const ::types::raw_types::c_char,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_cipher_alg"]
    pub fn oid_get_cipher_alg(
        oid: *const asn1_buf,
        cipher_alg: *mut cipher_type_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_oid_get_pkcs12_pbe_alg"]
    pub fn oid_get_pkcs12_pbe_alg(
        oid: *const asn1_buf,
        md_alg: *mut md_type_t,
        cipher_alg: *mut cipher_type_t,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctr_drbg_context {
    pub counter: [::types::raw_types::c_uchar; 16usize],
    pub reseed_counter: ::types::raw_types::c_int,
    pub prediction_resistance: ::types::raw_types::c_int,
    pub entropy_len: usize,
    pub reseed_interval: ::types::raw_types::c_int,
    pub aes_ctx: aes_context,
    pub f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut ::types::raw_types::c_uchar,
            arg3: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_entropy: *mut ::types::raw_types::c_void,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_ctr_drbg_context() {
    const UNINIT: ::core::mem::MaybeUninit<ctr_drbg_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ctr_drbg_context>(),
        392usize,
        concat!("Size of: ", stringify!(ctr_drbg_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ctr_drbg_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ctr_drbg_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reseed_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(reseed_counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prediction_resistance) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(prediction_resistance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entropy_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(entropy_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reseed_interval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(reseed_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aes_ctx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_entropy) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(f_entropy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_entropy) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(p_entropy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(mutex)
        )
    );
}
impl Default for ctr_drbg_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_init"]
    pub fn ctr_drbg_init(ctx: *mut ctr_drbg_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_seed"]
    pub fn ctr_drbg_seed(
        ctx: *mut ctr_drbg_context,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_entropy: *mut ::types::raw_types::c_void,
        custom: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_free"]
    pub fn ctr_drbg_free(ctx: *mut ctr_drbg_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_set_prediction_resistance"]
    pub fn ctr_drbg_set_prediction_resistance(
        ctx: *mut ctr_drbg_context,
        resistance: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_set_entropy_len"]
    pub fn ctr_drbg_set_entropy_len(ctx: *mut ctr_drbg_context, len: usize);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_set_nonce_len"]
    pub fn ctr_drbg_set_nonce_len(
        ctx: *mut ctr_drbg_context,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_set_reseed_interval"]
    pub fn ctr_drbg_set_reseed_interval(
        ctx: *mut ctr_drbg_context,
        interval: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_reseed"]
    pub fn ctr_drbg_reseed(
        ctx: *mut ctr_drbg_context,
        additional: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_update_ret"]
    pub fn ctr_drbg_update_ret(
        ctx: *mut ctr_drbg_context,
        additional: *const ::types::raw_types::c_uchar,
        add_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_random_with_add"]
    pub fn ctr_drbg_random_with_add(
        p_rng: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        output_len: usize,
        additional: *const ::types::raw_types::c_uchar,
        add_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_random"]
    pub fn ctr_drbg_random(
        p_rng: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        output_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_update"]
    pub fn ctr_drbg_update(
        ctx: *mut ctr_drbg_context,
        additional: *const ::types::raw_types::c_uchar,
        add_len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_write_seed_file"]
    pub fn ctr_drbg_write_seed_file(
        ctx: *mut ctr_drbg_context,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_update_seed_file"]
    pub fn ctr_drbg_update_seed_file(
        ctx: *mut ctr_drbg_context,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ctr_drbg_self_test"]
    pub fn ctr_drbg_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hmac_drbg_context {
    pub md_ctx: md_context_t,
    pub V: [::types::raw_types::c_uchar; 64usize],
    pub reseed_counter: ::types::raw_types::c_int,
    pub entropy_len: usize,
    pub prediction_resistance: ::types::raw_types::c_int,
    pub reseed_interval: ::types::raw_types::c_int,
    pub f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut ::types::raw_types::c_uchar,
            arg3: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_entropy: *mut ::types::raw_types::c_void,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_hmac_drbg_context() {
    const UNINIT: ::core::mem::MaybeUninit<hmac_drbg_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hmac_drbg_context>(),
        176usize,
        concat!("Size of: ", stringify!(hmac_drbg_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_drbg_context>(),
        8usize,
        concat!("Alignment of ", stringify!(hmac_drbg_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).V) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(V)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reseed_counter) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(reseed_counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entropy_len) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(entropy_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prediction_resistance) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(prediction_resistance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reseed_interval) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(reseed_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_entropy) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(f_entropy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_entropy) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(p_entropy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(mutex)
        )
    );
}
impl Default for hmac_drbg_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_init"]
    pub fn hmac_drbg_init(ctx: *mut hmac_drbg_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_seed"]
    pub fn hmac_drbg_seed(
        ctx: *mut hmac_drbg_context,
        md_info: *const md_info_t,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_entropy: *mut ::types::raw_types::c_void,
        custom: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_seed_buf"]
    pub fn hmac_drbg_seed_buf(
        ctx: *mut hmac_drbg_context,
        md_info: *const md_info_t,
        data: *const ::types::raw_types::c_uchar,
        data_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_set_prediction_resistance"]
    pub fn hmac_drbg_set_prediction_resistance(
        ctx: *mut hmac_drbg_context,
        resistance: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_set_entropy_len"]
    pub fn hmac_drbg_set_entropy_len(ctx: *mut hmac_drbg_context, len: usize);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_set_reseed_interval"]
    pub fn hmac_drbg_set_reseed_interval(
        ctx: *mut hmac_drbg_context,
        interval: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_update_ret"]
    pub fn hmac_drbg_update_ret(
        ctx: *mut hmac_drbg_context,
        additional: *const ::types::raw_types::c_uchar,
        add_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_reseed"]
    pub fn hmac_drbg_reseed(
        ctx: *mut hmac_drbg_context,
        additional: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_random_with_add"]
    pub fn hmac_drbg_random_with_add(
        p_rng: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        output_len: usize,
        additional: *const ::types::raw_types::c_uchar,
        add_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_random"]
    pub fn hmac_drbg_random(
        p_rng: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        out_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_free"]
    pub fn hmac_drbg_free(ctx: *mut hmac_drbg_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_update"]
    pub fn hmac_drbg_update(
        ctx: *mut hmac_drbg_context,
        additional: *const ::types::raw_types::c_uchar,
        add_len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_write_seed_file"]
    pub fn hmac_drbg_write_seed_file(
        ctx: *mut hmac_drbg_context,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_update_seed_file"]
    pub fn hmac_drbg_update_seed_file(
        ctx: *mut hmac_drbg_context,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hmac_drbg_self_test"]
    pub fn hmac_drbg_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ssl_premaster_secret {
    pub dummy: ::types::raw_types::c_uchar,
    pub _pms_rsa: [::types::raw_types::c_uchar; 48usize],
    pub _pms_dhm: [::types::raw_types::c_uchar; 1024usize],
    pub _pms_ecdh: [::types::raw_types::c_uchar; 66usize],
    pub _pms_psk: [::types::raw_types::c_uchar; 68usize],
    pub _pms_dhe_psk: [::types::raw_types::c_uchar; 1060usize],
    pub _pms_rsa_psk: [::types::raw_types::c_uchar; 84usize],
    pub _pms_ecdhe_psk: [::types::raw_types::c_uchar; 102usize],
}
#[test]
fn bindgen_test_layout_ssl_premaster_secret() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_premaster_secret> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_premaster_secret>(),
        1060usize,
        concat!("Size of: ", stringify!(ssl_premaster_secret))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_premaster_secret>(),
        1usize,
        concat!("Alignment of ", stringify!(ssl_premaster_secret))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(dummy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pms_rsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_rsa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pms_dhm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_dhm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pms_ecdh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_ecdh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pms_psk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_psk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pms_dhe_psk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_dhe_psk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pms_rsa_psk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_rsa_psk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pms_ecdhe_psk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_ecdhe_psk)
        )
    );
}
impl Default for ssl_premaster_secret {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SSL_HELLO_REQUEST: ssl_states = 0;
pub const SSL_CLIENT_HELLO: ssl_states = 1;
pub const SSL_SERVER_HELLO: ssl_states = 2;
pub const SSL_SERVER_CERTIFICATE: ssl_states = 3;
pub const SSL_SERVER_KEY_EXCHANGE: ssl_states = 4;
pub const SSL_CERTIFICATE_REQUEST: ssl_states = 5;
pub const SSL_SERVER_HELLO_DONE: ssl_states = 6;
pub const SSL_CLIENT_CERTIFICATE: ssl_states = 7;
pub const SSL_CLIENT_KEY_EXCHANGE: ssl_states = 8;
pub const SSL_CERTIFICATE_VERIFY: ssl_states = 9;
pub const SSL_CLIENT_CHANGE_CIPHER_SPEC: ssl_states = 10;
pub const SSL_CLIENT_FINISHED: ssl_states = 11;
pub const SSL_SERVER_CHANGE_CIPHER_SPEC: ssl_states = 12;
pub const SSL_SERVER_FINISHED: ssl_states = 13;
pub const SSL_FLUSH_BUFFERS: ssl_states = 14;
pub const SSL_HANDSHAKE_WRAPUP: ssl_states = 15;
pub const SSL_HANDSHAKE_OVER: ssl_states = 16;
pub const SSL_SERVER_NEW_SESSION_TICKET: ssl_states = 17;
pub const SSL_SERVER_HELLO_VERIFY_REQUEST_SENT: ssl_states = 18;
pub type ssl_states = u32;
pub const SSL_TLS_PRF_NONE: tls_prf_types = 0;
pub const SSL_TLS_PRF_SSL3: tls_prf_types = 1;
pub const SSL_TLS_PRF_TLS1: tls_prf_types = 2;
pub const SSL_TLS_PRF_SHA384: tls_prf_types = 3;
pub const SSL_TLS_PRF_SHA256: tls_prf_types = 4;
pub type tls_prf_types = u32;
pub type ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::types::raw_types::c_void,
        buf: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int,
>;
pub type ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::types::raw_types::c_void,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int,
>;
pub type ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::types::raw_types::c_void,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
        timeout: u32,
    ) -> ::types::raw_types::c_int,
>;
pub type ssl_set_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::types::raw_types::c_void, int_ms: u32, fin_ms: u32),
>;
pub type ssl_get_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::types::raw_types::c_void) -> ::types::raw_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_session {
    pub mfl_code: ::types::raw_types::c_uchar,
    pub start: time_t,
    pub ciphersuite: ::types::raw_types::c_int,
    pub compression: ::types::raw_types::c_int,
    pub id_len: usize,
    pub id: [::types::raw_types::c_uchar; 32usize],
    pub master: [::types::raw_types::c_uchar; 48usize],
    pub peer_cert: *mut x509_crt,
    pub verify_result: u32,
    pub ticket: *mut ::types::raw_types::c_uchar,
    pub ticket_len: usize,
    pub ticket_lifetime: u32,
    pub trunc_hmac: ::types::raw_types::c_int,
    pub encrypt_then_mac: ::types::raw_types::c_int,
}
#[test]
fn bindgen_test_layout_ssl_session() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_session> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_session>(),
        160usize,
        concat!("Size of: ", stringify!(ssl_session))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_session>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_session))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mfl_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(mfl_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ciphersuite) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ciphersuite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compression) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(compression)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(id_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).master) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(master)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_cert) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(peer_cert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verify_result) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(verify_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ticket) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ticket_len) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ticket_lifetime) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket_lifetime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trunc_hmac) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(trunc_hmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypt_then_mac) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(encrypt_then_mac)
        )
    );
}
impl Default for ssl_session {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_config {
    pub max_major_ver: ::types::raw_types::c_uchar,
    pub max_minor_ver: ::types::raw_types::c_uchar,
    pub min_major_ver: ::types::raw_types::c_uchar,
    pub min_minor_ver: ::types::raw_types::c_uchar,
    pub endpoint: u8,
    pub transport: u8,
    pub authmode: u8,
    pub allow_legacy_renegotiation: u8,
    pub arc4_disabled: u8,
    pub mfl_code: u8,
    pub encrypt_then_mac: u8,
    pub extended_ms: u8,
    pub anti_replay: u8,
    pub disable_renegotiation: u8,
    pub trunc_hmac: u8,
    pub session_tickets: u8,
    pub fallback: u8,
    pub cert_req_ca_list: u8,
    pub read_timeout: u32,
    pub hs_timeout_min: u32,
    pub hs_timeout_max: u32,
    pub renego_max_records: ::types::raw_types::c_int,
    pub renego_period: [::types::raw_types::c_uchar; 8usize],
    pub badmac_limit: ::types::raw_types::c_uint,
    pub dhm_min_bitlen: ::types::raw_types::c_uint,
    pub ciphersuite_list: [*const ::types::raw_types::c_int; 4usize],
    pub f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: ::types::raw_types::c_int,
            arg3: *const ::types::raw_types::c_char,
            arg4: ::types::raw_types::c_int,
            arg5: *const ::types::raw_types::c_char,
        ),
    >,
    pub p_dbg: *mut ::types::raw_types::c_void,
    pub f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut ::types::raw_types::c_uchar,
            arg3: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_rng: *mut ::types::raw_types::c_void,
    pub f_get_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut ssl_session,
        ) -> ::types::raw_types::c_int,
    >,
    pub f_set_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *const ssl_session,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_cache: *mut ::types::raw_types::c_void,
    pub f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut ssl_context,
            arg3: *const ::types::raw_types::c_uchar,
            arg4: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_sni: *mut ::types::raw_types::c_void,
    pub f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut x509_crt,
            arg3: ::types::raw_types::c_int,
            arg4: *mut u32,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_vrfy: *mut ::types::raw_types::c_void,
    pub f_psk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut ssl_context,
            arg3: *const ::types::raw_types::c_uchar,
            arg4: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_psk: *mut ::types::raw_types::c_void,
    pub f_cookie_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut *mut ::types::raw_types::c_uchar,
            arg3: *mut ::types::raw_types::c_uchar,
            arg4: *const ::types::raw_types::c_uchar,
            arg5: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub f_cookie_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *const ::types::raw_types::c_uchar,
            arg3: usize,
            arg4: *const ::types::raw_types::c_uchar,
            arg5: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_cookie: *mut ::types::raw_types::c_void,
    pub f_ticket_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *const ssl_session,
            arg3: *mut ::types::raw_types::c_uchar,
            arg4: *const ::types::raw_types::c_uchar,
            arg5: *mut usize,
            arg6: *mut u32,
        ) -> ::types::raw_types::c_int,
    >,
    pub f_ticket_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut ssl_session,
            arg3: *mut ::types::raw_types::c_uchar,
            arg4: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_ticket: *mut ::types::raw_types::c_void,
    pub f_export_keys: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *const ::types::raw_types::c_uchar,
            arg3: *const ::types::raw_types::c_uchar,
            arg4: usize,
            arg5: usize,
            arg6: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub f_export_keys_ext: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *const ::types::raw_types::c_uchar,
            arg3: *const ::types::raw_types::c_uchar,
            arg4: usize,
            arg5: usize,
            arg6: usize,
            arg7: *const ::types::raw_types::c_uchar,
            arg8: *const ::types::raw_types::c_uchar,
            arg9: tls_prf_types,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_export_keys: *mut ::types::raw_types::c_void,
    pub cert_profile: *const x509_crt_profile,
    pub key_cert: *mut ssl_key_cert,
    pub ca_chain: *mut x509_crt,
    pub ca_crl: *mut x509_crl,
    pub f_ca_cb: x509_crt_ca_cb_t,
    pub p_ca_cb: *mut ::types::raw_types::c_void,
    pub sig_hashes: *const ::types::raw_types::c_int,
    pub curve_list: *const ecp_group_id,
    pub dhm_P: mpi,
    pub dhm_G: mpi,
    pub psk: *mut ::types::raw_types::c_uchar,
    pub psk_len: usize,
    pub psk_identity: *mut ::types::raw_types::c_uchar,
    pub psk_identity_len: usize,
    pub alpn_list: *mut *const ::types::raw_types::c_char,
}
#[test]
fn bindgen_test_layout_ssl_config() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_config> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_config>(),
        416usize,
        concat!("Size of: ", stringify!(ssl_config))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_config>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_major_ver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_minor_ver) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_major_ver) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(min_major_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_minor_ver) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(min_minor_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).authmode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(authmode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allow_legacy_renegotiation) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(allow_legacy_renegotiation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arc4_disabled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(arc4_disabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mfl_code) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(mfl_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypt_then_mac) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(encrypt_then_mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_ms) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(extended_ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anti_replay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(anti_replay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disable_renegotiation) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(disable_renegotiation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trunc_hmac) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(trunc_hmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session_tickets) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(session_tickets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fallback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(fallback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert_req_ca_list) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(cert_req_ca_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_timeout) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(read_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hs_timeout_min) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(hs_timeout_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hs_timeout_max) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(hs_timeout_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).renego_max_records) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(renego_max_records)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).renego_period) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(renego_period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).badmac_limit) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(badmac_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhm_min_bitlen) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_min_bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ciphersuite_list) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ciphersuite_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_dbg) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_dbg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_dbg) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_dbg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_rng) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_rng)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_rng) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_rng)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_get_cache) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_get_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_set_cache) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_set_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_cache) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_sni) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_sni)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_sni) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_sni)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_vrfy) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_vrfy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_vrfy) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_vrfy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_psk) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_psk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_psk) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_psk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_cookie_write) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_cookie_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_cookie_check) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_cookie_check)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_cookie) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_ticket_write) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_ticket_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_ticket_parse) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_ticket_parse)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_ticket) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_ticket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_export_keys) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_export_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_export_keys_ext) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_export_keys_ext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_export_keys) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_export_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert_profile) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(cert_profile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_cert) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(key_cert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ca_chain) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ca_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ca_crl) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ca_crl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_ca_cb) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_ca_cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_ca_cb) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_ca_cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_hashes) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(sig_hashes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve_list) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(curve_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhm_P) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_P)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhm_G) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_G)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psk) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psk_len) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psk_identity) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_identity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psk_identity_len) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_identity_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpn_list) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(alpn_list)
        )
    );
}
impl Default for ssl_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_context {
    pub conf: *const ssl_config,
    pub state: ::types::raw_types::c_int,
    pub renego_status: ::types::raw_types::c_int,
    pub renego_records_seen: ::types::raw_types::c_int,
    pub major_ver: ::types::raw_types::c_int,
    pub minor_ver: ::types::raw_types::c_int,
    pub badmac_seen: ::types::raw_types::c_uint,
    pub f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut x509_crt,
            arg3: ::types::raw_types::c_int,
            arg4: *mut u32,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_vrfy: *mut ::types::raw_types::c_void,
    pub f_send: ssl_send_t,
    pub f_recv: ssl_recv_t,
    pub f_recv_timeout: ssl_recv_timeout_t,
    pub p_bio: *mut ::types::raw_types::c_void,
    pub session_in: *mut ssl_session,
    pub session_out: *mut ssl_session,
    pub session: *mut ssl_session,
    pub session_negotiate: *mut ssl_session,
    pub handshake: *mut ssl_handshake_params,
    pub transform_in: *mut ssl_transform,
    pub transform_out: *mut ssl_transform,
    pub transform: *mut ssl_transform,
    pub transform_negotiate: *mut ssl_transform,
    pub p_timer: *mut ::types::raw_types::c_void,
    pub f_set_timer: ssl_set_timer_t,
    pub f_get_timer: ssl_get_timer_t,
    pub in_buf: *mut ::types::raw_types::c_uchar,
    pub in_ctr: *mut ::types::raw_types::c_uchar,
    pub in_hdr: *mut ::types::raw_types::c_uchar,
    pub in_len: *mut ::types::raw_types::c_uchar,
    pub in_iv: *mut ::types::raw_types::c_uchar,
    pub in_msg: *mut ::types::raw_types::c_uchar,
    pub in_offt: *mut ::types::raw_types::c_uchar,
    pub in_msgtype: ::types::raw_types::c_int,
    pub in_msglen: usize,
    pub in_left: usize,
    pub in_epoch: u16,
    pub next_record_offset: usize,
    pub in_window_top: u64,
    pub in_window: u64,
    pub in_hslen: usize,
    pub nb_zero: ::types::raw_types::c_int,
    pub keep_current_message: ::types::raw_types::c_int,
    pub disable_datagram_packing: u8,
    pub out_buf: *mut ::types::raw_types::c_uchar,
    pub out_ctr: *mut ::types::raw_types::c_uchar,
    pub out_hdr: *mut ::types::raw_types::c_uchar,
    pub out_len: *mut ::types::raw_types::c_uchar,
    pub out_iv: *mut ::types::raw_types::c_uchar,
    pub out_msg: *mut ::types::raw_types::c_uchar,
    pub out_msgtype: ::types::raw_types::c_int,
    pub out_msglen: usize,
    pub out_left: usize,
    pub cur_out_ctr: [::types::raw_types::c_uchar; 8usize],
    pub mtu: u16,
    pub client_auth: ::types::raw_types::c_int,
    pub hostname: *mut ::types::raw_types::c_char,
    pub alpn_chosen: *const ::types::raw_types::c_char,
    pub cli_id: *mut ::types::raw_types::c_uchar,
    pub cli_id_len: usize,
    pub secure_renegotiation: ::types::raw_types::c_int,
    pub verify_data_len: usize,
    pub own_verify_data: [::types::raw_types::c_char; 12usize],
    pub peer_verify_data: [::types::raw_types::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_ssl_context() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_context>(),
        472usize,
        concat!("Size of: ", stringify!(ssl_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).renego_status) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(renego_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).renego_records_seen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(renego_records_seen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major_ver) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(major_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor_ver) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(minor_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).badmac_seen) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(badmac_seen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_vrfy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_vrfy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_vrfy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(p_vrfy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_send) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_send)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_recv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_recv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_recv_timeout) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_recv_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_bio) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(p_bio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session_in) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_in)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session_out) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session_negotiate) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_negotiate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handshake) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transform_in) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_in)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transform_out) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transform) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transform_negotiate) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_negotiate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_timer) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(p_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_set_timer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_set_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_get_timer) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_get_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_ctr) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_ctr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_hdr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_len) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_iv) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_msg) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_offt) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_offt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_msgtype) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msgtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_msglen) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msglen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_left) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_epoch) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_epoch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_record_offset) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(next_record_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_window_top) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_window_top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_window) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_hslen) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_hslen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nb_zero) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(nb_zero)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keep_current_message) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(keep_current_message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disable_datagram_packing) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(disable_datagram_packing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_buf) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_ctr) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_ctr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_hdr) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_len) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_iv) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_msg) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_msgtype) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msgtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_msglen) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msglen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_left) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur_out_ctr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cur_out_ctr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mtu) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client_auth) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(client_auth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpn_chosen) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(alpn_chosen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cli_id) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cli_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cli_id_len) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cli_id_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secure_renegotiation) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(secure_renegotiation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verify_data_len) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(verify_data_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).own_verify_data) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(own_verify_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_verify_data) as usize - ptr as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(peer_verify_data)
        )
    );
}
impl Default for ssl_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite_name"]
    pub fn ssl_get_ciphersuite_name(
        ciphersuite_id: ::types::raw_types::c_int,
    ) -> *const ::types::raw_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite_id"]
    pub fn ssl_get_ciphersuite_id(
        ciphersuite_name: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_init"]
    pub fn ssl_init(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_setup"]
    pub fn ssl_setup(ssl: *mut ssl_context, conf: *const ssl_config) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_session_reset"]
    pub fn ssl_session_reset(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_endpoint"]
    pub fn ssl_conf_endpoint(conf: *mut ssl_config, endpoint: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_transport"]
    pub fn ssl_conf_transport(conf: *mut ssl_config, transport: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_authmode"]
    pub fn ssl_conf_authmode(conf: *mut ssl_config, authmode: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_verify"]
    pub fn ssl_conf_verify(
        conf: *mut ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: ::types::raw_types::c_int,
                arg4: *mut u32,
            ) -> ::types::raw_types::c_int,
        >,
        p_vrfy: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_rng"]
    pub fn ssl_conf_rng(
        conf: *mut ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_dbg"]
    pub fn ssl_conf_dbg(
        conf: *mut ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: ::types::raw_types::c_int,
                arg3: *const ::types::raw_types::c_char,
                arg4: ::types::raw_types::c_int,
                arg5: *const ::types::raw_types::c_char,
            ),
        >,
        p_dbg: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_bio"]
    pub fn ssl_set_bio(
        ssl: *mut ssl_context,
        p_bio: *mut ::types::raw_types::c_void,
        f_send: ssl_send_t,
        f_recv: ssl_recv_t,
        f_recv_timeout: ssl_recv_timeout_t,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_mtu"]
    pub fn ssl_set_mtu(ssl: *mut ssl_context, mtu: u16);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_verify"]
    pub fn ssl_set_verify(
        ssl: *mut ssl_context,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: ::types::raw_types::c_int,
                arg4: *mut u32,
            ) -> ::types::raw_types::c_int,
        >,
        p_vrfy: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_read_timeout"]
    pub fn ssl_conf_read_timeout(conf: *mut ssl_config, timeout: u32);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_check_record"]
    pub fn ssl_check_record(
        ssl: *const ssl_context,
        buf: *mut ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_timer_cb"]
    pub fn ssl_set_timer_cb(
        ssl: *mut ssl_context,
        p_timer: *mut ::types::raw_types::c_void,
        f_set_timer: ssl_set_timer_t,
        f_get_timer: ssl_get_timer_t,
    );
}
pub type ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut ::types::raw_types::c_void,
        session: *const ssl_session,
        start: *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> ::types::raw_types::c_int,
>;
pub type ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut ::types::raw_types::c_void,
        ms: *const ::types::raw_types::c_uchar,
        kb: *const ::types::raw_types::c_uchar,
        maclen: usize,
        keylen: usize,
        ivlen: usize,
    ) -> ::types::raw_types::c_int,
>;
pub type ssl_export_keys_ext_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut ::types::raw_types::c_void,
        ms: *const ::types::raw_types::c_uchar,
        kb: *const ::types::raw_types::c_uchar,
        maclen: usize,
        keylen: usize,
        ivlen: usize,
        client_random: *const ::types::raw_types::c_uchar,
        server_random: *const ::types::raw_types::c_uchar,
        tls_prf_type: tls_prf_types,
    ) -> ::types::raw_types::c_int,
>;
pub type ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut ::types::raw_types::c_void,
        session: *mut ssl_session,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int,
>;
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_session_tickets_cb"]
    pub fn ssl_conf_session_tickets_cb(
        conf: *mut ssl_config,
        f_ticket_write: ssl_ticket_write_t,
        f_ticket_parse: ssl_ticket_parse_t,
        p_ticket: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_export_keys_cb"]
    pub fn ssl_conf_export_keys_cb(
        conf: *mut ssl_config,
        f_export_keys: ssl_export_keys_t,
        p_export_keys: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_export_keys_ext_cb"]
    pub fn ssl_conf_export_keys_ext_cb(
        conf: *mut ssl_config,
        f_export_keys_ext: ssl_export_keys_ext_t,
        p_export_keys: *mut ::types::raw_types::c_void,
    );
}
pub type ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::types::raw_types::c_void,
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *mut ::types::raw_types::c_uchar,
        info: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int,
>;
pub type ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::types::raw_types::c_void,
        cookie: *const ::types::raw_types::c_uchar,
        clen: usize,
        info: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int,
>;
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_dtls_cookies"]
    pub fn ssl_conf_dtls_cookies(
        conf: *mut ssl_config,
        f_cookie_write: ssl_cookie_write_t,
        f_cookie_check: ssl_cookie_check_t,
        p_cookie: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_client_transport_id"]
    pub fn ssl_set_client_transport_id(
        ssl: *mut ssl_context,
        info: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_dtls_anti_replay"]
    pub fn ssl_conf_dtls_anti_replay(conf: *mut ssl_config, mode: ::types::raw_types::c_char);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_dtls_badmac_limit"]
    pub fn ssl_conf_dtls_badmac_limit(conf: *mut ssl_config, limit: ::types::raw_types::c_uint);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_datagram_packing"]
    pub fn ssl_set_datagram_packing(
        ssl: *mut ssl_context,
        allow_packing: ::types::raw_types::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_handshake_timeout"]
    pub fn ssl_conf_handshake_timeout(conf: *mut ssl_config, min: u32, max: u32);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_session_cache"]
    pub fn ssl_conf_session_cache(
        conf: *mut ssl_config,
        p_cache: *mut ::types::raw_types::c_void,
        f_get_cache: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ssl_session,
            ) -> ::types::raw_types::c_int,
        >,
        f_set_cache: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *const ssl_session,
            ) -> ::types::raw_types::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_session"]
    pub fn ssl_set_session(
        ssl: *mut ssl_context,
        session: *const ssl_session,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_session_load"]
    pub fn ssl_session_load(
        session: *mut ssl_session,
        buf: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_session_save"]
    pub fn ssl_session_save(
        session: *const ssl_session,
        buf: *mut ::types::raw_types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_session_pointer"]
    pub fn ssl_get_session_pointer(ssl: *const ssl_context) -> *const ssl_session;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_ciphersuites"]
    pub fn ssl_conf_ciphersuites(
        conf: *mut ssl_config,
        ciphersuites: *const ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_ciphersuites_for_version"]
    pub fn ssl_conf_ciphersuites_for_version(
        conf: *mut ssl_config,
        ciphersuites: *const ::types::raw_types::c_int,
        major: ::types::raw_types::c_int,
        minor: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_cert_profile"]
    pub fn ssl_conf_cert_profile(conf: *mut ssl_config, profile: *const x509_crt_profile);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_ca_chain"]
    pub fn ssl_conf_ca_chain(conf: *mut ssl_config, ca_chain: *mut x509_crt, ca_crl: *mut x509_crl);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_ca_cb"]
    pub fn ssl_conf_ca_cb(
        conf: *mut ssl_config,
        f_ca_cb: x509_crt_ca_cb_t,
        p_ca_cb: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_own_cert"]
    pub fn ssl_conf_own_cert(
        conf: *mut ssl_config,
        own_cert: *mut x509_crt,
        pk_key: *mut pk_context,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_psk"]
    pub fn ssl_conf_psk(
        conf: *mut ssl_config,
        psk: *const ::types::raw_types::c_uchar,
        psk_len: usize,
        psk_identity: *const ::types::raw_types::c_uchar,
        psk_identity_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_hs_psk"]
    pub fn ssl_set_hs_psk(
        ssl: *mut ssl_context,
        psk: *const ::types::raw_types::c_uchar,
        psk_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_psk_cb"]
    pub fn ssl_conf_psk_cb(
        conf: *mut ssl_config,
        f_psk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ssl_context,
                arg3: *const ::types::raw_types::c_uchar,
                arg4: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_psk: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_dh_param"]
    pub fn ssl_conf_dh_param(
        conf: *mut ssl_config,
        dhm_P: *const ::types::raw_types::c_char,
        dhm_G: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_dh_param_bin"]
    pub fn ssl_conf_dh_param_bin(
        conf: *mut ssl_config,
        dhm_P: *const ::types::raw_types::c_uchar,
        P_len: usize,
        dhm_G: *const ::types::raw_types::c_uchar,
        G_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_dh_param_ctx"]
    pub fn ssl_conf_dh_param_ctx(
        conf: *mut ssl_config,
        dhm_ctx: *mut dhm_context,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_dhm_min_bitlen"]
    pub fn ssl_conf_dhm_min_bitlen(conf: *mut ssl_config, bitlen: ::types::raw_types::c_uint);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_curves"]
    pub fn ssl_conf_curves(conf: *mut ssl_config, curves: *const ecp_group_id);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_sig_hashes"]
    pub fn ssl_conf_sig_hashes(conf: *mut ssl_config, hashes: *const ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_hostname"]
    pub fn ssl_set_hostname(
        ssl: *mut ssl_context,
        hostname: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_hs_own_cert"]
    pub fn ssl_set_hs_own_cert(
        ssl: *mut ssl_context,
        own_cert: *mut x509_crt,
        pk_key: *mut pk_context,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_hs_ca_chain"]
    pub fn ssl_set_hs_ca_chain(
        ssl: *mut ssl_context,
        ca_chain: *mut x509_crt,
        ca_crl: *mut x509_crl,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_hs_authmode"]
    pub fn ssl_set_hs_authmode(ssl: *mut ssl_context, authmode: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_sni"]
    pub fn ssl_conf_sni(
        conf: *mut ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ssl_context,
                arg3: *const ::types::raw_types::c_uchar,
                arg4: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_sni: *mut ::types::raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_alpn_protocols"]
    pub fn ssl_conf_alpn_protocols(
        conf: *mut ssl_config,
        protos: *mut *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_alpn_protocol"]
    pub fn ssl_get_alpn_protocol(ssl: *const ssl_context) -> *const ::types::raw_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_max_version"]
    pub fn ssl_conf_max_version(
        conf: *mut ssl_config,
        major: ::types::raw_types::c_int,
        minor: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_min_version"]
    pub fn ssl_conf_min_version(
        conf: *mut ssl_config,
        major: ::types::raw_types::c_int,
        minor: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_fallback"]
    pub fn ssl_conf_fallback(conf: *mut ssl_config, fallback: ::types::raw_types::c_char);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_encrypt_then_mac"]
    pub fn ssl_conf_encrypt_then_mac(conf: *mut ssl_config, etm: ::types::raw_types::c_char);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_extended_master_secret"]
    pub fn ssl_conf_extended_master_secret(conf: *mut ssl_config, ems: ::types::raw_types::c_char);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_arc4_support"]
    pub fn ssl_conf_arc4_support(conf: *mut ssl_config, arc4: ::types::raw_types::c_char);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_cert_req_ca_list"]
    pub fn ssl_conf_cert_req_ca_list(
        conf: *mut ssl_config,
        cert_req_ca_list: ::types::raw_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_max_frag_len"]
    pub fn ssl_conf_max_frag_len(
        conf: *mut ssl_config,
        mfl_code: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_truncated_hmac"]
    pub fn ssl_conf_truncated_hmac(conf: *mut ssl_config, truncate: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_session_tickets"]
    pub fn ssl_conf_session_tickets(conf: *mut ssl_config, use_tickets: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_renegotiation"]
    pub fn ssl_conf_renegotiation(conf: *mut ssl_config, renegotiation: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_legacy_renegotiation"]
    pub fn ssl_conf_legacy_renegotiation(
        conf: *mut ssl_config,
        allow_legacy: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_renegotiation_enforced"]
    pub fn ssl_conf_renegotiation_enforced(
        conf: *mut ssl_config,
        max_records: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_conf_renegotiation_period"]
    pub fn ssl_conf_renegotiation_period(
        conf: *mut ssl_config,
        period: *const ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_check_pending"]
    pub fn ssl_check_pending(ssl: *const ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_bytes_avail"]
    pub fn ssl_get_bytes_avail(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_verify_result"]
    pub fn ssl_get_verify_result(ssl: *const ssl_context) -> u32;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite"]
    pub fn ssl_get_ciphersuite(ssl: *const ssl_context) -> *const ::types::raw_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_version"]
    pub fn ssl_get_version(ssl: *const ssl_context) -> *const ::types::raw_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_record_expansion"]
    pub fn ssl_get_record_expansion(ssl: *const ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_output_max_frag_len"]
    pub fn ssl_get_output_max_frag_len(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_input_max_frag_len"]
    pub fn ssl_get_input_max_frag_len(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_max_frag_len"]
    pub fn ssl_get_max_frag_len(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_max_out_record_payload"]
    pub fn ssl_get_max_out_record_payload(ssl: *const ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_peer_cert"]
    pub fn ssl_get_peer_cert(ssl: *const ssl_context) -> *const x509_crt;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_session"]
    pub fn ssl_get_session(
        ssl: *const ssl_context,
        session: *mut ssl_session,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake"]
    pub fn ssl_handshake(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake_step"]
    pub fn ssl_handshake_step(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_renegotiate"]
    pub fn ssl_renegotiate(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_read"]
    pub fn ssl_read(
        ssl: *mut ssl_context,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_write"]
    pub fn ssl_write(
        ssl: *mut ssl_context,
        buf: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_send_alert_message"]
    pub fn ssl_send_alert_message(
        ssl: *mut ssl_context,
        level: ::types::raw_types::c_uchar,
        message: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_close_notify"]
    pub fn ssl_close_notify(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_free"]
    pub fn ssl_free(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_context_save"]
    pub fn ssl_context_save(
        ssl: *mut ssl_context,
        buf: *mut ::types::raw_types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_context_load"]
    pub fn ssl_context_load(
        ssl: *mut ssl_context,
        buf: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_config_init"]
    pub fn ssl_config_init(conf: *mut ssl_config);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_config_defaults"]
    pub fn ssl_config_defaults(
        conf: *mut ssl_config,
        endpoint: ::types::raw_types::c_int,
        transport: ::types::raw_types::c_int,
        preset: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_config_free"]
    pub fn ssl_config_free(conf: *mut ssl_config);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_session_init"]
    pub fn ssl_session_init(session: *mut ssl_session);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_session_free"]
    pub fn ssl_session_free(session: *mut ssl_session);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_tls_prf"]
    pub fn ssl_tls_prf(
        prf: tls_prf_types,
        secret: *const ::types::raw_types::c_uchar,
        slen: usize,
        label: *const ::types::raw_types::c_char,
        random: *const ::types::raw_types::c_uchar,
        rlen: usize,
        dstbuf: *mut ::types::raw_types::c_uchar,
        dlen: usize,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md5_context {
    pub total: [u32; 2usize],
    pub state: [u32; 4usize],
    pub buffer: [::types::raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context() {
    const UNINIT: ::core::mem::MaybeUninit<md5_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<md5_context>(),
        88usize,
        concat!("Size of: ", stringify!(md5_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md5_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md5_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for md5_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_init"]
    pub fn md5_init(ctx: *mut md5_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_free"]
    pub fn md5_free(ctx: *mut md5_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_clone"]
    pub fn md5_clone(dst: *mut md5_context, src: *const md5_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_starts_ret"]
    pub fn md5_starts_ret(ctx: *mut md5_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_update_ret"]
    pub fn md5_update_ret(
        ctx: *mut md5_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_finish_ret"]
    pub fn md5_finish_ret(
        ctx: *mut md5_context,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_internal_md5_process"]
    pub fn internal_md5_process(
        ctx: *mut md5_context,
        data: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_starts"]
    pub fn md5_starts(ctx: *mut md5_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_update"]
    pub fn md5_update(
        ctx: *mut md5_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_finish"]
    pub fn md5_finish(ctx: *mut md5_context, output: *mut ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_process"]
    pub fn md5_process(ctx: *mut md5_context, data: *const ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_ret"]
    pub fn md5_ret(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5"]
    pub fn md5(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_self_test"]
    pub fn md5_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha1_context {
    pub total: [u32; 2usize],
    pub state: [u32; 5usize],
    pub buffer: [::types::raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_sha1_context() {
    const UNINIT: ::core::mem::MaybeUninit<sha1_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sha1_context>(),
        92usize,
        concat!("Size of: ", stringify!(sha1_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha1_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha1_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for sha1_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_init"]
    pub fn sha1_init(ctx: *mut sha1_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_free"]
    pub fn sha1_free(ctx: *mut sha1_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_clone"]
    pub fn sha1_clone(dst: *mut sha1_context, src: *const sha1_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_starts_ret"]
    pub fn sha1_starts_ret(ctx: *mut sha1_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_update_ret"]
    pub fn sha1_update_ret(
        ctx: *mut sha1_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_finish_ret"]
    pub fn sha1_finish_ret(
        ctx: *mut sha1_context,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_internal_sha1_process"]
    pub fn internal_sha1_process(
        ctx: *mut sha1_context,
        data: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_starts"]
    pub fn sha1_starts(ctx: *mut sha1_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_update"]
    pub fn sha1_update(
        ctx: *mut sha1_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_finish"]
    pub fn sha1_finish(ctx: *mut sha1_context, output: *mut ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_process"]
    pub fn sha1_process(ctx: *mut sha1_context, data: *const ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_ret"]
    pub fn sha1_ret(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1"]
    pub fn sha1(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_self_test"]
    pub fn sha1_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha256_context {
    pub total: [u32; 2usize],
    pub state: [u32; 8usize],
    pub buffer: [::types::raw_types::c_uchar; 64usize],
    pub is224: ::types::raw_types::c_int,
}
#[test]
fn bindgen_test_layout_sha256_context() {
    const UNINIT: ::core::mem::MaybeUninit<sha256_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sha256_context>(),
        108usize,
        concat!("Size of: ", stringify!(sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha256_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is224) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(is224)
        )
    );
}
impl Default for sha256_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_init"]
    pub fn sha256_init(ctx: *mut sha256_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_free"]
    pub fn sha256_free(ctx: *mut sha256_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_clone"]
    pub fn sha256_clone(dst: *mut sha256_context, src: *const sha256_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_starts_ret"]
    pub fn sha256_starts_ret(
        ctx: *mut sha256_context,
        is224: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_update_ret"]
    pub fn sha256_update_ret(
        ctx: *mut sha256_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_finish_ret"]
    pub fn sha256_finish_ret(
        ctx: *mut sha256_context,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_internal_sha256_process"]
    pub fn internal_sha256_process(
        ctx: *mut sha256_context,
        data: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_starts"]
    pub fn sha256_starts(ctx: *mut sha256_context, is224: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_update"]
    pub fn sha256_update(
        ctx: *mut sha256_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_finish"]
    pub fn sha256_finish(ctx: *mut sha256_context, output: *mut ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_process"]
    pub fn sha256_process(ctx: *mut sha256_context, data: *const ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_ret"]
    pub fn sha256_ret(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        is224: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256"]
    pub fn sha256(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        is224: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_self_test"]
    pub fn sha256_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha512_context {
    pub total: [u64; 2usize],
    pub state: [u64; 8usize],
    pub buffer: [::types::raw_types::c_uchar; 128usize],
    pub is384: ::types::raw_types::c_int,
}
#[test]
fn bindgen_test_layout_sha512_context() {
    const UNINIT: ::core::mem::MaybeUninit<sha512_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sha512_context>(),
        216usize,
        concat!("Size of: ", stringify!(sha512_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha512_context>(),
        8usize,
        concat!("Alignment of ", stringify!(sha512_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is384) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(is384)
        )
    );
}
impl Default for sha512_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_init"]
    pub fn sha512_init(ctx: *mut sha512_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_free"]
    pub fn sha512_free(ctx: *mut sha512_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_clone"]
    pub fn sha512_clone(dst: *mut sha512_context, src: *const sha512_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_starts_ret"]
    pub fn sha512_starts_ret(
        ctx: *mut sha512_context,
        is384: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_update_ret"]
    pub fn sha512_update_ret(
        ctx: *mut sha512_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_finish_ret"]
    pub fn sha512_finish_ret(
        ctx: *mut sha512_context,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_internal_sha512_process"]
    pub fn internal_sha512_process(
        ctx: *mut sha512_context,
        data: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_starts"]
    pub fn sha512_starts(ctx: *mut sha512_context, is384: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_update"]
    pub fn sha512_update(
        ctx: *mut sha512_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_finish"]
    pub fn sha512_finish(ctx: *mut sha512_context, output: *mut ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_process"]
    pub fn sha512_process(ctx: *mut sha512_context, data: *const ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_ret"]
    pub fn sha512_ret(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        is384: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512"]
    pub fn sha512(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
        is384: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_self_test"]
    pub fn sha512_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
pub const ECJPAKE_CLIENT: ecjpake_role = 0;
pub const ECJPAKE_SERVER: ecjpake_role = 1;
pub type ecjpake_role = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecjpake_context {
    pub md_info: *const md_info_t,
    pub grp: ecp_group,
    pub role: ecjpake_role,
    pub point_format: ::types::raw_types::c_int,
    pub Xm1: ecp_point,
    pub Xm2: ecp_point,
    pub Xp1: ecp_point,
    pub Xp2: ecp_point,
    pub Xp: ecp_point,
    pub xm1: mpi,
    pub xm2: mpi,
    pub s: mpi,
}
#[test]
fn bindgen_test_layout_ecjpake_context() {
    const UNINIT: ::core::mem::MaybeUninit<ecjpake_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ecjpake_context>(),
        696usize,
        concat!("Size of: ", stringify!(ecjpake_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ecjpake_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ecjpake_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(md_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).point_format) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(point_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xm1) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xm1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xm2) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xm2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xp1) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xp2) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xp) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xm1) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(xm1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xm2) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(xm2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(s)
        )
    );
}
impl Default for ecjpake_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_init"]
    pub fn ecjpake_init(ctx: *mut ecjpake_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_setup"]
    pub fn ecjpake_setup(
        ctx: *mut ecjpake_context,
        role: ecjpake_role,
        hash: md_type_t,
        curve: ecp_group_id,
        secret: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_check"]
    pub fn ecjpake_check(ctx: *const ecjpake_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_write_round_one"]
    pub fn ecjpake_write_round_one(
        ctx: *mut ecjpake_context,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_read_round_one"]
    pub fn ecjpake_read_round_one(
        ctx: *mut ecjpake_context,
        buf: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_write_round_two"]
    pub fn ecjpake_write_round_two(
        ctx: *mut ecjpake_context,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_read_round_two"]
    pub fn ecjpake_read_round_two(
        ctx: *mut ecjpake_context,
        buf: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_derive_secret"]
    pub fn ecjpake_derive_secret(
        ctx: *mut ecjpake_context,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_free"]
    pub fn ecjpake_free(ctx: *mut ecjpake_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecjpake_self_test"]
    pub fn ecjpake_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct net_context {
    pub fd: ::types::raw_types::c_int,
}
#[test]
fn bindgen_test_layout_net_context() {
    const UNINIT: ::core::mem::MaybeUninit<net_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<net_context>(),
        4usize,
        concat!("Size of: ", stringify!(net_context))
    );
    assert_eq!(
        ::core::mem::align_of::<net_context>(),
        4usize,
        concat!("Alignment of ", stringify!(net_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_context),
            "::",
            stringify!(fd)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_init"]
    pub fn net_init(ctx: *mut net_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_connect"]
    pub fn net_connect(
        ctx: *mut net_context,
        host: *const ::types::raw_types::c_char,
        port: *const ::types::raw_types::c_char,
        proto: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_bind"]
    pub fn net_bind(
        ctx: *mut net_context,
        bind_ip: *const ::types::raw_types::c_char,
        port: *const ::types::raw_types::c_char,
        proto: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_accept"]
    pub fn net_accept(
        bind_ctx: *mut net_context,
        client_ctx: *mut net_context,
        client_ip: *mut ::types::raw_types::c_void,
        buf_size: usize,
        ip_len: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_poll"]
    pub fn net_poll(ctx: *mut net_context, rw: u32, timeout: u32) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_set_block"]
    pub fn net_set_block(ctx: *mut net_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_set_nonblock"]
    pub fn net_set_nonblock(ctx: *mut net_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_usleep"]
    pub fn net_usleep(usec: ::types::raw_types::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_recv"]
    pub fn net_recv(
        ctx: *mut ::types::raw_types::c_void,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_send"]
    pub fn net_send(
        ctx: *mut ::types::raw_types::c_void,
        buf: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_recv_timeout"]
    pub fn net_recv_timeout(
        ctx: *mut ::types::raw_types::c_void,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
        timeout: u32,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_close"]
    pub fn net_close(ctx: *mut net_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_net_free"]
    pub fn net_free(ctx: *mut net_context);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct havege_state {
    pub PT1: u32,
    pub PT2: u32,
    pub offset: [u32; 2usize],
    pub pool: [u32; 1024usize],
    pub WALK: [u32; 8192usize],
}
#[test]
fn bindgen_test_layout_havege_state() {
    const UNINIT: ::core::mem::MaybeUninit<havege_state> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<havege_state>(),
        36880usize,
        concat!("Size of: ", stringify!(havege_state))
    );
    assert_eq!(
        ::core::mem::align_of::<havege_state>(),
        4usize,
        concat!("Alignment of ", stringify!(havege_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PT1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(PT1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PT2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(PT2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WALK) as usize - ptr as usize },
        4112usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(WALK)
        )
    );
}
impl Default for havege_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_havege_init"]
    pub fn havege_init(hs: *mut havege_state);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_havege_free"]
    pub fn havege_free(hs: *mut havege_state);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_havege_random"]
    pub fn havege_random(
        p_rng: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct poly1305_context {
    pub r: [u32; 4usize],
    pub s: [u32; 4usize],
    pub acc: [u32; 5usize],
    pub queue: [u8; 16usize],
    pub queue_len: usize,
}
#[test]
fn bindgen_test_layout_poly1305_context() {
    const UNINIT: ::core::mem::MaybeUninit<poly1305_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<poly1305_context>(),
        80usize,
        concat!("Size of: ", stringify!(poly1305_context))
    );
    assert_eq!(
        ::core::mem::align_of::<poly1305_context>(),
        8usize,
        concat!("Alignment of ", stringify!(poly1305_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(acc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue_len) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(queue_len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_poly1305_init"]
    pub fn poly1305_init(ctx: *mut poly1305_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_poly1305_free"]
    pub fn poly1305_free(ctx: *mut poly1305_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_poly1305_starts"]
    pub fn poly1305_starts(
        ctx: *mut poly1305_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_poly1305_update"]
    pub fn poly1305_update(
        ctx: *mut poly1305_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_poly1305_finish"]
    pub fn poly1305_finish(
        ctx: *mut poly1305_context,
        mac: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_poly1305_mac"]
    pub fn poly1305_mac(
        key: *const ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        mac: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_poly1305_self_test"]
    pub fn poly1305_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct chacha20_context {
    pub state: [u32; 16usize],
    pub keystream8: [u8; 64usize],
    pub keystream_bytes_used: usize,
}
#[test]
fn bindgen_test_layout_chacha20_context() {
    const UNINIT: ::core::mem::MaybeUninit<chacha20_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<chacha20_context>(),
        136usize,
        concat!("Size of: ", stringify!(chacha20_context))
    );
    assert_eq!(
        ::core::mem::align_of::<chacha20_context>(),
        8usize,
        concat!("Alignment of ", stringify!(chacha20_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keystream8) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(keystream8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keystream_bytes_used) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(keystream_bytes_used)
        )
    );
}
impl Default for chacha20_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chacha20_init"]
    pub fn chacha20_init(ctx: *mut chacha20_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chacha20_free"]
    pub fn chacha20_free(ctx: *mut chacha20_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chacha20_setkey"]
    pub fn chacha20_setkey(
        ctx: *mut chacha20_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chacha20_starts"]
    pub fn chacha20_starts(
        ctx: *mut chacha20_context,
        nonce: *const ::types::raw_types::c_uchar,
        counter: u32,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chacha20_update"]
    pub fn chacha20_update(
        ctx: *mut chacha20_context,
        size: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chacha20_crypt"]
    pub fn chacha20_crypt(
        key: *const ::types::raw_types::c_uchar,
        nonce: *const ::types::raw_types::c_uchar,
        counter: u32,
        size: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chacha20_self_test"]
    pub fn chacha20_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xtea_context {
    pub k: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_xtea_context() {
    const UNINIT: ::core::mem::MaybeUninit<xtea_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<xtea_context>(),
        16usize,
        concat!("Size of: ", stringify!(xtea_context))
    );
    assert_eq!(
        ::core::mem::align_of::<xtea_context>(),
        4usize,
        concat!("Alignment of ", stringify!(xtea_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtea_context),
            "::",
            stringify!(k)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_xtea_init"]
    pub fn xtea_init(ctx: *mut xtea_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_xtea_free"]
    pub fn xtea_free(ctx: *mut xtea_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_xtea_setup"]
    pub fn xtea_setup(ctx: *mut xtea_context, key: *const ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_xtea_crypt_ecb"]
    pub fn xtea_crypt_ecb(
        ctx: *mut xtea_context,
        mode: ::types::raw_types::c_int,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_xtea_crypt_cbc"]
    pub fn xtea_crypt_cbc(
        ctx: *mut xtea_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_xtea_self_test"]
    pub fn xtea_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_csr {
    pub raw: x509_buf,
    pub cri: x509_buf,
    pub version: ::types::raw_types::c_int,
    pub subject_raw: x509_buf,
    pub subject: x509_name,
    pub pk: pk_context,
    pub sig_oid: x509_buf,
    pub sig: x509_buf,
    pub sig_md: md_type_t,
    pub sig_pk: pk_type_t,
    pub sig_opts: *mut ::types::raw_types::c_void,
}
#[test]
fn bindgen_test_layout_x509_csr() {
    const UNINIT: ::core::mem::MaybeUninit<x509_csr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509_csr>(),
        224usize,
        concat!("Size of: ", stringify!(x509_csr))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_csr>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_csr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cri) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(cri)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject_raw) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(subject_raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pk) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(pk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_oid) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_md) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_pk) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig_opts) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_opts)
        )
    );
}
impl Default for x509_csr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509write_csr {
    pub key: *mut pk_context,
    pub subject: *mut asn1_named_data,
    pub md_alg: md_type_t,
    pub extensions: *mut asn1_named_data,
}
#[test]
fn bindgen_test_layout_x509write_csr() {
    const UNINIT: ::core::mem::MaybeUninit<x509write_csr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<x509write_csr>(),
        32usize,
        concat!("Size of: ", stringify!(x509write_csr))
    );
    assert_eq!(
        ::core::mem::align_of::<x509write_csr>(),
        8usize,
        concat!("Alignment of ", stringify!(x509write_csr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_alg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(md_alg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(extensions)
        )
    );
}
impl Default for x509write_csr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_csr_parse_der"]
    pub fn x509_csr_parse_der(
        csr: *mut x509_csr,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_csr_parse"]
    pub fn x509_csr_parse(
        csr: *mut x509_csr,
        buf: *const ::types::raw_types::c_uchar,
        buflen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_csr_parse_file"]
    pub fn x509_csr_parse_file(
        csr: *mut x509_csr,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_csr_info"]
    pub fn x509_csr_info(
        buf: *mut ::types::raw_types::c_char,
        size: usize,
        prefix: *const ::types::raw_types::c_char,
        csr: *const x509_csr,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_csr_init"]
    pub fn x509_csr_init(csr: *mut x509_csr);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_csr_free"]
    pub fn x509_csr_free(csr: *mut x509_csr);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_init"]
    pub fn x509write_csr_init(ctx: *mut x509write_csr);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_set_subject_name"]
    pub fn x509write_csr_set_subject_name(
        ctx: *mut x509write_csr,
        subject_name: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_set_key"]
    pub fn x509write_csr_set_key(ctx: *mut x509write_csr, key: *mut pk_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_set_md_alg"]
    pub fn x509write_csr_set_md_alg(ctx: *mut x509write_csr, md_alg: md_type_t);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_set_key_usage"]
    pub fn x509write_csr_set_key_usage(
        ctx: *mut x509write_csr,
        key_usage: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_set_ns_cert_type"]
    pub fn x509write_csr_set_ns_cert_type(
        ctx: *mut x509write_csr,
        ns_cert_type: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_set_extension"]
    pub fn x509write_csr_set_extension(
        ctx: *mut x509write_csr,
        oid: *const ::types::raw_types::c_char,
        oid_len: usize,
        val: *const ::types::raw_types::c_uchar,
        val_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_free"]
    pub fn x509write_csr_free(ctx: *mut x509write_csr);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_der"]
    pub fn x509write_csr_der(
        ctx: *mut x509write_csr,
        buf: *mut ::types::raw_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509write_csr_pem"]
    pub fn x509write_csr_pem(
        ctx: *mut x509write_csr,
        buf: *mut ::types::raw_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_version_get_number"]
    pub fn version_get_number() -> ::types::raw_types::c_uint;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_version_get_string"]
    pub fn version_get_string(string: *mut ::types::raw_types::c_char);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_version_get_string_full"]
    pub fn version_get_string_full(string: *mut ::types::raw_types::c_char);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_version_check_feature"]
    pub fn version_check_feature(
        feature: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timing_hr_time {
    pub opaque: [::types::raw_types::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_timing_hr_time() {
    const UNINIT: ::core::mem::MaybeUninit<timing_hr_time> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timing_hr_time>(),
        32usize,
        concat!("Size of: ", stringify!(timing_hr_time))
    );
    assert_eq!(
        ::core::mem::align_of::<timing_hr_time>(),
        1usize,
        concat!("Alignment of ", stringify!(timing_hr_time))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_hr_time),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timing_delay_context {
    pub timer: timing_hr_time,
    pub int_ms: u32,
    pub fin_ms: u32,
}
#[test]
fn bindgen_test_layout_timing_delay_context() {
    const UNINIT: ::core::mem::MaybeUninit<timing_delay_context> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timing_delay_context>(),
        40usize,
        concat!("Size of: ", stringify!(timing_delay_context))
    );
    assert_eq!(
        ::core::mem::align_of::<timing_delay_context>(),
        4usize,
        concat!("Alignment of ", stringify!(timing_delay_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_delay_context),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_ms) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_delay_context),
            "::",
            stringify!(int_ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fin_ms) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_delay_context),
            "::",
            stringify!(fin_ms)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_timing_alarmed"]
    pub static mut timing_alarmed: ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_timing_hardclock"]
    pub fn timing_hardclock() -> ::types::raw_types::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_timing_get_timer"]
    pub fn timing_get_timer(
        val: *mut timing_hr_time,
        reset: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_set_alarm"]
    pub fn set_alarm(seconds: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_timing_set_delay"]
    pub fn timing_set_delay(data: *mut ::types::raw_types::c_void, int_ms: u32, fin_ms: u32);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_timing_get_delay"]
    pub fn timing_get_delay(data: *mut ::types::raw_types::c_void) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_timing_self_test"]
    pub fn timing_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_ticket_key {
    pub name: [::types::raw_types::c_uchar; 4usize],
    pub generation_time: u32,
    pub ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_ssl_ticket_key() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_ticket_key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_ticket_key>(),
        104usize,
        concat!("Size of: ", stringify!(ssl_ticket_key))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ticket_key>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_ticket_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generation_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(generation_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for ssl_ticket_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_ticket_context {
    pub keys: [ssl_ticket_key; 2usize],
    pub active: ::types::raw_types::c_uchar,
    pub ticket_lifetime: u32,
    pub f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::types::raw_types::c_void,
            arg2: *mut ::types::raw_types::c_uchar,
            arg3: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub p_rng: *mut ::types::raw_types::c_void,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_ssl_ticket_context() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_ticket_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_ticket_context>(),
        280usize,
        concat!("Size of: ", stringify!(ssl_ticket_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ticket_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_ticket_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).active) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ticket_lifetime) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(ticket_lifetime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_rng) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(f_rng)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_rng) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(p_rng)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(mutex)
        )
    );
}
impl Default for ssl_ticket_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ticket_init"]
    pub fn ssl_ticket_init(ctx: *mut ssl_ticket_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ticket_setup"]
    pub fn ssl_ticket_setup(
        ctx: *mut ssl_ticket_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
        cipher: cipher_type_t,
        lifetime: u32,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ticket_write"]
    pub fn ssl_ticket_write(
        p_ticket: *mut ::types::raw_types::c_void,
        session: *const ssl_session,
        start: *mut ::types::raw_types::c_uchar,
        end: *const ::types::raw_types::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ticket_parse"]
    pub fn ssl_ticket_parse(
        p_ticket: *mut ::types::raw_types::c_void,
        session: *mut ssl_session,
        buf: *mut ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ticket_free"]
    pub fn ssl_ticket_free(ctx: *mut ssl_ticket_context);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_sig_hash_set_t {
    pub rsa: md_type_t,
    pub ecdsa: md_type_t,
}
#[test]
fn bindgen_test_layout_ssl_sig_hash_set_t() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_sig_hash_set_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_sig_hash_set_t>(),
        8usize,
        concat!("Size of: ", stringify!(ssl_sig_hash_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_sig_hash_set_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_sig_hash_set_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_sig_hash_set_t),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecdsa) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_sig_hash_set_t),
            "::",
            stringify!(ecdsa)
        )
    );
}
impl Default for ssl_sig_hash_set_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ssl_tls_prf_cb = ::core::option::Option<
    unsafe extern "C" fn(
        secret: *const ::types::raw_types::c_uchar,
        slen: usize,
        label: *const ::types::raw_types::c_char,
        random: *const ::types::raw_types::c_uchar,
        rlen: usize,
        dstbuf: *mut ::types::raw_types::c_uchar,
        dlen: usize,
    ) -> ::types::raw_types::c_int,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ssl_key_set {
    pub client_write_key: [::types::raw_types::c_uchar; 32usize],
    pub server_write_key: [::types::raw_types::c_uchar; 32usize],
    pub client_write_iv: [::types::raw_types::c_uchar; 16usize],
    pub server_write_iv: [::types::raw_types::c_uchar; 16usize],
    pub key_len: usize,
    pub iv_len: usize,
}
#[test]
fn bindgen_test_layout_ssl_key_set() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_key_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_key_set>(),
        112usize,
        concat!("Size of: ", stringify!(ssl_key_set))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_key_set>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_key_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client_write_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_set),
            "::",
            stringify!(client_write_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server_write_key) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_set),
            "::",
            stringify!(server_write_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client_write_iv) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_set),
            "::",
            stringify!(client_write_iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server_write_iv) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_set),
            "::",
            stringify!(server_write_iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_len) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_set),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_len) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_set),
            "::",
            stringify!(iv_len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params {
    pub max_major_ver: u8,
    pub max_minor_ver: u8,
    pub resume: u8,
    pub cli_exts: u8,
    pub sni_authmode: u8,
    pub new_session_ticket: u8,
    pub extended_ms: u8,
    pub retransmit_state: ::types::raw_types::c_uchar,
    pub hash_algs: ssl_sig_hash_set_t,
    pub pmslen: usize,
    pub ciphersuite_info: *const ssl_ciphersuite_t,
    pub update_checksum: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ssl_context,
            arg2: *const ::types::raw_types::c_uchar,
            arg3: usize,
        ),
    >,
    pub calc_verify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ssl_context,
            arg2: *mut ::types::raw_types::c_uchar,
            arg3: *mut usize,
        ),
    >,
    pub calc_finished: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ssl_context,
            arg2: *mut ::types::raw_types::c_uchar,
            arg3: ::types::raw_types::c_int,
        ),
    >,
    pub tls_prf: ssl_tls_prf_cb,
    pub dhm_ctx: dhm_context,
    pub ecdh_ctx: ecdh_context,
    pub curves: *mut *const ecp_curve_info,
    pub psk: *mut ::types::raw_types::c_uchar,
    pub psk_len: usize,
    pub key_cert: *mut ssl_key_cert,
    pub sni_key_cert: *mut ssl_key_cert,
    pub sni_ca_chain: *mut x509_crt,
    pub sni_ca_crl: *mut x509_crl,
    pub buffering: ssl_handshake_params__bindgen_ty_1,
    pub out_msg_seq: ::types::raw_types::c_uint,
    pub in_msg_seq: ::types::raw_types::c_uint,
    pub verify_cookie: *mut ::types::raw_types::c_uchar,
    pub verify_cookie_len: ::types::raw_types::c_uchar,
    pub retransmit_timeout: u32,
    pub flight: *mut ssl_flight_item,
    pub cur_msg: *mut ssl_flight_item,
    pub cur_msg_p: *mut ::types::raw_types::c_uchar,
    pub in_flight_start_seq: ::types::raw_types::c_uint,
    pub alt_transform_out: *mut ssl_transform,
    pub alt_out_ctr: [::types::raw_types::c_uchar; 8usize],
    pub mtu: u16,
    pub fin_sha256: sha256_context,
    pub fin_sha512: sha512_context,
    pub randbytes: [::types::raw_types::c_uchar; 64usize],
    pub premaster: [::types::raw_types::c_uchar; 1060usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1 {
    pub total_bytes_buffered: usize,
    pub seen_ccs: u8,
    pub hs: [ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer; 4usize],
    pub future_record: ssl_handshake_params__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: *mut ::types::raw_types::c_uchar,
    pub data_len: usize,
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer() {
    const UNINIT: ::core::mem::MaybeUninit<
        ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer),
            "::",
            stringify!(data_len)
        )
    );
}
impl Default for ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer {
    #[inline]
    pub fn is_valid(&self) -> ::types::raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_valid(&mut self, val: ::types::raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_fragmented(&self) -> ::types::raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_fragmented(&mut self, val: ::types::raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_complete(&self) -> ::types::raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_complete(&mut self, val: ::types::raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_valid: ::types::raw_types::c_uint,
        is_fragmented: ::types::raw_types::c_uint,
        is_complete: ::types::raw_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_valid: u32 = unsafe { ::core::mem::transmute(is_valid) };
            is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_fragmented: u32 = unsafe { ::core::mem::transmute(is_fragmented) };
            is_fragmented as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_complete: u32 = unsafe { ::core::mem::transmute(is_complete) };
            is_complete as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 {
    pub data: *mut ::types::raw_types::c_uchar,
    pub len: usize,
    pub epoch: ::types::raw_types::c_uint,
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).epoch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(epoch)
        )
    );
}
impl Default for ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_handshake_params__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1>(),
        136usize,
        concat!("Size of: ", stringify!(ssl_handshake_params__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_bytes_buffered) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(total_bytes_buffered)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seen_ccs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(seen_ccs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(hs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).future_record) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(future_record)
        )
    );
}
impl Default for ssl_handshake_params__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_ssl_handshake_params() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_handshake_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params>(),
        2648usize,
        concat!("Size of: ", stringify!(ssl_handshake_params))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_handshake_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_major_ver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_minor_ver) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resume) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cli_exts) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cli_exts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sni_authmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_authmode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).new_session_ticket) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(new_session_ticket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_ms) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(extended_ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retransmit_state) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(retransmit_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_algs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(hash_algs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pmslen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(pmslen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ciphersuite_info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(ciphersuite_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update_checksum) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(update_checksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calc_verify) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(calc_verify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calc_finished) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(calc_finished)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tls_prf) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(tls_prf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhm_ctx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(dhm_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecdh_ctx) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(ecdh_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curves) as usize - ptr as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(curves)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psk) as usize - ptr as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(psk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psk_len) as usize - ptr as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(psk_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_cert) as usize - ptr as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(key_cert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sni_key_cert) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_key_cert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sni_ca_chain) as usize - ptr as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_ca_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sni_ca_crl) as usize - ptr as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_ca_crl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffering) as usize - ptr as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(buffering)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_msg_seq) as usize - ptr as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(out_msg_seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_msg_seq) as usize - ptr as usize },
        1124usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(in_msg_seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verify_cookie) as usize - ptr as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(verify_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verify_cookie_len) as usize - ptr as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(verify_cookie_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retransmit_timeout) as usize - ptr as usize },
        1140usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(retransmit_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flight) as usize - ptr as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(flight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur_msg) as usize - ptr as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cur_msg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur_msg_p) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cur_msg_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_flight_start_seq) as usize - ptr as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(in_flight_start_seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alt_transform_out) as usize - ptr as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(alt_transform_out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alt_out_ctr) as usize - ptr as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(alt_out_ctr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mtu) as usize - ptr as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fin_sha256) as usize - ptr as usize },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_sha256)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fin_sha512) as usize - ptr as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_sha512)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).randbytes) as usize - ptr as usize },
        1520usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(randbytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).premaster) as usize - ptr as usize },
        1584usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(premaster)
        )
    );
}
impl Default for ssl_handshake_params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ssl_hs_buffer = ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_transform {
    pub minlen: usize,
    pub ivlen: usize,
    pub fixed_ivlen: usize,
    pub maclen: usize,
    pub taglen: usize,
    pub iv_enc: [::types::raw_types::c_uchar; 16usize],
    pub iv_dec: [::types::raw_types::c_uchar; 16usize],
    pub md_ctx_enc: md_context_t,
    pub md_ctx_dec: md_context_t,
    pub encrypt_then_mac: ::types::raw_types::c_int,
    pub cipher_ctx_enc: cipher_context_t,
    pub cipher_ctx_dec: cipher_context_t,
    pub minor_ver: ::types::raw_types::c_int,
    pub randbytes: [::types::raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_ssl_transform() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_transform> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_transform>(),
        392usize,
        concat!("Size of: ", stringify!(ssl_transform))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_transform>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_transform))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minlen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(minlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ivlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(ivlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fixed_ivlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(fixed_ivlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maclen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(maclen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taglen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(taglen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_enc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(iv_enc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_dec) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(iv_dec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_ctx_enc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(md_ctx_enc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_ctx_dec) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(md_ctx_dec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypt_then_mac) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(encrypt_then_mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_ctx_enc) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(cipher_ctx_enc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_ctx_dec) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(cipher_ctx_dec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor_ver) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(minor_ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).randbytes) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(randbytes)
        )
    );
}
impl Default for ssl_transform {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct record {
    pub ctr: [u8; 8usize],
    pub type_: u8,
    pub ver: [u8; 2usize],
    pub buf: *mut ::types::raw_types::c_uchar,
    pub buf_len: usize,
    pub data_offset: usize,
    pub data_len: usize,
}
#[test]
fn bindgen_test_layout_record() {
    const UNINIT: ::core::mem::MaybeUninit<record> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<record>(),
        48usize,
        concat!("Size of: ", stringify!(record))
    );
    assert_eq!(
        ::core::mem::align_of::<record>(),
        8usize,
        concat!("Alignment of ", stringify!(record))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ver) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(data_len)
        )
    );
}
impl Default for record {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_key_cert {
    pub cert: *mut x509_crt,
    pub key: *mut pk_context,
    pub next: *mut ssl_key_cert,
}
#[test]
fn bindgen_test_layout_ssl_key_cert() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_key_cert> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_key_cert>(),
        24usize,
        concat!("Size of: ", stringify!(ssl_key_cert))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_key_cert>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_key_cert))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(next)
        )
    );
}
impl Default for ssl_key_cert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_flight_item {
    pub p: *mut ::types::raw_types::c_uchar,
    pub len: usize,
    pub type_: ::types::raw_types::c_uchar,
    pub next: *mut ssl_flight_item,
}
#[test]
fn bindgen_test_layout_ssl_flight_item() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_flight_item> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_flight_item>(),
        32usize,
        concat!("Size of: ", stringify!(ssl_flight_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_flight_item>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_flight_item))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(next)
        )
    );
}
impl Default for ssl_flight_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_hash_set_find"]
    pub fn ssl_sig_hash_set_find(set: *mut ssl_sig_hash_set_t, sig_alg: pk_type_t) -> md_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_hash_set_add"]
    pub fn ssl_sig_hash_set_add(
        set: *mut ssl_sig_hash_set_t,
        sig_alg: pk_type_t,
        md_alg: md_type_t,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_hash_set_const_hash"]
    pub fn ssl_sig_hash_set_const_hash(set: *mut ssl_sig_hash_set_t, md_alg: md_type_t);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_transform_free"]
    pub fn ssl_transform_free(transform: *mut ssl_transform);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake_free"]
    pub fn ssl_handshake_free(ssl: *mut ssl_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_handshake_client_step"]
    pub fn ssl_handshake_client_step(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_handshake_server_step"]
    pub fn ssl_handshake_server_step(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake_wrapup"]
    pub fn ssl_handshake_wrapup(ssl: *mut ssl_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_send_fatal_handshake_failure"]
    pub fn ssl_send_fatal_handshake_failure(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_reset_checksum"]
    pub fn ssl_reset_checksum(ssl: *mut ssl_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_derive_keys"]
    pub fn ssl_derive_keys(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_handle_message_type"]
    pub fn ssl_handle_message_type(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_prepare_handshake_record"]
    pub fn ssl_prepare_handshake_record(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_update_handshake_status"]
    pub fn ssl_update_handshake_status(ssl: *mut ssl_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_read_record"]
    pub fn ssl_read_record(
        ssl: *mut ssl_context,
        update_hs_digest: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_fetch_input"]
    pub fn ssl_fetch_input(ssl: *mut ssl_context, nb_want: usize) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_write_handshake_msg"]
    pub fn ssl_write_handshake_msg(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_write_record"]
    pub fn ssl_write_record(ssl: *mut ssl_context, force_flush: u8) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_flush_output"]
    pub fn ssl_flush_output(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_parse_certificate"]
    pub fn ssl_parse_certificate(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_write_certificate"]
    pub fn ssl_write_certificate(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_parse_change_cipher_spec"]
    pub fn ssl_parse_change_cipher_spec(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_write_change_cipher_spec"]
    pub fn ssl_write_change_cipher_spec(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_parse_finished"]
    pub fn ssl_parse_finished(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_write_finished"]
    pub fn ssl_write_finished(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_optimize_checksum"]
    pub fn ssl_optimize_checksum(ssl: *mut ssl_context, ciphersuite_info: *const ssl_ciphersuite_t);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_psk_derive_premaster"]
    pub fn ssl_psk_derive_premaster(
        ssl: *mut ssl_context,
        key_ex: key_exchange_type_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_from_pk"]
    pub fn ssl_sig_from_pk(pk: *mut pk_context) -> ::types::raw_types::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_from_pk_alg"]
    pub fn ssl_sig_from_pk_alg(type_: pk_type_t) -> ::types::raw_types::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_pk_alg_from_sig"]
    pub fn ssl_pk_alg_from_sig(sig: ::types::raw_types::c_uchar) -> pk_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_md_alg_from_hash"]
    pub fn ssl_md_alg_from_hash(hash: ::types::raw_types::c_uchar) -> md_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_hash_from_md_alg"]
    pub fn ssl_hash_from_md_alg(md: ::types::raw_types::c_int) -> ::types::raw_types::c_uchar;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_set_calc_verify_md"]
    pub fn ssl_set_calc_verify_md(
        ssl: *mut ssl_context,
        md: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_check_curve"]
    pub fn ssl_check_curve(
        ssl: *const ssl_context,
        grp_id: ecp_group_id,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_check_curve_tls_id"]
    pub fn ssl_check_curve_tls_id(
        ssl: *const ssl_context,
        tls_id: u16,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_check_sig_hash"]
    pub fn ssl_check_sig_hash(ssl: *const ssl_context, md: md_type_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_check_cert_usage"]
    pub fn ssl_check_cert_usage(
        cert: *const x509_crt,
        ciphersuite: *const ssl_ciphersuite_t,
        cert_endpoint: ::types::raw_types::c_int,
        flags: *mut u32,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_write_version"]
    pub fn ssl_write_version(
        major: ::types::raw_types::c_int,
        minor: ::types::raw_types::c_int,
        transport: ::types::raw_types::c_int,
        ver: *mut ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_read_version"]
    pub fn ssl_read_version(
        major: *mut ::types::raw_types::c_int,
        minor: *mut ::types::raw_types::c_int,
        transport: ::types::raw_types::c_int,
        ver: *const ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_send_flight_completed"]
    pub fn ssl_send_flight_completed(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_recv_flight_completed"]
    pub fn ssl_recv_flight_completed(ssl: *mut ssl_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_resend"]
    pub fn ssl_resend(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_flight_transmit"]
    pub fn ssl_flight_transmit(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_dtls_replay_check"]
    pub fn ssl_dtls_replay_check(ssl: *const ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_dtls_replay_update"]
    pub fn ssl_dtls_replay_update(ssl: *mut ssl_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_session_copy"]
    pub fn ssl_session_copy(
        dst: *mut ssl_session,
        src: *const ssl_session,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_get_key_exchange_md_tls1_2"]
    pub fn ssl_get_key_exchange_md_tls1_2(
        ssl: *mut ssl_context,
        hash: *mut ::types::raw_types::c_uchar,
        hashlen: *mut usize,
        data: *mut ::types::raw_types::c_uchar,
        data_len: usize,
        md_alg: md_type_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_transform_init"]
    pub fn ssl_transform_init(transform: *mut ssl_transform);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_encrypt_buf"]
    pub fn ssl_encrypt_buf(
        ssl: *mut ssl_context,
        transform: *mut ssl_transform,
        rec: *mut record,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_decrypt_buf"]
    pub fn ssl_decrypt_buf(
        ssl: *const ssl_context,
        transform: *mut ssl_transform,
        rec: *mut record,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_resend_hello_request"]
    pub fn ssl_resend_hello_request(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_timer"]
    pub fn ssl_set_timer(ssl: *mut ssl_context, millisecs: u32);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_check_timer"]
    pub fn ssl_check_timer(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_reset_in_out_pointers"]
    pub fn ssl_reset_in_out_pointers(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_update_out_pointers"]
    pub fn ssl_update_out_pointers(ssl: *mut ssl_context, transform: *mut ssl_transform);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_update_in_pointers"]
    pub fn ssl_update_in_pointers(ssl: *mut ssl_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_session_reset_int"]
    pub fn ssl_session_reset_int(
        ssl: *mut ssl_context,
        partial: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_dtls_replay_reset"]
    pub fn ssl_dtls_replay_reset(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake_wrapup_free_hs_transform"]
    pub fn ssl_handshake_wrapup_free_hs_transform(ssl: *mut ssl_context);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_ssl_start_renegotiation"]
    pub fn ssl_start_renegotiation(ssl: *mut ssl_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_current_mtu"]
    pub fn ssl_get_current_mtu(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_buffering_free"]
    pub fn ssl_buffering_free(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_flight_free"]
    pub fn ssl_flight_free(flight: *mut ssl_flight_item);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_cookie_ctx {
    pub hmac_ctx: md_context_t,
    pub timeout: ::types::raw_types::c_ulong,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_ssl_cookie_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_cookie_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_cookie_ctx>(),
        80usize,
        concat!("Size of: ", stringify!(ssl_cookie_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_cookie_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_cookie_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hmac_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cookie_ctx),
            "::",
            stringify!(hmac_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cookie_ctx),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cookie_ctx),
            "::",
            stringify!(mutex)
        )
    );
}
impl Default for ssl_cookie_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cookie_init"]
    pub fn ssl_cookie_init(ctx: *mut ssl_cookie_ctx);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cookie_setup"]
    pub fn ssl_cookie_setup(
        ctx: *mut ssl_cookie_ctx,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cookie_set_timeout"]
    pub fn ssl_cookie_set_timeout(ctx: *mut ssl_cookie_ctx, delay: ::types::raw_types::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cookie_free"]
    pub fn ssl_cookie_free(ctx: *mut ssl_cookie_ctx);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cookie_write"]
    pub fn ssl_cookie_write(
        ctx: *mut ::types::raw_types::c_void,
        p: *mut *mut ::types::raw_types::c_uchar,
        end: *mut ::types::raw_types::c_uchar,
        info: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cookie_check"]
    pub fn ssl_cookie_check(
        ctx: *mut ::types::raw_types::c_void,
        cookie: *const ::types::raw_types::c_uchar,
        clen: usize,
        info: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_cache_entry {
    pub timestamp: time_t,
    pub session: ssl_session,
    pub peer_cert: x509_buf,
    pub next: *mut ssl_cache_entry,
}
#[test]
fn bindgen_test_layout_ssl_cache_entry() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_cache_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_cache_entry>(),
        200usize,
        concat!("Size of: ", stringify!(ssl_cache_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_cache_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_cache_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_entry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_entry),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_cert) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_entry),
            "::",
            stringify!(peer_cert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_entry),
            "::",
            stringify!(next)
        )
    );
}
impl Default for ssl_cache_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_cache_context {
    pub chain: *mut ssl_cache_entry,
    pub timeout: ::types::raw_types::c_int,
    pub max_entries: ::types::raw_types::c_int,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_ssl_cache_context() {
    const UNINIT: ::core::mem::MaybeUninit<ssl_cache_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ssl_cache_context>(),
        64usize,
        concat!("Size of: ", stringify!(ssl_cache_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_cache_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_cache_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_context),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_context),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_entries) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_context),
            "::",
            stringify!(max_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_context),
            "::",
            stringify!(mutex)
        )
    );
}
impl Default for ssl_cache_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cache_init"]
    pub fn ssl_cache_init(cache: *mut ssl_cache_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cache_get"]
    pub fn ssl_cache_get(
        data: *mut ::types::raw_types::c_void,
        session: *mut ssl_session,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cache_set"]
    pub fn ssl_cache_set(
        data: *mut ::types::raw_types::c_void,
        session: *const ssl_session,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cache_set_timeout"]
    pub fn ssl_cache_set_timeout(cache: *mut ssl_cache_context, timeout: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cache_set_max_entries"]
    pub fn ssl_cache_set_max_entries(cache: *mut ssl_cache_context, max: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_cache_free"]
    pub fn ssl_cache_free(cache: *mut ssl_cache_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_deduce_primes"]
    pub fn rsa_deduce_primes(
        N: *const mpi,
        E: *const mpi,
        D: *const mpi,
        P: *mut mpi,
        Q: *mut mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_deduce_private_exponent"]
    pub fn rsa_deduce_private_exponent(
        P: *const mpi,
        Q: *const mpi,
        E: *const mpi,
        D: *mut mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_deduce_crt"]
    pub fn rsa_deduce_crt(
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        DP: *mut mpi,
        DQ: *mut mpi,
        QP: *mut mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_validate_params"]
    pub fn rsa_validate_params(
        N: *const mpi,
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        E: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::types::raw_types::c_void,
                arg2: *mut ::types::raw_types::c_uchar,
                arg3: usize,
            ) -> ::types::raw_types::c_int,
        >,
        p_rng: *mut ::types::raw_types::c_void,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_validate_crt"]
    pub fn rsa_validate_crt(
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        DP: *const mpi,
        DQ: *const mpi,
        QP: *const mpi,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ripemd160_context {
    pub total: [u32; 2usize],
    pub state: [u32; 5usize],
    pub buffer: [::types::raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_ripemd160_context() {
    const UNINIT: ::core::mem::MaybeUninit<ripemd160_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ripemd160_context>(),
        92usize,
        concat!("Size of: ", stringify!(ripemd160_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ripemd160_context>(),
        4usize,
        concat!("Alignment of ", stringify!(ripemd160_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for ripemd160_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_init"]
    pub fn ripemd160_init(ctx: *mut ripemd160_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_free"]
    pub fn ripemd160_free(ctx: *mut ripemd160_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_clone"]
    pub fn ripemd160_clone(dst: *mut ripemd160_context, src: *const ripemd160_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_starts_ret"]
    pub fn ripemd160_starts_ret(ctx: *mut ripemd160_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_update_ret"]
    pub fn ripemd160_update_ret(
        ctx: *mut ripemd160_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_finish_ret"]
    pub fn ripemd160_finish_ret(
        ctx: *mut ripemd160_context,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_internal_ripemd160_process"]
    pub fn internal_ripemd160_process(
        ctx: *mut ripemd160_context,
        data: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_starts"]
    pub fn ripemd160_starts(ctx: *mut ripemd160_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_update"]
    pub fn ripemd160_update(
        ctx: *mut ripemd160_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_finish"]
    pub fn ripemd160_finish(ctx: *mut ripemd160_context, output: *mut ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_process"]
    pub fn ripemd160_process(ctx: *mut ripemd160_context, data: *const ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_ret"]
    pub fn ripemd160_ret(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160"]
    pub fn ripemd160(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_self_test"]
    pub fn ripemd160_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_context {
    pub dummy: ::types::raw_types::c_char,
}
#[test]
fn bindgen_test_layout_platform_context() {
    const UNINIT: ::core::mem::MaybeUninit<platform_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<platform_context>(),
        1usize,
        concat!("Size of: ", stringify!(platform_context))
    );
    assert_eq!(
        ::core::mem::align_of::<platform_context>(),
        1usize,
        concat!("Alignment of ", stringify!(platform_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(platform_context),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_platform_setup"]
    pub fn platform_setup(ctx: *mut platform_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_platform_teardown"]
    pub fn platform_teardown(ctx: *mut platform_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pkcs5_pbes2"]
    pub fn pkcs5_pbes2(
        pbe_params: *const asn1_buf,
        mode: ::types::raw_types::c_int,
        pwd: *const ::types::raw_types::c_uchar,
        pwdlen: usize,
        data: *const ::types::raw_types::c_uchar,
        datalen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pkcs5_pbes2_ext"]
    pub fn pkcs5_pbes2_ext(
        pbe_params: *const asn1_buf,
        mode: ::types::raw_types::c_int,
        pwd: *const ::types::raw_types::c_uchar,
        pwdlen: usize,
        data: *const ::types::raw_types::c_uchar,
        datalen: usize,
        output: *mut ::types::raw_types::c_uchar,
        output_size: usize,
        output_len: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pkcs5_pbkdf2_hmac"]
    pub fn pkcs5_pbkdf2_hmac(
        ctx: *mut md_context_t,
        password: *const ::types::raw_types::c_uchar,
        plen: usize,
        salt: *const ::types::raw_types::c_uchar,
        slen: usize,
        iteration_count: ::types::raw_types::c_uint,
        key_length: u32,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pkcs5_self_test"]
    pub fn pkcs5_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pkcs12_pbe_sha1_rc4_128"]
    pub fn pkcs12_pbe_sha1_rc4_128(
        pbe_params: *mut asn1_buf,
        mode: ::types::raw_types::c_int,
        pwd: *const ::types::raw_types::c_uchar,
        pwdlen: usize,
        input: *const ::types::raw_types::c_uchar,
        len: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pkcs12_pbe"]
    pub fn pkcs12_pbe(
        pbe_params: *mut asn1_buf,
        mode: ::types::raw_types::c_int,
        cipher_type: cipher_type_t,
        md_type: md_type_t,
        pwd: *const ::types::raw_types::c_uchar,
        pwdlen: usize,
        data: *const ::types::raw_types::c_uchar,
        len: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pkcs12_pbe_ext"]
    pub fn pkcs12_pbe_ext(
        pbe_params: *mut asn1_buf,
        mode: ::types::raw_types::c_int,
        cipher_type: cipher_type_t,
        md_type: md_type_t,
        pwd: *const ::types::raw_types::c_uchar,
        pwdlen: usize,
        data: *const ::types::raw_types::c_uchar,
        len: usize,
        output: *mut ::types::raw_types::c_uchar,
        output_size: usize,
        output_len: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pkcs12_derivation"]
    pub fn pkcs12_derivation(
        data: *mut ::types::raw_types::c_uchar,
        datalen: usize,
        pwd: *const ::types::raw_types::c_uchar,
        pwdlen: usize,
        salt: *const ::types::raw_types::c_uchar,
        saltlen: usize,
        mbedtls_md: md_type_t,
        id: ::types::raw_types::c_int,
        iterations: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pk_info_t {
    pub type_: pk_type_t,
    pub name: *const ::types::raw_types::c_char,
    pub get_bitlen: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::types::raw_types::c_void) -> usize,
    >,
    pub can_do:
        ::core::option::Option<unsafe extern "C" fn(type_: pk_type_t) -> ::types::raw_types::c_int>,
    pub verify_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            md_alg: md_type_t,
            hash: *const ::types::raw_types::c_uchar,
            hash_len: usize,
            sig: *const ::types::raw_types::c_uchar,
            sig_len: usize,
        ) -> ::types::raw_types::c_int,
    >,
    pub sign_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            md_alg: md_type_t,
            hash: *const ::types::raw_types::c_uchar,
            hash_len: usize,
            sig: *mut ::types::raw_types::c_uchar,
            sig_len: *mut usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::types::raw_types::c_void,
                    arg2: *mut ::types::raw_types::c_uchar,
                    arg3: usize,
                ) -> ::types::raw_types::c_int,
            >,
            p_rng: *mut ::types::raw_types::c_void,
        ) -> ::types::raw_types::c_int,
    >,
    pub decrypt_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            input: *const ::types::raw_types::c_uchar,
            ilen: usize,
            output: *mut ::types::raw_types::c_uchar,
            olen: *mut usize,
            osize: usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::types::raw_types::c_void,
                    arg2: *mut ::types::raw_types::c_uchar,
                    arg3: usize,
                ) -> ::types::raw_types::c_int,
            >,
            p_rng: *mut ::types::raw_types::c_void,
        ) -> ::types::raw_types::c_int,
    >,
    pub encrypt_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            input: *const ::types::raw_types::c_uchar,
            ilen: usize,
            output: *mut ::types::raw_types::c_uchar,
            olen: *mut usize,
            osize: usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::types::raw_types::c_void,
                    arg2: *mut ::types::raw_types::c_uchar,
                    arg3: usize,
                ) -> ::types::raw_types::c_int,
            >,
            p_rng: *mut ::types::raw_types::c_void,
        ) -> ::types::raw_types::c_int,
    >,
    pub check_pair_func: ::core::option::Option<
        unsafe extern "C" fn(
            pub_: *const ::types::raw_types::c_void,
            prv: *const ::types::raw_types::c_void,
        ) -> ::types::raw_types::c_int,
    >,
    pub ctx_alloc_func:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::types::raw_types::c_void>,
    pub ctx_free_func:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::types::raw_types::c_void)>,
    pub debug_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *const ::types::raw_types::c_void, items: *mut pk_debug_item),
    >,
}
#[test]
fn bindgen_test_layout_pk_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<pk_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pk_info_t>(),
        96usize,
        concat!("Size of: ", stringify!(pk_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pk_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_bitlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(get_bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_do) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(can_do)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verify_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(verify_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sign_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(sign_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decrypt_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(decrypt_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypt_func) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(encrypt_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).check_pair_func) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(check_pair_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx_alloc_func) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(ctx_alloc_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx_free_func) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(ctx_free_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).debug_func) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(debug_func)
        )
    );
}
impl Default for pk_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsa_alt_context {
    pub key: *mut ::types::raw_types::c_void,
    pub decrypt_func: pk_rsa_alt_decrypt_func,
    pub sign_func: pk_rsa_alt_sign_func,
    pub key_len_func: pk_rsa_alt_key_len_func,
}
#[test]
fn bindgen_test_layout_rsa_alt_context() {
    const UNINIT: ::core::mem::MaybeUninit<rsa_alt_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rsa_alt_context>(),
        32usize,
        concat!("Size of: ", stringify!(rsa_alt_context))
    );
    assert_eq!(
        ::core::mem::align_of::<rsa_alt_context>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_alt_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decrypt_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(decrypt_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sign_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(sign_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_len_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(key_len_func)
        )
    );
}
impl Default for rsa_alt_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_info"]
    pub static rsa_info: pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_eckey_info"]
    pub static eckey_info: pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_eckeydh_info"]
    pub static eckeydh_info: pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_info"]
    pub static ecdsa_info: pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_alt_info"]
    pub static rsa_alt_info: pk_info_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pem_context {
    pub buf: *mut ::types::raw_types::c_uchar,
    pub buflen: usize,
    pub info: *mut ::types::raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_pem_context() {
    const UNINIT: ::core::mem::MaybeUninit<pem_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pem_context>(),
        24usize,
        concat!("Size of: ", stringify!(pem_context))
    );
    assert_eq!(
        ::core::mem::align_of::<pem_context>(),
        8usize,
        concat!("Alignment of ", stringify!(pem_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buflen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(info)
        )
    );
}
impl Default for pem_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pem_init"]
    pub fn pem_init(ctx: *mut pem_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pem_read_buffer"]
    pub fn pem_read_buffer(
        ctx: *mut pem_context,
        header: *const ::types::raw_types::c_char,
        footer: *const ::types::raw_types::c_char,
        data: *const ::types::raw_types::c_uchar,
        pwd: *const ::types::raw_types::c_uchar,
        pwdlen: usize,
        use_len: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pem_free"]
    pub fn pem_free(ctx: *mut pem_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_pem_write_buffer"]
    pub fn pem_write_buffer(
        header: *const ::types::raw_types::c_char,
        footer: *const ::types::raw_types::c_char,
        der_data: *const ::types::raw_types::c_uchar,
        der_len: usize,
        buf: *mut ::types::raw_types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
pub const KW_MODE_KW: nist_kw_mode_t = 0;
pub const KW_MODE_KWP: nist_kw_mode_t = 1;
pub type nist_kw_mode_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nist_kw_context {
    pub cipher_ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_nist_kw_context() {
    const UNINIT: ::core::mem::MaybeUninit<nist_kw_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nist_kw_context>(),
        96usize,
        concat!("Size of: ", stringify!(nist_kw_context))
    );
    assert_eq!(
        ::core::mem::align_of::<nist_kw_context>(),
        8usize,
        concat!("Alignment of ", stringify!(nist_kw_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nist_kw_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
impl Default for nist_kw_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_nist_kw_init"]
    pub fn nist_kw_init(ctx: *mut nist_kw_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_nist_kw_setkey"]
    pub fn nist_kw_setkey(
        ctx: *mut nist_kw_context,
        cipher: cipher_id_t,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
        is_wrap: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_nist_kw_free"]
    pub fn nist_kw_free(ctx: *mut nist_kw_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_nist_kw_wrap"]
    pub fn nist_kw_wrap(
        ctx: *mut nist_kw_context,
        mode: nist_kw_mode_t,
        input: *const ::types::raw_types::c_uchar,
        in_len: usize,
        output: *mut ::types::raw_types::c_uchar,
        out_len: *mut usize,
        out_size: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_nist_kw_unwrap"]
    pub fn nist_kw_unwrap(
        ctx: *mut nist_kw_context,
        mode: nist_kw_mode_t,
        input: *const ::types::raw_types::c_uchar,
        in_len: usize,
        output: *mut ::types::raw_types::c_uchar,
        out_len: *mut usize,
        out_size: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_nist_kw_self_test"]
    pub fn nist_kw_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_memory_buffer_alloc_init"]
    pub fn memory_buffer_alloc_init(buf: *mut ::types::raw_types::c_uchar, len: usize);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_memory_buffer_alloc_free"]
    pub fn memory_buffer_alloc_free();
}
extern "C" {
    #[link_name = "\u{1}mbedtls_memory_buffer_set_verify"]
    pub fn memory_buffer_set_verify(verify: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_memory_buffer_alloc_verify"]
    pub fn memory_buffer_alloc_verify() -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_memory_buffer_alloc_self_test"]
    pub fn memory_buffer_alloc_self_test(
        verbose: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md_info_t {
    pub name: *const ::types::raw_types::c_char,
    pub type_: md_type_t,
    pub size: ::types::raw_types::c_uchar,
    pub block_size: ::types::raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_md_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<md_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<md_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(md_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<md_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(md_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(block_size)
        )
    );
}
impl Default for md_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_info"]
    pub static md2_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_info"]
    pub static md4_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_info"]
    pub static md5_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_info"]
    pub static ripemd160_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_info"]
    pub static sha1_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha224_info"]
    pub static sha224_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_info"]
    pub static sha256_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha384_info"]
    pub static sha384_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_info"]
    pub static sha512_info: md_info_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md4_context {
    pub total: [u32; 2usize],
    pub state: [u32; 4usize],
    pub buffer: [::types::raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md4_context() {
    const UNINIT: ::core::mem::MaybeUninit<md4_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<md4_context>(),
        88usize,
        concat!("Size of: ", stringify!(md4_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md4_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md4_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for md4_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_init"]
    pub fn md4_init(ctx: *mut md4_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_free"]
    pub fn md4_free(ctx: *mut md4_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_clone"]
    pub fn md4_clone(dst: *mut md4_context, src: *const md4_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_starts_ret"]
    pub fn md4_starts_ret(ctx: *mut md4_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_update_ret"]
    pub fn md4_update_ret(
        ctx: *mut md4_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_finish_ret"]
    pub fn md4_finish_ret(
        ctx: *mut md4_context,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_internal_md4_process"]
    pub fn internal_md4_process(
        ctx: *mut md4_context,
        data: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_starts"]
    pub fn md4_starts(ctx: *mut md4_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_update"]
    pub fn md4_update(
        ctx: *mut md4_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_finish"]
    pub fn md4_finish(ctx: *mut md4_context, output: *mut ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_process"]
    pub fn md4_process(ctx: *mut md4_context, data: *const ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_ret"]
    pub fn md4_ret(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4"]
    pub fn md4(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md4_self_test"]
    pub fn md4_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md2_context {
    pub cksum: [::types::raw_types::c_uchar; 16usize],
    pub state: [::types::raw_types::c_uchar; 48usize],
    pub buffer: [::types::raw_types::c_uchar; 16usize],
    pub left: usize,
}
#[test]
fn bindgen_test_layout_md2_context() {
    const UNINIT: ::core::mem::MaybeUninit<md2_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<md2_context>(),
        88usize,
        concat!("Size of: ", stringify!(md2_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md2_context>(),
        8usize,
        concat!("Alignment of ", stringify!(md2_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cksum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(cksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(left)
        )
    );
}
impl Default for md2_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_init"]
    pub fn md2_init(ctx: *mut md2_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_free"]
    pub fn md2_free(ctx: *mut md2_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_clone"]
    pub fn md2_clone(dst: *mut md2_context, src: *const md2_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_starts_ret"]
    pub fn md2_starts_ret(ctx: *mut md2_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_update_ret"]
    pub fn md2_update_ret(
        ctx: *mut md2_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_finish_ret"]
    pub fn md2_finish_ret(
        ctx: *mut md2_context,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_internal_md2_process"]
    pub fn internal_md2_process(ctx: *mut md2_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_starts"]
    pub fn md2_starts(ctx: *mut md2_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_update"]
    pub fn md2_update(
        ctx: *mut md2_context,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_finish"]
    pub fn md2_finish(ctx: *mut md2_context, output: *mut ::types::raw_types::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_process"]
    pub fn md2_process(ctx: *mut md2_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_ret"]
    pub fn md2_ret(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2"]
    pub fn md2(
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md2_self_test"]
    pub fn md2_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hkdf"]
    pub fn hkdf(
        md: *const md_info_t,
        salt: *const ::types::raw_types::c_uchar,
        salt_len: usize,
        ikm: *const ::types::raw_types::c_uchar,
        ikm_len: usize,
        info: *const ::types::raw_types::c_uchar,
        info_len: usize,
        okm: *mut ::types::raw_types::c_uchar,
        okm_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hkdf_extract"]
    pub fn hkdf_extract(
        md: *const md_info_t,
        salt: *const ::types::raw_types::c_uchar,
        salt_len: usize,
        ikm: *const ::types::raw_types::c_uchar,
        ikm_len: usize,
        prk: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hkdf_expand"]
    pub fn hkdf_expand(
        md: *const md_info_t,
        prk: *const ::types::raw_types::c_uchar,
        prk_len: usize,
        info: *const ::types::raw_types::c_uchar,
        info_len: usize,
        okm: *mut ::types::raw_types::c_uchar,
        okm_len: usize,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gcm_context {
    pub cipher_ctx: cipher_context_t,
    pub HL: [u64; 16usize],
    pub HH: [u64; 16usize],
    pub len: u64,
    pub add_len: u64,
    pub base_ectr: [::types::raw_types::c_uchar; 16usize],
    pub y: [::types::raw_types::c_uchar; 16usize],
    pub buf: [::types::raw_types::c_uchar; 16usize],
    pub mode: ::types::raw_types::c_int,
}
#[test]
fn bindgen_test_layout_gcm_context() {
    const UNINIT: ::core::mem::MaybeUninit<gcm_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gcm_context>(),
        424usize,
        concat!("Size of: ", stringify!(gcm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<gcm_context>(),
        8usize,
        concat!("Alignment of ", stringify!(gcm_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HL) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(HL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HH) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(HH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_len) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(add_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base_ectr) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(base_ectr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for gcm_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_init"]
    pub fn gcm_init(ctx: *mut gcm_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_setkey"]
    pub fn gcm_setkey(
        ctx: *mut gcm_context,
        cipher: cipher_id_t,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_crypt_and_tag"]
    pub fn gcm_crypt_and_tag(
        ctx: *mut gcm_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        add: *const ::types::raw_types::c_uchar,
        add_len: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        tag_len: usize,
        tag: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_auth_decrypt"]
    pub fn gcm_auth_decrypt(
        ctx: *mut gcm_context,
        length: usize,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        add: *const ::types::raw_types::c_uchar,
        add_len: usize,
        tag: *const ::types::raw_types::c_uchar,
        tag_len: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_starts"]
    pub fn gcm_starts(
        ctx: *mut gcm_context,
        mode: ::types::raw_types::c_int,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        add: *const ::types::raw_types::c_uchar,
        add_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_update"]
    pub fn gcm_update(
        ctx: *mut gcm_context,
        length: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_finish"]
    pub fn gcm_finish(
        ctx: *mut gcm_context,
        tag: *mut ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_free"]
    pub fn gcm_free(ctx: *mut gcm_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_gcm_self_test"]
    pub fn gcm_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_strerror"]
    pub fn strerror(
        errnum: ::types::raw_types::c_int,
        buffer: *mut ::types::raw_types::c_char,
        buflen: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_high_level_strerr"]
    pub fn high_level_strerr(
        error_code: ::types::raw_types::c_int,
    ) -> *const ::types::raw_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_low_level_strerr"]
    pub fn low_level_strerr(
        error_code: ::types::raw_types::c_int,
    ) -> *const ::types::raw_types::c_char;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_platform_entropy_poll"]
    pub fn platform_entropy_poll(
        data: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_hardclock_poll"]
    pub fn hardclock_poll(
        data: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int;
}
pub type entropy_f_source_ptr = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> ::types::raw_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entropy_source_state {
    pub f_source: entropy_f_source_ptr,
    pub p_source: *mut ::types::raw_types::c_void,
    pub size: usize,
    pub threshold: usize,
    pub strong: ::types::raw_types::c_int,
}
#[test]
fn bindgen_test_layout_entropy_source_state() {
    const UNINIT: ::core::mem::MaybeUninit<entropy_source_state> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<entropy_source_state>(),
        40usize,
        concat!("Size of: ", stringify!(entropy_source_state))
    );
    assert_eq!(
        ::core::mem::align_of::<entropy_source_state>(),
        8usize,
        concat!("Alignment of ", stringify!(entropy_source_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(f_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_source) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(p_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strong) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(strong)
        )
    );
}
impl Default for entropy_source_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entropy_context {
    pub accumulator_started: ::types::raw_types::c_int,
    pub accumulator: sha512_context,
    pub source_count: ::types::raw_types::c_int,
    pub source: [entropy_source_state; 20usize],
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_entropy_context() {
    const UNINIT: ::core::mem::MaybeUninit<entropy_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<entropy_context>(),
        1080usize,
        concat!("Size of: ", stringify!(entropy_context))
    );
    assert_eq!(
        ::core::mem::align_of::<entropy_context>(),
        8usize,
        concat!("Alignment of ", stringify!(entropy_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accumulator_started) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(accumulator_started)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accumulator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(accumulator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source_count) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(source_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(mutex)
        )
    );
}
impl Default for entropy_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_init"]
    pub fn entropy_init(ctx: *mut entropy_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_free"]
    pub fn entropy_free(ctx: *mut entropy_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_add_source"]
    pub fn entropy_add_source(
        ctx: *mut entropy_context,
        f_source: entropy_f_source_ptr,
        p_source: *mut ::types::raw_types::c_void,
        threshold: usize,
        strong: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_gather"]
    pub fn entropy_gather(ctx: *mut entropy_context) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_func"]
    pub fn entropy_func(
        data: *mut ::types::raw_types::c_void,
        output: *mut ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_update_manual"]
    pub fn entropy_update_manual(
        ctx: *mut entropy_context,
        data: *const ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_write_seed_file"]
    pub fn entropy_write_seed_file(
        ctx: *mut entropy_context,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_update_seed_file"]
    pub fn entropy_update_seed_file(
        ctx: *mut entropy_context,
        path: *const ::types::raw_types::c_char,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_entropy_self_test"]
    pub fn entropy_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct des_context {
    pub sk: [u32; 32usize],
}
#[test]
fn bindgen_test_layout_des_context() {
    const UNINIT: ::core::mem::MaybeUninit<des_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<des_context>(),
        128usize,
        concat!("Size of: ", stringify!(des_context))
    );
    assert_eq!(
        ::core::mem::align_of::<des_context>(),
        4usize,
        concat!("Alignment of ", stringify!(des_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(des_context),
            "::",
            stringify!(sk)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct des3_context {
    pub sk: [u32; 96usize],
}
#[test]
fn bindgen_test_layout_des3_context() {
    const UNINIT: ::core::mem::MaybeUninit<des3_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<des3_context>(),
        384usize,
        concat!("Size of: ", stringify!(des3_context))
    );
    assert_eq!(
        ::core::mem::align_of::<des3_context>(),
        4usize,
        concat!("Alignment of ", stringify!(des3_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(des3_context),
            "::",
            stringify!(sk)
        )
    );
}
impl Default for des3_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_des_init"]
    pub fn des_init(ctx: *mut des_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_des_free"]
    pub fn des_free(ctx: *mut des_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_des3_init"]
    pub fn des3_init(ctx: *mut des3_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_des3_free"]
    pub fn des3_free(ctx: *mut des3_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_des_key_set_parity"]
    pub fn des_key_set_parity(key: *mut ::types::raw_types::c_uchar);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des_key_check_key_parity"]
    pub fn des_key_check_key_parity(
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des_key_check_weak"]
    pub fn des_key_check_weak(key: *const ::types::raw_types::c_uchar)
        -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des_setkey_enc"]
    pub fn des_setkey_enc(
        ctx: *mut des_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des_setkey_dec"]
    pub fn des_setkey_dec(
        ctx: *mut des_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des3_set2key_enc"]
    pub fn des3_set2key_enc(
        ctx: *mut des3_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des3_set2key_dec"]
    pub fn des3_set2key_dec(
        ctx: *mut des3_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des3_set3key_enc"]
    pub fn des3_set3key_enc(
        ctx: *mut des3_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des3_set3key_dec"]
    pub fn des3_set3key_dec(
        ctx: *mut des3_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des_crypt_ecb"]
    pub fn des_crypt_ecb(
        ctx: *mut des_context,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des_crypt_cbc"]
    pub fn des_crypt_cbc(
        ctx: *mut des_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des3_crypt_ecb"]
    pub fn des3_crypt_ecb(
        ctx: *mut des3_context,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des3_crypt_cbc"]
    pub fn des3_crypt_cbc(
        ctx: *mut des3_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_des_setkey"]
    pub fn des_setkey(SK: *mut u32, key: *const ::types::raw_types::c_uchar);
}
extern "C" {
    #[must_use]
    #[link_name = "\u{1}mbedtls_des_self_test"]
    pub fn des_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_debug_set_threshold"]
    pub fn debug_set_threshold(threshold: ::types::raw_types::c_int);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_debug_print_msg"]
    pub fn debug_print_msg(
        ssl: *const ssl_context,
        level: ::types::raw_types::c_int,
        file: *const ::types::raw_types::c_char,
        line: ::types::raw_types::c_int,
        format: *const ::types::raw_types::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_debug_print_ret"]
    pub fn debug_print_ret(
        ssl: *const ssl_context,
        level: ::types::raw_types::c_int,
        file: *const ::types::raw_types::c_char,
        line: ::types::raw_types::c_int,
        text: *const ::types::raw_types::c_char,
        ret: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_debug_print_buf"]
    pub fn debug_print_buf(
        ssl: *const ssl_context,
        level: ::types::raw_types::c_int,
        file: *const ::types::raw_types::c_char,
        line: ::types::raw_types::c_int,
        text: *const ::types::raw_types::c_char,
        buf: *const ::types::raw_types::c_uchar,
        len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_debug_print_mpi"]
    pub fn debug_print_mpi(
        ssl: *const ssl_context,
        level: ::types::raw_types::c_int,
        file: *const ::types::raw_types::c_char,
        line: ::types::raw_types::c_int,
        text: *const ::types::raw_types::c_char,
        X: *const mpi,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_debug_print_ecp"]
    pub fn debug_print_ecp(
        ssl: *const ssl_context,
        level: ::types::raw_types::c_int,
        file: *const ::types::raw_types::c_char,
        line: ::types::raw_types::c_int,
        text: *const ::types::raw_types::c_char,
        X: *const ecp_point,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_debug_print_crt"]
    pub fn debug_print_crt(
        ssl: *const ssl_context,
        level: ::types::raw_types::c_int,
        file: *const ::types::raw_types::c_char,
        line: ::types::raw_types::c_int,
        text: *const ::types::raw_types::c_char,
        crt: *const x509_crt,
    );
}
pub const DEBUG_ECDH_Q: debug_ecdh_attr = 0;
pub const DEBUG_ECDH_QP: debug_ecdh_attr = 1;
pub const DEBUG_ECDH_Z: debug_ecdh_attr = 2;
pub type debug_ecdh_attr = u32;
extern "C" {
    #[link_name = "\u{1}mbedtls_debug_printf_ecdh"]
    pub fn debug_printf_ecdh(
        ssl: *const ssl_context,
        level: ::types::raw_types::c_int,
        file: *const ::types::raw_types::c_char,
        line: ::types::raw_types::c_int,
        ecdh: *const ecdh_context,
        attr: debug_ecdh_attr,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ct_memcmp"]
    pub fn ct_memcmp(
        a: *const ::types::raw_types::c_void,
        b: *const ::types::raw_types::c_void,
        n: usize,
    ) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cmac_context_t {
    pub state: [::types::raw_types::c_uchar; 16usize],
    pub unprocessed_block: [::types::raw_types::c_uchar; 16usize],
    pub unprocessed_len: usize,
}
#[test]
fn bindgen_test_layout_cmac_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<cmac_context_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cmac_context_t>(),
        40usize,
        concat!("Size of: ", stringify!(cmac_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cmac_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cmac_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_block) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(unprocessed_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_len) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_cmac_starts"]
    pub fn cipher_cmac_starts(
        ctx: *mut cipher_context_t,
        key: *const ::types::raw_types::c_uchar,
        keybits: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_cmac_update"]
    pub fn cipher_cmac_update(
        ctx: *mut cipher_context_t,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_cmac_finish"]
    pub fn cipher_cmac_finish(
        ctx: *mut cipher_context_t,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_cmac_reset"]
    pub fn cipher_cmac_reset(ctx: *mut cipher_context_t) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_cmac"]
    pub fn cipher_cmac(
        cipher_info: *const cipher_info_t,
        key: *const ::types::raw_types::c_uchar,
        keylen: usize,
        input: *const ::types::raw_types::c_uchar,
        ilen: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aes_cmac_prf_128"]
    pub fn aes_cmac_prf_128(
        key: *const ::types::raw_types::c_uchar,
        key_len: usize,
        input: *const ::types::raw_types::c_uchar,
        in_len: usize,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cmac_self_test"]
    pub fn cmac_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cipher_base_t {
    pub cipher: cipher_id_t,
    pub ecb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            mode: operation_t,
            input: *const ::types::raw_types::c_uchar,
            output: *mut ::types::raw_types::c_uchar,
        ) -> ::types::raw_types::c_int,
    >,
    pub cbc_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            mode: operation_t,
            length: usize,
            iv: *mut ::types::raw_types::c_uchar,
            input: *const ::types::raw_types::c_uchar,
            output: *mut ::types::raw_types::c_uchar,
        ) -> ::types::raw_types::c_int,
    >,
    pub cfb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            mode: operation_t,
            length: usize,
            iv_off: *mut usize,
            iv: *mut ::types::raw_types::c_uchar,
            input: *const ::types::raw_types::c_uchar,
            output: *mut ::types::raw_types::c_uchar,
        ) -> ::types::raw_types::c_int,
    >,
    pub ofb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            length: usize,
            iv_off: *mut usize,
            iv: *mut ::types::raw_types::c_uchar,
            input: *const ::types::raw_types::c_uchar,
            output: *mut ::types::raw_types::c_uchar,
        ) -> ::types::raw_types::c_int,
    >,
    pub ctr_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            length: usize,
            nc_off: *mut usize,
            nonce_counter: *mut ::types::raw_types::c_uchar,
            stream_block: *mut ::types::raw_types::c_uchar,
            input: *const ::types::raw_types::c_uchar,
            output: *mut ::types::raw_types::c_uchar,
        ) -> ::types::raw_types::c_int,
    >,
    pub xts_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            mode: operation_t,
            length: usize,
            data_unit: *const ::types::raw_types::c_uchar,
            input: *const ::types::raw_types::c_uchar,
            output: *mut ::types::raw_types::c_uchar,
        ) -> ::types::raw_types::c_int,
    >,
    pub stream_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            length: usize,
            input: *const ::types::raw_types::c_uchar,
            output: *mut ::types::raw_types::c_uchar,
        ) -> ::types::raw_types::c_int,
    >,
    pub setkey_enc_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            key: *const ::types::raw_types::c_uchar,
            key_bitlen: ::types::raw_types::c_uint,
        ) -> ::types::raw_types::c_int,
    >,
    pub setkey_dec_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::types::raw_types::c_void,
            key: *const ::types::raw_types::c_uchar,
            key_bitlen: ::types::raw_types::c_uint,
        ) -> ::types::raw_types::c_int,
    >,
    pub ctx_alloc_func:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::types::raw_types::c_void>,
    pub ctx_free_func:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::types::raw_types::c_void)>,
}
#[test]
fn bindgen_test_layout_cipher_base_t() {
    const UNINIT: ::core::mem::MaybeUninit<cipher_base_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cipher_base_t>(),
        96usize,
        concat!("Size of: ", stringify!(cipher_base_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_base_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cipher_base_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecb_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ecb_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbc_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cbc_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfb_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cfb_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ofb_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ofb_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctr_func) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctr_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xts_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(xts_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stream_func) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(stream_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setkey_enc_func) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(setkey_enc_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setkey_dec_func) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(setkey_dec_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx_alloc_func) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctx_alloc_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx_free_func) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctx_free_func)
        )
    );
}
impl Default for cipher_base_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cipher_definition_t {
    pub type_: cipher_type_t,
    pub info: *const cipher_info_t,
}
#[test]
fn bindgen_test_layout_cipher_definition_t() {
    const UNINIT: ::core::mem::MaybeUninit<cipher_definition_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cipher_definition_t>(),
        16usize,
        concat!("Size of: ", stringify!(cipher_definition_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_definition_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cipher_definition_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_definition_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_definition_t),
            "::",
            stringify!(info)
        )
    );
}
impl Default for cipher_definition_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_definitions"]
    pub static cipher_definitions: [cipher_definition_t; 0usize];
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_supported"]
    pub static mut cipher_supported: [::types::raw_types::c_int; 0usize];
}
pub const CHACHAPOLY_ENCRYPT: chachapoly_mode_t = 0;
pub const CHACHAPOLY_DECRYPT: chachapoly_mode_t = 1;
pub type chachapoly_mode_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct chachapoly_context {
    pub chacha20_ctx: chacha20_context,
    pub poly1305_ctx: poly1305_context,
    pub aad_len: u64,
    pub ciphertext_len: u64,
    pub state: ::types::raw_types::c_int,
    pub mode: chachapoly_mode_t,
}
#[test]
fn bindgen_test_layout_chachapoly_context() {
    const UNINIT: ::core::mem::MaybeUninit<chachapoly_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<chachapoly_context>(),
        240usize,
        concat!("Size of: ", stringify!(chachapoly_context))
    );
    assert_eq!(
        ::core::mem::align_of::<chachapoly_context>(),
        8usize,
        concat!("Alignment of ", stringify!(chachapoly_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chacha20_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(chacha20_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poly1305_ctx) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(poly1305_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aad_len) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(aad_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ciphertext_len) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(ciphertext_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for chachapoly_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_init"]
    pub fn chachapoly_init(ctx: *mut chachapoly_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_free"]
    pub fn chachapoly_free(ctx: *mut chachapoly_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_setkey"]
    pub fn chachapoly_setkey(
        ctx: *mut chachapoly_context,
        key: *const ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_starts"]
    pub fn chachapoly_starts(
        ctx: *mut chachapoly_context,
        nonce: *const ::types::raw_types::c_uchar,
        mode: chachapoly_mode_t,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_update_aad"]
    pub fn chachapoly_update_aad(
        ctx: *mut chachapoly_context,
        aad: *const ::types::raw_types::c_uchar,
        aad_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_update"]
    pub fn chachapoly_update(
        ctx: *mut chachapoly_context,
        len: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_finish"]
    pub fn chachapoly_finish(
        ctx: *mut chachapoly_context,
        mac: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_encrypt_and_tag"]
    pub fn chachapoly_encrypt_and_tag(
        ctx: *mut chachapoly_context,
        length: usize,
        nonce: *const ::types::raw_types::c_uchar,
        aad: *const ::types::raw_types::c_uchar,
        aad_len: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        tag: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_auth_decrypt"]
    pub fn chachapoly_auth_decrypt(
        ctx: *mut chachapoly_context,
        length: usize,
        nonce: *const ::types::raw_types::c_uchar,
        aad: *const ::types::raw_types::c_uchar,
        aad_len: usize,
        tag: *const ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_chachapoly_self_test"]
    pub fn chachapoly_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ccm_context {
    pub cipher_ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_ccm_context() {
    const UNINIT: ::core::mem::MaybeUninit<ccm_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ccm_context>(),
        96usize,
        concat!("Size of: ", stringify!(ccm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ccm_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ccm_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ccm_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
impl Default for ccm_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ccm_init"]
    pub fn ccm_init(ctx: *mut ccm_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ccm_setkey"]
    pub fn ccm_setkey(
        ctx: *mut ccm_context,
        cipher: cipher_id_t,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ccm_free"]
    pub fn ccm_free(ctx: *mut ccm_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ccm_encrypt_and_tag"]
    pub fn ccm_encrypt_and_tag(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        add: *const ::types::raw_types::c_uchar,
        add_len: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        tag: *mut ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ccm_star_encrypt_and_tag"]
    pub fn ccm_star_encrypt_and_tag(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        add: *const ::types::raw_types::c_uchar,
        add_len: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        tag: *mut ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ccm_auth_decrypt"]
    pub fn ccm_auth_decrypt(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        add: *const ::types::raw_types::c_uchar,
        add_len: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        tag: *const ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ccm_star_auth_decrypt"]
    pub fn ccm_star_auth_decrypt(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const ::types::raw_types::c_uchar,
        iv_len: usize,
        add: *const ::types::raw_types::c_uchar,
        add_len: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
        tag: *const ::types::raw_types::c_uchar,
        tag_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ccm_self_test"]
    pub fn ccm_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct camellia_context {
    pub nr: ::types::raw_types::c_int,
    pub rk: [u32; 68usize],
}
#[test]
fn bindgen_test_layout_camellia_context() {
    const UNINIT: ::core::mem::MaybeUninit<camellia_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<camellia_context>(),
        276usize,
        concat!("Size of: ", stringify!(camellia_context))
    );
    assert_eq!(
        ::core::mem::align_of::<camellia_context>(),
        4usize,
        concat!("Alignment of ", stringify!(camellia_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rk) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_context),
            "::",
            stringify!(rk)
        )
    );
}
impl Default for camellia_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_init"]
    pub fn camellia_init(ctx: *mut camellia_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_free"]
    pub fn camellia_free(ctx: *mut camellia_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_setkey_enc"]
    pub fn camellia_setkey_enc(
        ctx: *mut camellia_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_setkey_dec"]
    pub fn camellia_setkey_dec(
        ctx: *mut camellia_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_crypt_ecb"]
    pub fn camellia_crypt_ecb(
        ctx: *mut camellia_context,
        mode: ::types::raw_types::c_int,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_crypt_cbc"]
    pub fn camellia_crypt_cbc(
        ctx: *mut camellia_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_crypt_cfb128"]
    pub fn camellia_crypt_cfb128(
        ctx: *mut camellia_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_crypt_ctr"]
    pub fn camellia_crypt_ctr(
        ctx: *mut camellia_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut ::types::raw_types::c_uchar,
        stream_block: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_camellia_self_test"]
    pub fn camellia_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blowfish_context {
    pub P: [u32; 18usize],
    pub S: [[u32; 256usize]; 4usize],
}
#[test]
fn bindgen_test_layout_blowfish_context() {
    const UNINIT: ::core::mem::MaybeUninit<blowfish_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<blowfish_context>(),
        4168usize,
        concat!("Size of: ", stringify!(blowfish_context))
    );
    assert_eq!(
        ::core::mem::align_of::<blowfish_context>(),
        4usize,
        concat!("Alignment of ", stringify!(blowfish_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).P) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blowfish_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).S) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blowfish_context),
            "::",
            stringify!(S)
        )
    );
}
impl Default for blowfish_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_blowfish_init"]
    pub fn blowfish_init(ctx: *mut blowfish_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_blowfish_free"]
    pub fn blowfish_free(ctx: *mut blowfish_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_blowfish_setkey"]
    pub fn blowfish_setkey(
        ctx: *mut blowfish_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_blowfish_crypt_ecb"]
    pub fn blowfish_crypt_ecb(
        ctx: *mut blowfish_context,
        mode: ::types::raw_types::c_int,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_blowfish_crypt_cbc"]
    pub fn blowfish_crypt_cbc(
        ctx: *mut blowfish_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_blowfish_crypt_cfb64"]
    pub fn blowfish_crypt_cfb64(
        ctx: *mut blowfish_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_blowfish_crypt_ctr"]
    pub fn blowfish_crypt_ctr(
        ctx: *mut blowfish_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut ::types::raw_types::c_uchar,
        stream_block: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_base64_encode"]
    pub fn base64_encode(
        dst: *mut ::types::raw_types::c_uchar,
        dlen: usize,
        olen: *mut usize,
        src: *const ::types::raw_types::c_uchar,
        slen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_base64_decode"]
    pub fn base64_decode(
        dst: *mut ::types::raw_types::c_uchar,
        dlen: usize,
        olen: *mut usize,
        src: *const ::types::raw_types::c_uchar,
        slen: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_base64_self_test"]
    pub fn base64_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_len"]
    pub fn asn1_write_len(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_tag"]
    pub fn asn1_write_tag(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        tag: ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_raw_buffer"]
    pub fn asn1_write_raw_buffer(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        buf: *const ::types::raw_types::c_uchar,
        size: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_mpi"]
    pub fn asn1_write_mpi(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        X: *const mpi,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_null"]
    pub fn asn1_write_null(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_oid"]
    pub fn asn1_write_oid(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        oid: *const ::types::raw_types::c_char,
        oid_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_algorithm_identifier"]
    pub fn asn1_write_algorithm_identifier(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        oid: *const ::types::raw_types::c_char,
        oid_len: usize,
        par_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_algorithm_identifier_ext"]
    pub fn asn1_write_algorithm_identifier_ext(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        oid: *const ::types::raw_types::c_char,
        oid_len: usize,
        par_len: usize,
        has_par: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_bool"]
    pub fn asn1_write_bool(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        boolean: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_int"]
    pub fn asn1_write_int(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        val: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_enum"]
    pub fn asn1_write_enum(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        val: ::types::raw_types::c_int,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_tagged_string"]
    pub fn asn1_write_tagged_string(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        tag: ::types::raw_types::c_int,
        text: *const ::types::raw_types::c_char,
        text_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_printable_string"]
    pub fn asn1_write_printable_string(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        text: *const ::types::raw_types::c_char,
        text_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_utf8_string"]
    pub fn asn1_write_utf8_string(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        text: *const ::types::raw_types::c_char,
        text_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_ia5_string"]
    pub fn asn1_write_ia5_string(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        text: *const ::types::raw_types::c_char,
        text_len: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_bitstring"]
    pub fn asn1_write_bitstring(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        buf: *const ::types::raw_types::c_uchar,
        bits: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_named_bitstring"]
    pub fn asn1_write_named_bitstring(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        buf: *const ::types::raw_types::c_uchar,
        bits: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_write_octet_string"]
    pub fn asn1_write_octet_string(
        p: *mut *mut ::types::raw_types::c_uchar,
        start: *mut ::types::raw_types::c_uchar,
        buf: *const ::types::raw_types::c_uchar,
        size: usize,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_asn1_store_named_data"]
    pub fn asn1_store_named_data(
        list: *mut *mut asn1_named_data,
        oid: *const ::types::raw_types::c_char,
        oid_len: usize,
        val: *const ::types::raw_types::c_uchar,
        val_len: usize,
    ) -> *mut asn1_named_data;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct aria_context {
    pub nr: ::types::raw_types::c_uchar,
    pub rk: [[u32; 4usize]; 17usize],
}
#[test]
fn bindgen_test_layout_aria_context() {
    const UNINIT: ::core::mem::MaybeUninit<aria_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<aria_context>(),
        276usize,
        concat!("Size of: ", stringify!(aria_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aria_context>(),
        4usize,
        concat!("Alignment of ", stringify!(aria_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aria_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rk) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aria_context),
            "::",
            stringify!(rk)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_init"]
    pub fn aria_init(ctx: *mut aria_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_free"]
    pub fn aria_free(ctx: *mut aria_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_setkey_enc"]
    pub fn aria_setkey_enc(
        ctx: *mut aria_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_setkey_dec"]
    pub fn aria_setkey_dec(
        ctx: *mut aria_context,
        key: *const ::types::raw_types::c_uchar,
        keybits: ::types::raw_types::c_uint,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_crypt_ecb"]
    pub fn aria_crypt_ecb(
        ctx: *mut aria_context,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_crypt_cbc"]
    pub fn aria_crypt_cbc(
        ctx: *mut aria_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_crypt_cfb128"]
    pub fn aria_crypt_cfb128(
        ctx: *mut aria_context,
        mode: ::types::raw_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_crypt_ctr"]
    pub fn aria_crypt_ctr(
        ctx: *mut aria_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut ::types::raw_types::c_uchar,
        stream_block: *mut ::types::raw_types::c_uchar,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aria_self_test"]
    pub fn aria_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arc4_context {
    pub x: ::types::raw_types::c_int,
    pub y: ::types::raw_types::c_int,
    pub m: [::types::raw_types::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_arc4_context() {
    const UNINIT: ::core::mem::MaybeUninit<arc4_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arc4_context>(),
        264usize,
        concat!("Size of: ", stringify!(arc4_context))
    );
    assert_eq!(
        ::core::mem::align_of::<arc4_context>(),
        4usize,
        concat!("Alignment of ", stringify!(arc4_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(m)
        )
    );
}
impl Default for arc4_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_arc4_init"]
    pub fn arc4_init(ctx: *mut arc4_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_arc4_free"]
    pub fn arc4_free(ctx: *mut arc4_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_arc4_setup"]
    pub fn arc4_setup(
        ctx: *mut arc4_context,
        key: *const ::types::raw_types::c_uchar,
        keylen: ::types::raw_types::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_arc4_crypt"]
    pub fn arc4_crypt(
        ctx: *mut arc4_context,
        length: usize,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_arc4_self_test"]
    pub fn arc4_self_test(verbose: ::types::raw_types::c_int) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aesni_has_support"]
    pub fn aesni_has_support(what: ::types::raw_types::c_uint) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aesni_crypt_ecb"]
    pub fn aesni_crypt_ecb(
        ctx: *mut aes_context,
        mode: ::types::raw_types::c_int,
        input: *const ::types::raw_types::c_uchar,
        output: *mut ::types::raw_types::c_uchar,
    ) -> ::types::raw_types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aesni_gcm_mult"]
    pub fn aesni_gcm_mult(
        c: *mut ::types::raw_types::c_uchar,
        a: *const ::types::raw_types::c_uchar,
        b: *const ::types::raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aesni_inverse_key"]
    pub fn aesni_inverse_key(
        invkey: *mut ::types::raw_types::c_uchar,
        fwdkey: *const ::types::raw_types::c_uchar,
        nr: ::types::raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_aesni_setkey_enc"]
    pub fn aesni_setkey_enc(
        rk: *mut ::types::raw_types::c_uchar,
        key: *const ::types::raw_types::c_uchar,
        bits: usize,
    ) -> ::types::raw_types::c_int;
}
impl x509_san_other_name__bindgen_ty_1 { # [deprecated] pub unsafe fn hardware_module_name (& mut self) -> * mut x509_san_other_name__bindgen_ty_1__bindgen_ty_1 { & mut self . hardware_module_name } }impl x509_subject_alternative_name__bindgen_ty_1 { # [deprecated] pub unsafe fn other_name (& mut self) -> * mut x509_san_other_name { & mut self . other_name } # [deprecated] pub unsafe fn unstructured_name (& mut self) -> * mut x509_buf { & mut self . unstructured_name } }impl ssl_premaster_secret { # [deprecated] pub unsafe fn dummy (& mut self) -> * mut :: types :: raw_types :: c_uchar { & mut self . dummy } # [deprecated] pub unsafe fn _pms_rsa (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 48usize] { & mut self . _pms_rsa } # [deprecated] pub unsafe fn _pms_dhm (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 1024usize] { & mut self . _pms_dhm } # [deprecated] pub unsafe fn _pms_ecdh (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 66usize] { & mut self . _pms_ecdh } # [deprecated] pub unsafe fn _pms_psk (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 68usize] { & mut self . _pms_psk } # [deprecated] pub unsafe fn _pms_dhe_psk (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 1060usize] { & mut self . _pms_dhe_psk } # [deprecated] pub unsafe fn _pms_rsa_psk (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 84usize] { & mut self . _pms_rsa_psk } # [deprecated] pub unsafe fn _pms_ecdhe_psk (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 102usize] { & mut self . _pms_ecdhe_psk } }use crate::types::*;
