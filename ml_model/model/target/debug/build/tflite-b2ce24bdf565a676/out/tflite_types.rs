/* automatically generated by rust-bindgen 0.69.5 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Default)]
    pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
    impl<T> __IncompleteArrayField<T> {
        #[inline]
        pub const fn new() -> Self {
            __IncompleteArrayField(::std::marker::PhantomData, [])
        }
        #[inline]
        pub fn as_ptr(&self) -> *const T {
            self as *const _ as *const T
        }
        #[inline]
        pub fn as_mut_ptr(&mut self) -> *mut T {
            self as *mut _ as *mut T
        }
        #[inline]
        pub unsafe fn as_slice(&self, len: usize) -> &[T] {
            ::std::slice::from_raw_parts(self.as_ptr(), len)
        }
        #[inline]
        pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
            ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
        }
    }
    impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__IncompleteArrayField")
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type string = [u64; 4usize];
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union aligned_storage_type {
            pub __data: *mut ::std::os::raw::c_uchar,
            pub __align: root::std::aligned_storage_type__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct aligned_storage_type__bindgen_ty_1 {
            pub _address: u8,
        }
        impl Default for aligned_storage_type {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for aligned_storage_type {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "aligned_storage_type {{ union }}")
            }
        }
        pub type __enable_if_t = u8;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_value_t = root::std::false_type;
        pub type __detector_type<_Default> = _Default;
        pub type __detected_or = root::std::__detector;
        pub type __detected_or_t = root::std::__detected_or;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __ptr_traits_elem_1 {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct __ptr_traits_elem {
            pub _address: u8,
        }
        impl Default for __ptr_traits_elem {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits___difference_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct pointer_traits___rebind {
            pub _address: u8,
        }
        impl Default for pointer_traits___rebind {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type pointer_traits_pointer<_Ptr> = _Ptr;
        pub type pointer_traits_difference_type = root::std::__detected_or_t;
        pub type pointer_traits_rebind = root::std::pointer_traits___rebind;
        impl Default for pointer_traits {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        impl<_Iterator> Default for reverse_iterator<_Iterator> {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type<_Tp> = _Tp;
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        impl Default for allocator {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __allocator_traits_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        impl Default for __allocator_traits_base___rebind {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type __allocator_traits_base___pointer = [u8; 0usize];
        pub type __allocator_traits_base___c_pointer = [u8; 0usize];
        pub type __allocator_traits_base___v_pointer = [u8; 0usize];
        pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
        pub type __allocator_traits_base___pocca = [u8; 0usize];
        pub type __allocator_traits_base___pocma = [u8; 0usize];
        pub type __allocator_traits_base___pocs = [u8; 0usize];
        pub type __allocator_traits_base___equal = [u8; 0usize];
        pub type __alloc_rebind = root::std::__allocator_traits_base;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits_pointer = root::std::__detected_or_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        impl Default for allocator_traits__Size {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        pub type allocator_traits_const_pointer = [u8; 0usize];
        pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
        pub type allocator_traits_difference_type = [u8; 0usize];
        pub type allocator_traits_size_type = [u8; 0usize];
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::std::__detected_or_t;
        pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
        pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
        pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct tuple {
            pub _address: u8,
        }
        pub type tuple__Inherited = u8;
        pub type tuple__TCC = u8;
        pub type tuple__ImplicitDefaultCtor = root::std::__enable_if_t;
        pub type tuple__ExplicitDefaultCtor = root::std::__enable_if_t;
        pub type tuple__ImplicitCtor = root::std::__enable_if_t;
        pub type tuple__ExplicitCtor = root::std::__enable_if_t;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct tuple__UseOtherCtor {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __uniq_ptr_impl {
            pub _M_t: root::std::tuple,
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __uniq_ptr_impl__Ptr {
            pub _address: u8,
        }
        pub type __uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
        pub type __uniq_ptr_impl__DeleterConstraint = u8;
        pub type __uniq_ptr_impl_pointer = root::std::__uniq_ptr_impl__Ptr;
        #[repr(C)]
        #[derive(Debug, Default, PartialEq, Eq)]
        pub struct unique_ptr {
            pub _M_t: u8,
        }
        pub type unique_ptr__DeleterConstraint = root::std::__uniq_ptr_impl;
        pub type unique_ptr_pointer = root::std::__uniq_ptr_impl;
        pub type unique_ptr_element_type<_Tp> = _Tp;
        pub type unique_ptr_deleter_type<_Dp> = _Dp;
        pub type unique_ptr___safe_conversion_up = root::std::__and_;
        #[repr(C)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = [u8; 0usize];
        pub type _Vector_base_pointer = [u8; 0usize];
        #[repr(C)]
        pub struct _Vector_base__Vector_impl_data {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        impl Default for _Vector_base__Vector_impl_data {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for _Vector_base__Vector_impl_data {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base__Vector_impl_data {{  }}")
            }
        }
        #[repr(C)]
        pub struct _Vector_base__Vector_impl {
            pub _base_1: root::std::_Vector_base__Vector_impl_data,
        }
        impl Default for _Vector_base__Vector_impl {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for _Vector_base__Vector_impl {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base__Vector_impl {{  }}")
            }
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        impl Default for _Vector_base {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for _Vector_base {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "_Vector_base {{ _M_impl: {:?} }}", self._M_impl)
            }
        }
        #[repr(C)]
        pub struct vector {
            pub _base: root::std::_Vector_base,
        }
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = usize;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct vector__Temporary_value {
            pub _M_this: *mut root::std::vector,
            pub __buf: u8,
        }
        impl Default for vector__Temporary_value {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl Default for vector {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for vector {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "vector {{  }}")
            }
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        impl<_Iterator> Default for __normal_iterator<_Iterator> {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, PartialEq, Eq)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_value_type<_Tp> = _Tp;
        pub type new_allocator_size_type = usize;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        impl Default for __alloc_traits {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TfLiteStatus {
        kTfLiteOk = 0,
        kTfLiteError = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TfLiteExternalContextType {
        kTfLiteEigenContext = 0,
        kTfLiteGemmLowpContext = 1,
        kTfLiteEdgeTpuContext = 2,
        kTfLiteCpuBackendContext = 3,
        kTfLiteMaxExternalContexts = 4,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteExternalContext {
        pub type_: root::TfLiteExternalContextType,
        pub Refresh: ::std::option::Option<
            unsafe extern "C" fn(context: *mut root::TfLiteContext) -> root::TfLiteStatus,
        >,
    }
    impl Default for TfLiteExternalContext {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default)]
    pub struct TfLiteIntArray {
        pub size: ::std::os::raw::c_int,
        pub data: root::__IncompleteArrayField<::std::os::raw::c_int>,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, PartialEq)]
    pub struct TfLiteComplex64 {
        pub re: f32,
        pub im: f32,
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteFloat16 {
        pub data: u16,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TfLiteType {
        kTfLiteNoType = 0,
        kTfLiteFloat32 = 1,
        kTfLiteInt32 = 2,
        kTfLiteUInt8 = 3,
        kTfLiteInt64 = 4,
        kTfLiteString = 5,
        kTfLiteBool = 6,
        kTfLiteInt16 = 7,
        kTfLiteComplex64 = 8,
        kTfLiteInt8 = 9,
        kTfLiteFloat16 = 10,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TfLiteQuantizationType {
        kTfLiteNoQuantization = 0,
        kTfLiteAffineQuantization = 1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteQuantization {
        pub type_: root::TfLiteQuantizationType,
        pub params: *mut ::std::os::raw::c_void,
    }
    impl Default for TfLiteQuantization {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Default, Copy, Clone, PartialEq)]
    pub struct TfLiteQuantizationParams {
        pub scale: f32,
        pub zero_point: i32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union TfLitePtrUnion {
        pub i32_: *mut i32,
        pub i64_: *mut i64,
        pub f: *mut f32,
        pub f16: *mut root::TfLiteFloat16,
        pub raw: *mut ::std::os::raw::c_char,
        pub raw_const: *const ::std::os::raw::c_char,
        pub uint8: *mut u8,
        pub b: *mut bool,
        pub i16_: *mut i16,
        pub c64: *mut root::TfLiteComplex64,
        pub int8: *mut i8,
    }
    impl Default for TfLitePtrUnion {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    impl ::std::fmt::Debug for TfLitePtrUnion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write!(f, "TfLitePtrUnion {{ union }}")
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum TfLiteAllocationType {
        kTfLiteMemNone = 0,
        kTfLiteMmapRo = 1,
        kTfLiteArenaRw = 2,
        kTfLiteArenaRwPersistent = 3,
        kTfLiteDynamic = 4,
    }
    pub type TfLiteBufferHandle = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct TfLiteTensor {
        pub type_: root::TfLiteType,
        pub data: root::TfLitePtrUnion,
        pub dims: *mut root::TfLiteIntArray,
        pub params: root::TfLiteQuantizationParams,
        pub allocation_type: root::TfLiteAllocationType,
        pub bytes: usize,
        pub allocation: *const ::std::os::raw::c_void,
        pub name: *const ::std::os::raw::c_char,
        pub delegate: *mut root::TfLiteDelegate,
        pub buffer_handle: root::TfLiteBufferHandle,
        pub data_is_stale: bool,
        pub is_variable: bool,
        pub quantization: root::TfLiteQuantization,
    }
    impl Default for TfLiteTensor {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    impl ::std::fmt::Debug for TfLiteTensor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            write ! (f , "TfLiteTensor {{ type: {:?}, data: {:?}, dims: {:?}, params: {:?}, allocation_type: {:?}, allocation: {:?}, name: {:?}, delegate: {:?}, buffer_handle: {:?}, data_is_stale: {:?}, is_variable: {:?}, quantization: {:?} }}" , self . type_ , self . data , self . dims , self . params , self . allocation_type , self . allocation , self . name , self . delegate , self . buffer_handle , self . data_is_stale , self . is_variable , self . quantization)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteNode {
        pub inputs: *mut root::TfLiteIntArray,
        pub outputs: *mut root::TfLiteIntArray,
        pub intermediates: *mut root::TfLiteIntArray,
        pub temporaries: *mut root::TfLiteIntArray,
        pub user_data: *mut ::std::os::raw::c_void,
        pub builtin_data: *mut ::std::os::raw::c_void,
        pub custom_initial_data: *const ::std::os::raw::c_void,
        pub custom_initial_data_size: ::std::os::raw::c_int,
        pub delegate: *mut root::TfLiteDelegate,
    }
    impl Default for TfLiteNode {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteContext {
        pub tensors_size: usize,
        pub GetExecutionPlan: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                execution_plan: *mut *mut root::TfLiteIntArray,
            ) -> root::TfLiteStatus,
        >,
        pub tensors: *mut root::TfLiteTensor,
        pub impl_: *mut ::std::os::raw::c_void,
        pub ResizeTensor: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::TfLiteContext,
                tensor: *mut root::TfLiteTensor,
                new_size: *mut root::TfLiteIntArray,
            ) -> root::TfLiteStatus,
        >,
        pub ReportError: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::TfLiteContext,
                msg: *const ::std::os::raw::c_char,
                ...
            ),
        >,
        pub AddTensors: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::TfLiteContext,
                tensors_to_add: ::std::os::raw::c_int,
                first_new_tensor_index: *mut ::std::os::raw::c_int,
            ) -> root::TfLiteStatus,
        >,
        pub GetNodeAndRegistration: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::TfLiteContext,
                node_index: ::std::os::raw::c_int,
                node: *mut *mut root::TfLiteNode,
                registration: *mut *mut root::TfLiteRegistration,
            ) -> root::TfLiteStatus,
        >,
        pub ReplaceNodeSubsetsWithDelegateKernels: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::TfLiteContext,
                registration: root::TfLiteRegistration,
                nodes_to_replace: *const root::TfLiteIntArray,
                delegate: *mut root::TfLiteDelegate,
            ) -> root::TfLiteStatus,
        >,
        pub recommended_num_threads: ::std::os::raw::c_int,
        pub GetExternalContext: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::TfLiteContext,
                arg2: root::TfLiteExternalContextType,
            ) -> *mut root::TfLiteExternalContext,
        >,
        pub SetExternalContext: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::TfLiteContext,
                arg2: root::TfLiteExternalContextType,
                arg3: *mut root::TfLiteExternalContext,
            ),
        >,
        pub allow_fp32_relax_to_fp16: bool,
        pub profiler: *mut ::std::os::raw::c_void,
    }
    impl Default for TfLiteContext {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteRegistration {
        pub init: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                buffer: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        pub free: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                buffer: *mut ::std::os::raw::c_void,
            ),
        >,
        pub prepare: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                node: *mut root::TfLiteNode,
            ) -> root::TfLiteStatus,
        >,
        pub invoke: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                node: *mut root::TfLiteNode,
            ) -> root::TfLiteStatus,
        >,
        pub profiling_string: ::std::option::Option<
            unsafe extern "C" fn(
                context: *const root::TfLiteContext,
                node: *const root::TfLiteNode,
            ) -> *const ::std::os::raw::c_char,
        >,
        pub builtin_code: i32,
        pub custom_name: *const ::std::os::raw::c_char,
        pub version: ::std::os::raw::c_int,
    }
    impl Default for TfLiteRegistration {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    pub struct TfLiteDelegate {
        pub data_: *mut ::std::os::raw::c_void,
        pub Prepare: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                delegate: *mut root::TfLiteDelegate,
            ) -> root::TfLiteStatus,
        >,
        pub CopyFromBufferHandle: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                delegate: *mut root::TfLiteDelegate,
                buffer_handle: root::TfLiteBufferHandle,
                tensor: *mut root::TfLiteTensor,
            ) -> root::TfLiteStatus,
        >,
        pub CopyToBufferHandle: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                delegate: *mut root::TfLiteDelegate,
                buffer_handle: root::TfLiteBufferHandle,
                tensor: *mut root::TfLiteTensor,
            ) -> root::TfLiteStatus,
        >,
        pub FreeBufferHandle: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut root::TfLiteContext,
                delegate: *mut root::TfLiteDelegate,
                handle: *mut root::TfLiteBufferHandle,
            ),
        >,
        pub flags: i64,
    }
    impl Default for TfLiteDelegate {
        fn default() -> Self {
            let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
            unsafe {
                ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                s.assume_init()
            }
        }
    }
    pub mod tflite {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[doc = " An interpreter for a graph of nodes that input and output from tensors.\n Each node of the graph processes a set of input tensors and produces a\n set of output Tensors. All inputs/output tensors are referenced by index.\n\n Usage:\n\n <pre><code>\n // Create basic model\n Interpreter foo(2, 1);\n foo.SetTensorParametersReadWrite(0, ...);\n foo.SetTensorParametersReadOnly(1, ...);\n foo.SetNodeParameters(0, ...)\n // Resize input array to 1 length.\n foo.ResizeInputTensor(0, 1);\n foo.AllocateTensors();\n // Install array data\n foo.typed_tensor<float>(0)[0] = 3;\n foo.Invoke();\n foo.typed_tensor<float>(0)[0] = 4;\n foo.Invoke();\n // Resize input array and set data.\n foo.ResizeInputTensor(0, 2);\n foo.AllocateTensors();\n foo.typed_tensor<float>(0)[0] = 4;\n foo.typed_tensor<float>(0)[1] = 8;\n foo.Invoke();\n </code></pre>\n"]
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Interpreter {
            pub _bindgen_opaque_blob: [u64; 21usize],
        }
        impl root::tflite::TensorType {
            pub const TensorType_MIN: root::tflite::TensorType = TensorType::TensorType_FLOAT32;
        }
        impl root::tflite::TensorType {
            pub const TensorType_MAX: root::tflite::TensorType = TensorType::TensorType_INT8;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TensorType {
            TensorType_FLOAT32 = 0,
            TensorType_FLOAT16 = 1,
            TensorType_INT32 = 2,
            TensorType_UINT8 = 3,
            TensorType_INT64 = 4,
            TensorType_STRING = 5,
            TensorType_BOOL = 6,
            TensorType_INT16 = 7,
            TensorType_COMPLEX64 = 8,
            TensorType_INT8 = 9,
        }
        impl root::tflite::QuantizationDetails {
            pub const QuantizationDetails_MIN: root::tflite::QuantizationDetails =
                QuantizationDetails::QuantizationDetails_NONE;
        }
        impl root::tflite::QuantizationDetails {
            pub const QuantizationDetails_MAX: root::tflite::QuantizationDetails =
                QuantizationDetails::QuantizationDetails_CustomQuantization;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum QuantizationDetails {
            QuantizationDetails_NONE = 0,
            QuantizationDetails_CustomQuantization = 1,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct QuantizationDetailsUnion {
            pub type_: root::tflite::QuantizationDetails,
            pub value: *mut ::std::os::raw::c_void,
        }
        impl Default for QuantizationDetailsUnion {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl root::tflite::BuiltinOperator {
            pub const BuiltinOperator_MIN: root::tflite::BuiltinOperator =
                BuiltinOperator::BuiltinOperator_ADD;
        }
        impl root::tflite::BuiltinOperator {
            pub const BuiltinOperator_MAX: root::tflite::BuiltinOperator =
                BuiltinOperator::BuiltinOperator_WHILE;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BuiltinOperator {
            BuiltinOperator_ADD = 0,
            BuiltinOperator_AVERAGE_POOL_2D = 1,
            BuiltinOperator_CONCATENATION = 2,
            BuiltinOperator_CONV_2D = 3,
            BuiltinOperator_DEPTHWISE_CONV_2D = 4,
            BuiltinOperator_DEPTH_TO_SPACE = 5,
            BuiltinOperator_DEQUANTIZE = 6,
            BuiltinOperator_EMBEDDING_LOOKUP = 7,
            BuiltinOperator_FLOOR = 8,
            BuiltinOperator_FULLY_CONNECTED = 9,
            BuiltinOperator_HASHTABLE_LOOKUP = 10,
            BuiltinOperator_L2_NORMALIZATION = 11,
            BuiltinOperator_L2_POOL_2D = 12,
            BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
            BuiltinOperator_LOGISTIC = 14,
            BuiltinOperator_LSH_PROJECTION = 15,
            BuiltinOperator_LSTM = 16,
            BuiltinOperator_MAX_POOL_2D = 17,
            BuiltinOperator_MUL = 18,
            BuiltinOperator_RELU = 19,
            BuiltinOperator_RELU_N1_TO_1 = 20,
            BuiltinOperator_RELU6 = 21,
            BuiltinOperator_RESHAPE = 22,
            BuiltinOperator_RESIZE_BILINEAR = 23,
            BuiltinOperator_RNN = 24,
            BuiltinOperator_SOFTMAX = 25,
            BuiltinOperator_SPACE_TO_DEPTH = 26,
            BuiltinOperator_SVDF = 27,
            BuiltinOperator_TANH = 28,
            BuiltinOperator_CONCAT_EMBEDDINGS = 29,
            BuiltinOperator_SKIP_GRAM = 30,
            BuiltinOperator_CALL = 31,
            BuiltinOperator_CUSTOM = 32,
            BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
            BuiltinOperator_PAD = 34,
            BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
            BuiltinOperator_GATHER = 36,
            BuiltinOperator_BATCH_TO_SPACE_ND = 37,
            BuiltinOperator_SPACE_TO_BATCH_ND = 38,
            BuiltinOperator_TRANSPOSE = 39,
            BuiltinOperator_MEAN = 40,
            BuiltinOperator_SUB = 41,
            BuiltinOperator_DIV = 42,
            BuiltinOperator_SQUEEZE = 43,
            BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
            BuiltinOperator_STRIDED_SLICE = 45,
            BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
            BuiltinOperator_EXP = 47,
            BuiltinOperator_TOPK_V2 = 48,
            BuiltinOperator_SPLIT = 49,
            BuiltinOperator_LOG_SOFTMAX = 50,
            BuiltinOperator_DELEGATE = 51,
            BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
            BuiltinOperator_CAST = 53,
            BuiltinOperator_PRELU = 54,
            BuiltinOperator_MAXIMUM = 55,
            BuiltinOperator_ARG_MAX = 56,
            BuiltinOperator_MINIMUM = 57,
            BuiltinOperator_LESS = 58,
            BuiltinOperator_NEG = 59,
            BuiltinOperator_PADV2 = 60,
            BuiltinOperator_GREATER = 61,
            BuiltinOperator_GREATER_EQUAL = 62,
            BuiltinOperator_LESS_EQUAL = 63,
            BuiltinOperator_SELECT = 64,
            BuiltinOperator_SLICE = 65,
            BuiltinOperator_SIN = 66,
            BuiltinOperator_TRANSPOSE_CONV = 67,
            BuiltinOperator_SPARSE_TO_DENSE = 68,
            BuiltinOperator_TILE = 69,
            BuiltinOperator_EXPAND_DIMS = 70,
            BuiltinOperator_EQUAL = 71,
            BuiltinOperator_NOT_EQUAL = 72,
            BuiltinOperator_LOG = 73,
            BuiltinOperator_SUM = 74,
            BuiltinOperator_SQRT = 75,
            BuiltinOperator_RSQRT = 76,
            BuiltinOperator_SHAPE = 77,
            BuiltinOperator_POW = 78,
            BuiltinOperator_ARG_MIN = 79,
            BuiltinOperator_FAKE_QUANT = 80,
            BuiltinOperator_REDUCE_PROD = 81,
            BuiltinOperator_REDUCE_MAX = 82,
            BuiltinOperator_PACK = 83,
            BuiltinOperator_LOGICAL_OR = 84,
            BuiltinOperator_ONE_HOT = 85,
            BuiltinOperator_LOGICAL_AND = 86,
            BuiltinOperator_LOGICAL_NOT = 87,
            BuiltinOperator_UNPACK = 88,
            BuiltinOperator_REDUCE_MIN = 89,
            BuiltinOperator_FLOOR_DIV = 90,
            BuiltinOperator_REDUCE_ANY = 91,
            BuiltinOperator_SQUARE = 92,
            BuiltinOperator_ZEROS_LIKE = 93,
            BuiltinOperator_FILL = 94,
            BuiltinOperator_FLOOR_MOD = 95,
            BuiltinOperator_RANGE = 96,
            BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
            BuiltinOperator_LEAKY_RELU = 98,
            BuiltinOperator_SQUARED_DIFFERENCE = 99,
            BuiltinOperator_MIRROR_PAD = 100,
            BuiltinOperator_ABS = 101,
            BuiltinOperator_SPLIT_V = 102,
            BuiltinOperator_UNIQUE = 103,
            BuiltinOperator_CEIL = 104,
            BuiltinOperator_REVERSE_V2 = 105,
            BuiltinOperator_ADD_N = 106,
            BuiltinOperator_GATHER_ND = 107,
            BuiltinOperator_COS = 108,
            BuiltinOperator_WHERE = 109,
            BuiltinOperator_RANK = 110,
            BuiltinOperator_ELU = 111,
            BuiltinOperator_REVERSE_SEQUENCE = 112,
            BuiltinOperator_MATRIX_DIAG = 113,
            BuiltinOperator_QUANTIZE = 114,
            BuiltinOperator_MATRIX_SET_DIAG = 115,
            BuiltinOperator_ROUND = 116,
            BuiltinOperator_HARD_SWISH = 117,
            BuiltinOperator_IF = 118,
            BuiltinOperator_WHILE = 119,
        }
        impl root::tflite::BuiltinOptions {
            pub const BuiltinOptions_MIN: root::tflite::BuiltinOptions =
                BuiltinOptions::BuiltinOptions_NONE;
        }
        impl root::tflite::BuiltinOptions {
            pub const BuiltinOptions_MAX: root::tflite::BuiltinOptions =
                BuiltinOptions::BuiltinOptions_DepthToSpaceOptions;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BuiltinOptions {
            BuiltinOptions_NONE = 0,
            BuiltinOptions_Conv2DOptions = 1,
            BuiltinOptions_DepthwiseConv2DOptions = 2,
            BuiltinOptions_ConcatEmbeddingsOptions = 3,
            BuiltinOptions_LSHProjectionOptions = 4,
            BuiltinOptions_Pool2DOptions = 5,
            BuiltinOptions_SVDFOptions = 6,
            BuiltinOptions_RNNOptions = 7,
            BuiltinOptions_FullyConnectedOptions = 8,
            BuiltinOptions_SoftmaxOptions = 9,
            BuiltinOptions_ConcatenationOptions = 10,
            BuiltinOptions_AddOptions = 11,
            BuiltinOptions_L2NormOptions = 12,
            BuiltinOptions_LocalResponseNormalizationOptions = 13,
            BuiltinOptions_LSTMOptions = 14,
            BuiltinOptions_ResizeBilinearOptions = 15,
            BuiltinOptions_CallOptions = 16,
            BuiltinOptions_ReshapeOptions = 17,
            BuiltinOptions_SkipGramOptions = 18,
            BuiltinOptions_SpaceToDepthOptions = 19,
            BuiltinOptions_EmbeddingLookupSparseOptions = 20,
            BuiltinOptions_MulOptions = 21,
            BuiltinOptions_PadOptions = 22,
            BuiltinOptions_GatherOptions = 23,
            BuiltinOptions_BatchToSpaceNDOptions = 24,
            BuiltinOptions_SpaceToBatchNDOptions = 25,
            BuiltinOptions_TransposeOptions = 26,
            BuiltinOptions_ReducerOptions = 27,
            BuiltinOptions_SubOptions = 28,
            BuiltinOptions_DivOptions = 29,
            BuiltinOptions_SqueezeOptions = 30,
            BuiltinOptions_SequenceRNNOptions = 31,
            BuiltinOptions_StridedSliceOptions = 32,
            BuiltinOptions_ExpOptions = 33,
            BuiltinOptions_TopKV2Options = 34,
            BuiltinOptions_SplitOptions = 35,
            BuiltinOptions_LogSoftmaxOptions = 36,
            BuiltinOptions_CastOptions = 37,
            BuiltinOptions_DequantizeOptions = 38,
            BuiltinOptions_MaximumMinimumOptions = 39,
            BuiltinOptions_ArgMaxOptions = 40,
            BuiltinOptions_LessOptions = 41,
            BuiltinOptions_NegOptions = 42,
            BuiltinOptions_PadV2Options = 43,
            BuiltinOptions_GreaterOptions = 44,
            BuiltinOptions_GreaterEqualOptions = 45,
            BuiltinOptions_LessEqualOptions = 46,
            BuiltinOptions_SelectOptions = 47,
            BuiltinOptions_SliceOptions = 48,
            BuiltinOptions_TransposeConvOptions = 49,
            BuiltinOptions_SparseToDenseOptions = 50,
            BuiltinOptions_TileOptions = 51,
            BuiltinOptions_ExpandDimsOptions = 52,
            BuiltinOptions_EqualOptions = 53,
            BuiltinOptions_NotEqualOptions = 54,
            BuiltinOptions_ShapeOptions = 55,
            BuiltinOptions_PowOptions = 56,
            BuiltinOptions_ArgMinOptions = 57,
            BuiltinOptions_FakeQuantOptions = 58,
            BuiltinOptions_PackOptions = 59,
            BuiltinOptions_LogicalOrOptions = 60,
            BuiltinOptions_OneHotOptions = 61,
            BuiltinOptions_LogicalAndOptions = 62,
            BuiltinOptions_LogicalNotOptions = 63,
            BuiltinOptions_UnpackOptions = 64,
            BuiltinOptions_FloorDivOptions = 65,
            BuiltinOptions_SquareOptions = 66,
            BuiltinOptions_ZerosLikeOptions = 67,
            BuiltinOptions_FillOptions = 68,
            BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
            BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
            BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
            BuiltinOptions_FloorModOptions = 72,
            BuiltinOptions_RangeOptions = 73,
            BuiltinOptions_ResizeNearestNeighborOptions = 74,
            BuiltinOptions_LeakyReluOptions = 75,
            BuiltinOptions_SquaredDifferenceOptions = 76,
            BuiltinOptions_MirrorPadOptions = 77,
            BuiltinOptions_AbsOptions = 78,
            BuiltinOptions_SplitVOptions = 79,
            BuiltinOptions_UniqueOptions = 80,
            BuiltinOptions_ReverseV2Options = 81,
            BuiltinOptions_AddNOptions = 82,
            BuiltinOptions_GatherNdOptions = 83,
            BuiltinOptions_CosOptions = 84,
            BuiltinOptions_WhereOptions = 85,
            BuiltinOptions_RankOptions = 86,
            BuiltinOptions_ReverseSequenceOptions = 87,
            BuiltinOptions_MatrixDiagOptions = 88,
            BuiltinOptions_QuantizeOptions = 89,
            BuiltinOptions_MatrixSetDiagOptions = 90,
            BuiltinOptions_HardSwishOptions = 91,
            BuiltinOptions_IfOptions = 92,
            BuiltinOptions_WhileOptions = 93,
            BuiltinOptions_DepthToSpaceOptions = 94,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct BuiltinOptionsUnion {
            pub type_: root::tflite::BuiltinOptions,
            pub value: *mut ::std::os::raw::c_void,
        }
        impl Default for BuiltinOptionsUnion {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl root::tflite::Padding {
            pub const Padding_MIN: root::tflite::Padding = Padding::Padding_SAME;
        }
        impl root::tflite::Padding {
            pub const Padding_MAX: root::tflite::Padding = Padding::Padding_VALID;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Padding {
            Padding_SAME = 0,
            Padding_VALID = 1,
        }
        impl root::tflite::ActivationFunctionType {
            pub const ActivationFunctionType_MIN: root::tflite::ActivationFunctionType =
                ActivationFunctionType::ActivationFunctionType_NONE;
        }
        impl root::tflite::ActivationFunctionType {
            pub const ActivationFunctionType_MAX: root::tflite::ActivationFunctionType =
                ActivationFunctionType::ActivationFunctionType_SIGN_BIT;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ActivationFunctionType {
            ActivationFunctionType_NONE = 0,
            ActivationFunctionType_RELU = 1,
            ActivationFunctionType_RELU_N1_TO_1 = 2,
            ActivationFunctionType_RELU6 = 3,
            ActivationFunctionType_TANH = 4,
            ActivationFunctionType_SIGN_BIT = 5,
        }
        impl root::tflite::LSHProjectionType {
            pub const LSHProjectionType_MIN: root::tflite::LSHProjectionType =
                LSHProjectionType::LSHProjectionType_UNKNOWN;
        }
        impl root::tflite::LSHProjectionType {
            pub const LSHProjectionType_MAX: root::tflite::LSHProjectionType =
                LSHProjectionType::LSHProjectionType_DENSE;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LSHProjectionType {
            LSHProjectionType_UNKNOWN = 0,
            LSHProjectionType_SPARSE = 1,
            LSHProjectionType_DENSE = 2,
        }
        impl root::tflite::FullyConnectedOptionsWeightsFormat {
            pub const FullyConnectedOptionsWeightsFormat_MIN:
                root::tflite::FullyConnectedOptionsWeightsFormat =
                FullyConnectedOptionsWeightsFormat::FullyConnectedOptionsWeightsFormat_DEFAULT;
        }
        impl root::tflite::FullyConnectedOptionsWeightsFormat {
            pub const FullyConnectedOptionsWeightsFormat_MAX : root :: tflite :: FullyConnectedOptionsWeightsFormat = FullyConnectedOptionsWeightsFormat :: FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 ;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum FullyConnectedOptionsWeightsFormat {
            FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
            FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
        }
        impl root::tflite::LSTMKernelType {
            pub const LSTMKernelType_MIN: root::tflite::LSTMKernelType =
                LSTMKernelType::LSTMKernelType_FULL;
        }
        impl root::tflite::LSTMKernelType {
            pub const LSTMKernelType_MAX: root::tflite::LSTMKernelType =
                LSTMKernelType::LSTMKernelType_BASIC;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LSTMKernelType {
            LSTMKernelType_FULL = 0,
            LSTMKernelType_BASIC = 1,
        }
        impl root::tflite::CombinerType {
            pub const CombinerType_MIN: root::tflite::CombinerType = CombinerType::CombinerType_SUM;
        }
        impl root::tflite::CombinerType {
            pub const CombinerType_MAX: root::tflite::CombinerType =
                CombinerType::CombinerType_SQRTN;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CombinerType {
            CombinerType_SUM = 0,
            CombinerType_MEAN = 1,
            CombinerType_SQRTN = 2,
        }
        impl root::tflite::MirrorPadMode {
            pub const MirrorPadMode_MIN: root::tflite::MirrorPadMode =
                MirrorPadMode::MirrorPadMode_REFLECT;
        }
        impl root::tflite::MirrorPadMode {
            pub const MirrorPadMode_MAX: root::tflite::MirrorPadMode =
                MirrorPadMode::MirrorPadMode_SYMMETRIC;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MirrorPadMode {
            MirrorPadMode_REFLECT = 0,
            MirrorPadMode_SYMMETRIC = 1,
        }
        impl root::tflite::CustomOptionsFormat {
            pub const CustomOptionsFormat_MIN: root::tflite::CustomOptionsFormat =
                CustomOptionsFormat::CustomOptionsFormat_FLEXBUFFERS;
        }
        impl root::tflite::CustomOptionsFormat {
            pub const CustomOptionsFormat_MAX: root::tflite::CustomOptionsFormat =
                CustomOptionsFormat::CustomOptionsFormat_FLEXBUFFERS;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CustomOptionsFormat {
            CustomOptionsFormat_FLEXBUFFERS = 0,
        }
        #[repr(C)]
        pub struct QuantizationParametersT {
            pub _base: root::flatbuffers::NativeTable,
            pub min: root::std::vector,
            pub max: root::std::vector,
            pub scale: root::std::vector,
            pub zero_point: root::std::vector,
            pub details: root::tflite::QuantizationDetailsUnion,
            pub quantized_dimension: i32,
        }
        impl Default for QuantizationParametersT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for QuantizationParametersT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write ! (f , "QuantizationParametersT {{ min: {:?}, max: {:?}, scale: {:?}, zero_point: {:?}, details: {:?} }}" , self . min , self . max , self . scale , self . zero_point , self . details)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct QuantizationParameters {
            pub _base: root::flatbuffers::Table,
        }
        pub type QuantizationParameters_NativeTableType = root::tflite::QuantizationParametersT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum QuantizationParameters_FlatBuffersVTableOffset {
            VT_MIN = 4,
            VT_MAX = 6,
            VT_SCALE = 8,
            VT_ZERO_POINT = 10,
            VT_DETAILS_TYPE = 12,
            VT_DETAILS = 14,
            VT_QUANTIZED_DIMENSION = 16,
        }
        #[repr(C)]
        pub struct TensorT {
            pub _base: root::flatbuffers::NativeTable,
            pub shape: root::std::vector,
            pub type_: root::tflite::TensorType,
            pub buffer: u32,
            pub name: root::std::string,
            pub quantization: root::std::unique_ptr,
            pub is_variable: bool,
        }
        impl Default for TensorT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for TensorT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "TensorT {{ shape: {:?}, type: {:?}, quantization: {:?}, is_variable: {:?} }}",
                    self.shape, self.type_, self.quantization, self.is_variable
                )
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Tensor {
            pub _base: root::flatbuffers::Table,
        }
        pub type Tensor_NativeTableType = root::tflite::TensorT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Tensor_FlatBuffersVTableOffset {
            VT_SHAPE = 4,
            VT_TYPE = 6,
            VT_BUFFER = 8,
            VT_NAME = 10,
            VT_QUANTIZATION = 12,
            VT_IS_VARIABLE = 14,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct Conv2DOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub padding: root::tflite::Padding,
            pub stride_w: i32,
            pub stride_h: i32,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
            pub dilation_w_factor: i32,
            pub dilation_h_factor: i32,
        }
        impl Default for Conv2DOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Conv2DOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type Conv2DOptions_NativeTableType = root::tflite::Conv2DOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Conv2DOptions_FlatBuffersVTableOffset {
            VT_PADDING = 4,
            VT_STRIDE_W = 6,
            VT_STRIDE_H = 8,
            VT_FUSED_ACTIVATION_FUNCTION = 10,
            VT_DILATION_W_FACTOR = 12,
            VT_DILATION_H_FACTOR = 14,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct Pool2DOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub padding: root::tflite::Padding,
            pub stride_w: i32,
            pub stride_h: i32,
            pub filter_width: i32,
            pub filter_height: i32,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for Pool2DOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Pool2DOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type Pool2DOptions_NativeTableType = root::tflite::Pool2DOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Pool2DOptions_FlatBuffersVTableOffset {
            VT_PADDING = 4,
            VT_STRIDE_W = 6,
            VT_STRIDE_H = 8,
            VT_FILTER_WIDTH = 10,
            VT_FILTER_HEIGHT = 12,
            VT_FUSED_ACTIVATION_FUNCTION = 14,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct DepthwiseConv2DOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub padding: root::tflite::Padding,
            pub stride_w: i32,
            pub stride_h: i32,
            pub depth_multiplier: i32,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
            pub dilation_w_factor: i32,
            pub dilation_h_factor: i32,
        }
        impl Default for DepthwiseConv2DOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct DepthwiseConv2DOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type DepthwiseConv2DOptions_NativeTableType = root::tflite::DepthwiseConv2DOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DepthwiseConv2DOptions_FlatBuffersVTableOffset {
            VT_PADDING = 4,
            VT_STRIDE_W = 6,
            VT_STRIDE_H = 8,
            VT_DEPTH_MULTIPLIER = 10,
            VT_FUSED_ACTIVATION_FUNCTION = 12,
            VT_DILATION_W_FACTOR = 14,
            VT_DILATION_H_FACTOR = 16,
        }
        #[repr(C)]
        pub struct ConcatEmbeddingsOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub num_channels: i32,
            pub num_columns_per_channel: root::std::vector,
            pub embedding_dim_per_channel: root::std::vector,
        }
        impl Default for ConcatEmbeddingsOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for ConcatEmbeddingsOptionsT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write ! (f , "ConcatEmbeddingsOptionsT {{ num_columns_per_channel: {:?}, embedding_dim_per_channel: {:?} }}" , self . num_columns_per_channel , self . embedding_dim_per_channel)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ConcatEmbeddingsOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ConcatEmbeddingsOptions_NativeTableType = root::tflite::ConcatEmbeddingsOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ConcatEmbeddingsOptions_FlatBuffersVTableOffset {
            VT_NUM_CHANNELS = 4,
            VT_NUM_COLUMNS_PER_CHANNEL = 6,
            VT_EMBEDDING_DIM_PER_CHANNEL = 8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct LSHProjectionOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub type_: root::tflite::LSHProjectionType,
        }
        impl Default for LSHProjectionOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LSHProjectionOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LSHProjectionOptions_NativeTableType = root::tflite::LSHProjectionOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LSHProjectionOptions_FlatBuffersVTableOffset {
            VT_TYPE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SVDFOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub rank: i32,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for SVDFOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SVDFOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SVDFOptions_NativeTableType = root::tflite::SVDFOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SVDFOptions_FlatBuffersVTableOffset {
            VT_RANK = 4,
            VT_FUSED_ACTIVATION_FUNCTION = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct RNNOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for RNNOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct RNNOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type RNNOptions_NativeTableType = root::tflite::RNNOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RNNOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SequenceRNNOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub time_major: bool,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for SequenceRNNOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SequenceRNNOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SequenceRNNOptions_NativeTableType = root::tflite::SequenceRNNOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SequenceRNNOptions_FlatBuffersVTableOffset {
            VT_TIME_MAJOR = 4,
            VT_FUSED_ACTIVATION_FUNCTION = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct BidirectionalSequenceRNNOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub time_major: bool,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
            pub merge_outputs: bool,
        }
        impl Default for BidirectionalSequenceRNNOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct BidirectionalSequenceRNNOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type BidirectionalSequenceRNNOptions_NativeTableType =
            root::tflite::BidirectionalSequenceRNNOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BidirectionalSequenceRNNOptions_FlatBuffersVTableOffset {
            VT_TIME_MAJOR = 4,
            VT_FUSED_ACTIVATION_FUNCTION = 6,
            VT_MERGE_OUTPUTS = 8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct FullyConnectedOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
            pub weights_format: root::tflite::FullyConnectedOptionsWeightsFormat,
            pub keep_num_dims: bool,
        }
        impl Default for FullyConnectedOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct FullyConnectedOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type FullyConnectedOptions_NativeTableType = root::tflite::FullyConnectedOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum FullyConnectedOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
            VT_WEIGHTS_FORMAT = 6,
            VT_KEEP_NUM_DIMS = 8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SoftmaxOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub beta: f32,
        }
        impl Default for SoftmaxOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SoftmaxOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SoftmaxOptions_NativeTableType = root::tflite::SoftmaxOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SoftmaxOptions_FlatBuffersVTableOffset {
            VT_BETA = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ConcatenationOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub axis: i32,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for ConcatenationOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ConcatenationOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ConcatenationOptions_NativeTableType = root::tflite::ConcatenationOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ConcatenationOptions_FlatBuffersVTableOffset {
            VT_AXIS = 4,
            VT_FUSED_ACTIVATION_FUNCTION = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct AddOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for AddOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct AddOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type AddOptions_NativeTableType = root::tflite::AddOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AddOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct MulOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for MulOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct MulOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type MulOptions_NativeTableType = root::tflite::MulOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MulOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct L2NormOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for L2NormOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct L2NormOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type L2NormOptions_NativeTableType = root::tflite::L2NormOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum L2NormOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LocalResponseNormalizationOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub radius: i32,
            pub bias: f32,
            pub alpha: f32,
            pub beta: f32,
        }
        impl Default for LocalResponseNormalizationOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LocalResponseNormalizationOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LocalResponseNormalizationOptions_NativeTableType =
            root::tflite::LocalResponseNormalizationOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LocalResponseNormalizationOptions_FlatBuffersVTableOffset {
            VT_RADIUS = 4,
            VT_BIAS = 6,
            VT_ALPHA = 8,
            VT_BETA = 10,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LSTMOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
            pub cell_clip: f32,
            pub proj_clip: f32,
            pub kernel_type: root::tflite::LSTMKernelType,
        }
        impl Default for LSTMOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LSTMOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LSTMOptions_NativeTableType = root::tflite::LSTMOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LSTMOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
            VT_CELL_CLIP = 6,
            VT_PROJ_CLIP = 8,
            VT_KERNEL_TYPE = 10,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct UnidirectionalSequenceLSTMOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
            pub cell_clip: f32,
            pub proj_clip: f32,
            pub time_major: bool,
        }
        impl Default for UnidirectionalSequenceLSTMOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct UnidirectionalSequenceLSTMOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type UnidirectionalSequenceLSTMOptions_NativeTableType =
            root::tflite::UnidirectionalSequenceLSTMOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum UnidirectionalSequenceLSTMOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
            VT_CELL_CLIP = 6,
            VT_PROJ_CLIP = 8,
            VT_TIME_MAJOR = 10,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct BidirectionalSequenceLSTMOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
            pub cell_clip: f32,
            pub proj_clip: f32,
            pub merge_outputs: bool,
            pub time_major: bool,
        }
        impl Default for BidirectionalSequenceLSTMOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct BidirectionalSequenceLSTMOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type BidirectionalSequenceLSTMOptions_NativeTableType =
            root::tflite::BidirectionalSequenceLSTMOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BidirectionalSequenceLSTMOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
            VT_CELL_CLIP = 6,
            VT_PROJ_CLIP = 8,
            VT_MERGE_OUTPUTS = 10,
            VT_TIME_MAJOR = 12,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ResizeBilinearOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub align_corners: bool,
        }
        impl Default for ResizeBilinearOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ResizeBilinearOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ResizeBilinearOptions_NativeTableType = root::tflite::ResizeBilinearOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ResizeBilinearOptions_FlatBuffersVTableOffset {
            VT_ALIGN_CORNERS = 8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ResizeNearestNeighborOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub align_corners: bool,
        }
        impl Default for ResizeNearestNeighborOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ResizeNearestNeighborOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ResizeNearestNeighborOptions_NativeTableType =
            root::tflite::ResizeNearestNeighborOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ResizeNearestNeighborOptions_FlatBuffersVTableOffset {
            VT_ALIGN_CORNERS = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct CallOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub subgraph: u32,
        }
        impl Default for CallOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct CallOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type CallOptions_NativeTableType = root::tflite::CallOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CallOptions_FlatBuffersVTableOffset {
            VT_SUBGRAPH = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct PadOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for PadOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct PadOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type PadOptions_NativeTableType = root::tflite::PadOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct PadV2OptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for PadV2OptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct PadV2Options {
            pub _base: root::flatbuffers::Table,
        }
        pub type PadV2Options_NativeTableType = root::tflite::PadV2OptionsT;
        #[repr(C)]
        pub struct ReshapeOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub new_shape: root::std::vector,
        }
        impl Default for ReshapeOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for ReshapeOptionsT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "ReshapeOptionsT {{ new_shape: {:?} }}", self.new_shape)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ReshapeOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ReshapeOptions_NativeTableType = root::tflite::ReshapeOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ReshapeOptions_FlatBuffersVTableOffset {
            VT_NEW_SHAPE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SpaceToBatchNDOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for SpaceToBatchNDOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SpaceToBatchNDOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SpaceToBatchNDOptions_NativeTableType = root::tflite::SpaceToBatchNDOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct BatchToSpaceNDOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for BatchToSpaceNDOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct BatchToSpaceNDOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type BatchToSpaceNDOptions_NativeTableType = root::tflite::BatchToSpaceNDOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SkipGramOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub ngram_size: i32,
            pub max_skip_size: i32,
            pub include_all_ngrams: bool,
        }
        impl Default for SkipGramOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SkipGramOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SkipGramOptions_NativeTableType = root::tflite::SkipGramOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SkipGramOptions_FlatBuffersVTableOffset {
            VT_NGRAM_SIZE = 4,
            VT_MAX_SKIP_SIZE = 6,
            VT_INCLUDE_ALL_NGRAMS = 8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SpaceToDepthOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub block_size: i32,
        }
        impl Default for SpaceToDepthOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SpaceToDepthOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SpaceToDepthOptions_NativeTableType = root::tflite::SpaceToDepthOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SpaceToDepthOptions_FlatBuffersVTableOffset {
            VT_BLOCK_SIZE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct DepthToSpaceOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub block_size: i32,
        }
        impl Default for DepthToSpaceOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct DepthToSpaceOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type DepthToSpaceOptions_NativeTableType = root::tflite::DepthToSpaceOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DepthToSpaceOptions_FlatBuffersVTableOffset {
            VT_BLOCK_SIZE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SubOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for SubOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SubOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SubOptions_NativeTableType = root::tflite::SubOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SubOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct DivOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub fused_activation_function: root::tflite::ActivationFunctionType,
        }
        impl Default for DivOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct DivOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type DivOptions_NativeTableType = root::tflite::DivOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DivOptions_FlatBuffersVTableOffset {
            VT_FUSED_ACTIVATION_FUNCTION = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct TopKV2OptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for TopKV2OptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct TopKV2Options {
            pub _base: root::flatbuffers::Table,
        }
        pub type TopKV2Options_NativeTableType = root::tflite::TopKV2OptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct EmbeddingLookupSparseOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub combiner: root::tflite::CombinerType,
        }
        impl Default for EmbeddingLookupSparseOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct EmbeddingLookupSparseOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type EmbeddingLookupSparseOptions_NativeTableType =
            root::tflite::EmbeddingLookupSparseOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum EmbeddingLookupSparseOptions_FlatBuffersVTableOffset {
            VT_COMBINER = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct GatherOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub axis: i32,
        }
        impl Default for GatherOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct GatherOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type GatherOptions_NativeTableType = root::tflite::GatherOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GatherOptions_FlatBuffersVTableOffset {
            VT_AXIS = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct TransposeOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for TransposeOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct TransposeOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type TransposeOptions_NativeTableType = root::tflite::TransposeOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ExpOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for ExpOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ExpOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ExpOptions_NativeTableType = root::tflite::ExpOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct CosOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for CosOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct CosOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type CosOptions_NativeTableType = root::tflite::CosOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ReducerOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub keep_dims: bool,
        }
        impl Default for ReducerOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ReducerOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ReducerOptions_NativeTableType = root::tflite::ReducerOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ReducerOptions_FlatBuffersVTableOffset {
            VT_KEEP_DIMS = 4,
        }
        #[repr(C)]
        pub struct SqueezeOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub squeeze_dims: root::std::vector,
        }
        impl Default for SqueezeOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for SqueezeOptionsT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "SqueezeOptionsT {{ squeeze_dims: {:?} }}",
                    self.squeeze_dims
                )
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SqueezeOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SqueezeOptions_NativeTableType = root::tflite::SqueezeOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SqueezeOptions_FlatBuffersVTableOffset {
            VT_SQUEEZE_DIMS = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SplitOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub num_splits: i32,
        }
        impl Default for SplitOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SplitOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SplitOptions_NativeTableType = root::tflite::SplitOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SplitOptions_FlatBuffersVTableOffset {
            VT_NUM_SPLITS = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SplitVOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub num_splits: i32,
        }
        impl Default for SplitVOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SplitVOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SplitVOptions_NativeTableType = root::tflite::SplitVOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SplitVOptions_FlatBuffersVTableOffset {
            VT_NUM_SPLITS = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct StridedSliceOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub begin_mask: i32,
            pub end_mask: i32,
            pub ellipsis_mask: i32,
            pub new_axis_mask: i32,
            pub shrink_axis_mask: i32,
        }
        impl Default for StridedSliceOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct StridedSliceOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type StridedSliceOptions_NativeTableType = root::tflite::StridedSliceOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StridedSliceOptions_FlatBuffersVTableOffset {
            VT_BEGIN_MASK = 4,
            VT_END_MASK = 6,
            VT_ELLIPSIS_MASK = 8,
            VT_NEW_AXIS_MASK = 10,
            VT_SHRINK_AXIS_MASK = 12,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct LogSoftmaxOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for LogSoftmaxOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LogSoftmaxOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LogSoftmaxOptions_NativeTableType = root::tflite::LogSoftmaxOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct CastOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub in_data_type: root::tflite::TensorType,
            pub out_data_type: root::tflite::TensorType,
        }
        impl Default for CastOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct CastOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type CastOptions_NativeTableType = root::tflite::CastOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CastOptions_FlatBuffersVTableOffset {
            VT_IN_DATA_TYPE = 4,
            VT_OUT_DATA_TYPE = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct DequantizeOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for DequantizeOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct DequantizeOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type DequantizeOptions_NativeTableType = root::tflite::DequantizeOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct MaximumMinimumOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for MaximumMinimumOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct MaximumMinimumOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type MaximumMinimumOptions_NativeTableType = root::tflite::MaximumMinimumOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct TileOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for TileOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct TileOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type TileOptions_NativeTableType = root::tflite::TileOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ArgMaxOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub output_type: root::tflite::TensorType,
        }
        impl Default for ArgMaxOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ArgMaxOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ArgMaxOptions_NativeTableType = root::tflite::ArgMaxOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ArgMaxOptions_FlatBuffersVTableOffset {
            VT_OUTPUT_TYPE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ArgMinOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub output_type: root::tflite::TensorType,
        }
        impl Default for ArgMinOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ArgMinOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ArgMinOptions_NativeTableType = root::tflite::ArgMinOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ArgMinOptions_FlatBuffersVTableOffset {
            VT_OUTPUT_TYPE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct GreaterOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for GreaterOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct GreaterOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type GreaterOptions_NativeTableType = root::tflite::GreaterOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct GreaterEqualOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for GreaterEqualOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct GreaterEqualOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type GreaterEqualOptions_NativeTableType = root::tflite::GreaterEqualOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct LessOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for LessOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LessOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LessOptions_NativeTableType = root::tflite::LessOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct LessEqualOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for LessEqualOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LessEqualOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LessEqualOptions_NativeTableType = root::tflite::LessEqualOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct NegOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for NegOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct NegOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type NegOptions_NativeTableType = root::tflite::NegOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SelectOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for SelectOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SelectOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SelectOptions_NativeTableType = root::tflite::SelectOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SliceOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for SliceOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SliceOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SliceOptions_NativeTableType = root::tflite::SliceOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct TransposeConvOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub padding: root::tflite::Padding,
            pub stride_w: i32,
            pub stride_h: i32,
        }
        impl Default for TransposeConvOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct TransposeConvOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type TransposeConvOptions_NativeTableType = root::tflite::TransposeConvOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TransposeConvOptions_FlatBuffersVTableOffset {
            VT_PADDING = 4,
            VT_STRIDE_W = 6,
            VT_STRIDE_H = 8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ExpandDimsOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for ExpandDimsOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ExpandDimsOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ExpandDimsOptions_NativeTableType = root::tflite::ExpandDimsOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SparseToDenseOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub validate_indices: bool,
        }
        impl Default for SparseToDenseOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SparseToDenseOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SparseToDenseOptions_NativeTableType = root::tflite::SparseToDenseOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SparseToDenseOptions_FlatBuffersVTableOffset {
            VT_VALIDATE_INDICES = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct EqualOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for EqualOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct EqualOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type EqualOptions_NativeTableType = root::tflite::EqualOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct NotEqualOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for NotEqualOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct NotEqualOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type NotEqualOptions_NativeTableType = root::tflite::NotEqualOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ShapeOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub out_type: root::tflite::TensorType,
        }
        impl Default for ShapeOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ShapeOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ShapeOptions_NativeTableType = root::tflite::ShapeOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ShapeOptions_FlatBuffersVTableOffset {
            VT_OUT_TYPE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct RankOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for RankOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct RankOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type RankOptions_NativeTableType = root::tflite::RankOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct PowOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for PowOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct PowOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type PowOptions_NativeTableType = root::tflite::PowOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct FakeQuantOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub min: f32,
            pub max: f32,
            pub num_bits: i32,
            pub narrow_range: bool,
        }
        impl Default for FakeQuantOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct FakeQuantOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type FakeQuantOptions_NativeTableType = root::tflite::FakeQuantOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum FakeQuantOptions_FlatBuffersVTableOffset {
            VT_MIN = 4,
            VT_MAX = 6,
            VT_NUM_BITS = 8,
            VT_NARROW_RANGE = 10,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct PackOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub values_count: i32,
            pub axis: i32,
        }
        impl Default for PackOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct PackOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type PackOptions_NativeTableType = root::tflite::PackOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PackOptions_FlatBuffersVTableOffset {
            VT_VALUES_COUNT = 4,
            VT_AXIS = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct LogicalOrOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for LogicalOrOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LogicalOrOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LogicalOrOptions_NativeTableType = root::tflite::LogicalOrOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct OneHotOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub axis: i32,
        }
        impl Default for OneHotOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct OneHotOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type OneHotOptions_NativeTableType = root::tflite::OneHotOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum OneHotOptions_FlatBuffersVTableOffset {
            VT_AXIS = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct AbsOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for AbsOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct AbsOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type AbsOptions_NativeTableType = root::tflite::AbsOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct HardSwishOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for HardSwishOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct HardSwishOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type HardSwishOptions_NativeTableType = root::tflite::HardSwishOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct LogicalAndOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for LogicalAndOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LogicalAndOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LogicalAndOptions_NativeTableType = root::tflite::LogicalAndOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct LogicalNotOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for LogicalNotOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LogicalNotOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LogicalNotOptions_NativeTableType = root::tflite::LogicalNotOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct UnpackOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub num: i32,
            pub axis: i32,
        }
        impl Default for UnpackOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct UnpackOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type UnpackOptions_NativeTableType = root::tflite::UnpackOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum UnpackOptions_FlatBuffersVTableOffset {
            VT_NUM = 4,
            VT_AXIS = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct FloorDivOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for FloorDivOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct FloorDivOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type FloorDivOptions_NativeTableType = root::tflite::FloorDivOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SquareOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for SquareOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SquareOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SquareOptions_NativeTableType = root::tflite::SquareOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ZerosLikeOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for ZerosLikeOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ZerosLikeOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ZerosLikeOptions_NativeTableType = root::tflite::ZerosLikeOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct FillOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for FillOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct FillOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type FillOptions_NativeTableType = root::tflite::FillOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct FloorModOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for FloorModOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct FloorModOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type FloorModOptions_NativeTableType = root::tflite::FloorModOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct RangeOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for RangeOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct RangeOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type RangeOptions_NativeTableType = root::tflite::RangeOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LeakyReluOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub alpha: f32,
        }
        impl Default for LeakyReluOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct LeakyReluOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type LeakyReluOptions_NativeTableType = root::tflite::LeakyReluOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LeakyReluOptions_FlatBuffersVTableOffset {
            VT_ALPHA = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct SquaredDifferenceOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for SquaredDifferenceOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SquaredDifferenceOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type SquaredDifferenceOptions_NativeTableType = root::tflite::SquaredDifferenceOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct MirrorPadOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub mode: root::tflite::MirrorPadMode,
        }
        impl Default for MirrorPadOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct MirrorPadOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type MirrorPadOptions_NativeTableType = root::tflite::MirrorPadOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MirrorPadOptions_FlatBuffersVTableOffset {
            VT_MODE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct UniqueOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub idx_out_type: root::tflite::TensorType,
        }
        impl Default for UniqueOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct UniqueOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type UniqueOptions_NativeTableType = root::tflite::UniqueOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum UniqueOptions_FlatBuffersVTableOffset {
            VT_IDX_OUT_TYPE = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ReverseV2OptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for ReverseV2OptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ReverseV2Options {
            pub _base: root::flatbuffers::Table,
        }
        pub type ReverseV2Options_NativeTableType = root::tflite::ReverseV2OptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct AddNOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for AddNOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct AddNOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type AddNOptions_NativeTableType = root::tflite::AddNOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct GatherNdOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for GatherNdOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct GatherNdOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type GatherNdOptions_NativeTableType = root::tflite::GatherNdOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct WhereOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for WhereOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct WhereOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type WhereOptions_NativeTableType = root::tflite::WhereOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct ReverseSequenceOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub seq_dim: i32,
            pub batch_dim: i32,
        }
        impl Default for ReverseSequenceOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct ReverseSequenceOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type ReverseSequenceOptions_NativeTableType = root::tflite::ReverseSequenceOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ReverseSequenceOptions_FlatBuffersVTableOffset {
            VT_SEQ_DIM = 4,
            VT_BATCH_DIM = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct MatrixDiagOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for MatrixDiagOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct MatrixDiagOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type MatrixDiagOptions_NativeTableType = root::tflite::MatrixDiagOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct QuantizeOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for QuantizeOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct QuantizeOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type QuantizeOptions_NativeTableType = root::tflite::QuantizeOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct MatrixSetDiagOptionsT {
            pub _base: root::flatbuffers::NativeTable,
        }
        impl Default for MatrixSetDiagOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct MatrixSetDiagOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type MatrixSetDiagOptions_NativeTableType = root::tflite::MatrixSetDiagOptionsT;
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct IfOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub then_subgraph_index: i32,
            pub else_subgraph_index: i32,
        }
        impl Default for IfOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct IfOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type IfOptions_NativeTableType = root::tflite::IfOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum IfOptions_FlatBuffersVTableOffset {
            VT_THEN_SUBGRAPH_INDEX = 4,
            VT_ELSE_SUBGRAPH_INDEX = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct WhileOptionsT {
            pub _base: root::flatbuffers::NativeTable,
            pub cond_subgraph_index: i32,
            pub body_subgraph_index: i32,
        }
        impl Default for WhileOptionsT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct WhileOptions {
            pub _base: root::flatbuffers::Table,
        }
        pub type WhileOptions_NativeTableType = root::tflite::WhileOptionsT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WhileOptions_FlatBuffersVTableOffset {
            VT_COND_SUBGRAPH_INDEX = 4,
            VT_BODY_SUBGRAPH_INDEX = 6,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct OperatorCodeT {
            pub _base: root::flatbuffers::NativeTable,
            pub builtin_code: root::tflite::BuiltinOperator,
            pub custom_code: root::std::string,
            pub version: i32,
        }
        impl Default for OperatorCodeT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct OperatorCode {
            pub _base: root::flatbuffers::Table,
        }
        pub type OperatorCode_NativeTableType = root::tflite::OperatorCodeT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum OperatorCode_FlatBuffersVTableOffset {
            VT_BUILTIN_CODE = 4,
            VT_CUSTOM_CODE = 6,
            VT_VERSION = 8,
        }
        #[repr(C)]
        pub struct OperatorT {
            pub _base: root::flatbuffers::NativeTable,
            pub opcode_index: u32,
            pub inputs: root::std::vector,
            pub outputs: root::std::vector,
            pub builtin_options: root::tflite::BuiltinOptionsUnion,
            pub custom_options: root::std::vector,
            pub custom_options_format: root::tflite::CustomOptionsFormat,
            pub mutating_variable_inputs: [u64; 5usize],
            pub intermediates: root::std::vector,
        }
        impl Default for OperatorT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for OperatorT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write ! (f , "OperatorT {{ inputs: {:?}, outputs: {:?}, builtin_options: {:?}, custom_options: {:?}, custom_options_format: {:?}, mutating_variable_inputs: opaque, intermediates: {:?} }}" , self . inputs , self . outputs , self . builtin_options , self . custom_options , self . custom_options_format , self . intermediates)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Operator {
            pub _base: root::flatbuffers::Table,
        }
        pub type Operator_NativeTableType = root::tflite::OperatorT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Operator_FlatBuffersVTableOffset {
            VT_OPCODE_INDEX = 4,
            VT_INPUTS = 6,
            VT_OUTPUTS = 8,
            VT_BUILTIN_OPTIONS_TYPE = 10,
            VT_BUILTIN_OPTIONS = 12,
            VT_CUSTOM_OPTIONS = 14,
            VT_CUSTOM_OPTIONS_FORMAT = 16,
            VT_MUTATING_VARIABLE_INPUTS = 18,
            VT_INTERMEDIATES = 20,
        }
        #[repr(C)]
        pub struct SubGraphT {
            pub _base: root::flatbuffers::NativeTable,
            pub tensors: root::std::vector,
            pub inputs: root::std::vector,
            pub outputs: root::std::vector,
            pub operators: root::std::vector,
            pub name: root::std::string,
        }
        impl Default for SubGraphT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for SubGraphT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "SubGraphT {{ tensors: {:?}, inputs: {:?}, outputs: {:?}, operators: {:?} }}",
                    self.tensors, self.inputs, self.outputs, self.operators
                )
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct SubGraph {
            pub _base: root::flatbuffers::Table,
        }
        pub type SubGraph_NativeTableType = root::tflite::SubGraphT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SubGraph_FlatBuffersVTableOffset {
            VT_TENSORS = 4,
            VT_INPUTS = 6,
            VT_OUTPUTS = 8,
            VT_OPERATORS = 10,
            VT_NAME = 12,
        }
        #[repr(C)]
        pub struct BufferT {
            pub _base: root::flatbuffers::NativeTable,
            pub data: root::std::vector,
        }
        impl Default for BufferT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for BufferT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "BufferT {{ data: {:?} }}", self.data)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Buffer {
            pub _base: root::flatbuffers::Table,
        }
        pub type Buffer_NativeTableType = root::tflite::BufferT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Buffer_FlatBuffersVTableOffset {
            VT_DATA = 4,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq, Eq)]
        pub struct MetadataT {
            pub _base: root::flatbuffers::NativeTable,
            pub name: root::std::string,
            pub buffer: u32,
        }
        impl Default for MetadataT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Metadata {
            pub _base: root::flatbuffers::Table,
        }
        pub type Metadata_NativeTableType = root::tflite::MetadataT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Metadata_FlatBuffersVTableOffset {
            VT_NAME = 4,
            VT_BUFFER = 6,
        }
        #[repr(C)]
        pub struct ModelT {
            pub _base: root::flatbuffers::NativeTable,
            pub version: u32,
            pub operator_codes: root::std::vector,
            pub subgraphs: root::std::vector,
            pub description: root::std::string,
            pub buffers: root::std::vector,
            pub metadata_buffer: root::std::vector,
            pub metadata: root::std::vector,
        }
        impl Default for ModelT {
            fn default() -> Self {
                let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
                unsafe {
                    ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
                    s.assume_init()
                }
            }
        }
        impl ::std::fmt::Debug for ModelT {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write ! (f , "ModelT {{ operator_codes: {:?}, subgraphs: {:?}, buffers: {:?}, metadata_buffer: {:?}, metadata: {:?} }}" , self . operator_codes , self . subgraphs , self . buffers , self . metadata_buffer , self . metadata)
            }
        }
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Model {
            pub _base: root::flatbuffers::Table,
        }
        pub type Model_NativeTableType = root::tflite::ModelT;
        #[repr(u16)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Model_FlatBuffersVTableOffset {
            VT_VERSION = 4,
            VT_OPERATOR_CODES = 6,
            VT_SUBGRAPHS = 8,
            VT_DESCRIPTION = 10,
            VT_BUFFERS = 12,
            VT_METADATA_BUFFER = 14,
            VT_METADATA = 16,
        }
        #[doc = " Abstract interface that returns TfLiteRegistrations given op codes or custom\n op names. This is the mechanism that ops being referenced in the flatbuffer\n model are mapped to executable function pointers (TfLiteRegistrations)."]
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct OpResolver {
            pub _bindgen_opaque_blob: u64,
        }
        #[doc = " An RAII object that represents a read-only tflite model, copied from disk,\n or mmapped. This uses flatbuffers as the serialization format.\n\n NOTE: The current API requires that a FlatBufferModel instance be kept alive\n by the client as long as it is in use by any dependent Interpreter\n instances.\n <pre><code>\n using namespace tflite;\n StderrReporter error_reporter;\n auto model = FlatBufferModel::BuildFromFile(\"interesting_model.tflite\",\n                                             &error_reporter);\n MyOpResolver resolver;  // You need to subclass OpResolver to provide\n                         // implementations.\n InterpreterBuilder builder(*model, resolver);\n std::unique_ptr<Interpreter> interpreter;\n if(builder(&interpreter) == kTfLiteOk) {\n   .. run model inference with interpreter\n }\n </code></pre>\n\n OpResolver must be defined to provide your kernel implementations to the\n interpreter. This is environment specific and may consist of just the\n builtin ops, or some custom operators you defined to extend tflite."]
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct FlatBufferModel {
            pub _bindgen_opaque_blob: [u64; 3usize],
        }
        #[doc = " Build an interpreter capable of interpreting `model`.\n\n model: A model whose lifetime must be at least as long as any\n   interpreter(s) created by the builder. In principle multiple interpreters\n   can be made from a single model.\n op_resolver: An instance that implements the OpResolver interface, which\n maps\n   custom op names and builtin op codes to op registrations. The lifetime\n   of the provided `op_resolver` object must be at least as long as the\n   InterpreterBuilder; unlike `model` and `error_reporter`, the `op_resolver`\n   does not need to exist for the duration of any created Interpreter\n   objects.\n error_reporter: a functor that is called to report errors that handles\n   printf var arg semantics. The lifetime of the `error_reporter` object must\n   be greater than or equal to the Interpreter created by operator().\n\n Returns a kTfLiteOk when successful and sets interpreter to a valid\n Interpreter. Note: The user must ensure the model lifetime (and error\n reporter, if provided) is at least as long as interpreter's lifetime."]
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct InterpreterBuilder {
            pub _bindgen_opaque_blob: [u64; 14usize],
        }
        pub mod ops {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod builtin {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
                pub struct BuiltinOpResolver {
                    pub _bindgen_opaque_blob: [u64; 15usize],
                }
            }
        }
    }
    pub mod flatbuffers {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type voffset_t = u16;
        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct Table {
            pub data_: [u8; 1usize],
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct NativeTable {
            pub _bindgen_opaque_blob: u64,
        }
    }
}
